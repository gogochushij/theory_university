\lecture{5}{29 April}{\dag}
\chapter{Коммуникационная сложность}
Пусть у нас есть два игрока: Алиса и Боб. Они могут отправлять друг другу сообщения и хотят посчитать функцию (или отношение) $ f \colon X \times Y \to Z$.
Будем говорить, что они \textit{решают коммуникационную задачу} для функции $ f$, если:
\begin{enumerate}
	\item множества $ X, Y, Z$ и функция $ f$ известны обоим игрокам,
	\item	Алиса знает некоторое $x \in  X$,
	\item	Боб знает некоторое $ y \in Y$,
	\item	Алиса и Боб стремятся вычислить $ f(x, y)$.
\end{enumerate}

\section{Детерминированная модель}
\begin{defn}[Коммуникационный протокол]
	\selectedFont{Коммуникационный протокол} для функции $ f\colon X\times Y \to  Z$ --- корневое двоичное дерево, которое описывает совместное вычисление Алисой и Бобом функции $ f$. В этом дереве:
	   \begin{itemize}
		   \item каждая внутренняя вершина $ v$ помечена меткой $ a$ или $ b$, означающей очередь хода Алисы или Боба соответственно;
		   \item для каждой вершины $ v$, помеченной $ a$, определена функция  $ g_v\colon X \to \{0, 1\}$, которая задает бит, который Алиса отправит  Бобу, если вычисление будет находится в $ v$; аналогично для каждой вершины $ v$ с пометкой $ b$ определена функция  $ h_v\colon Y \to \{0, 1\}$ для сообщений Боба;
		\item у каждой внутренней вершины есть два потомка, ребро к первому помечено $ 0$, ко второму --- $ 1$;
		\item каждый лист помечен значением из множества $ Z$.
	   \end{itemize}
	   Каждая пара входов $ (x, y)$ определяют путь от корня до листа в этом дереве. 
	   Будем  говорить, что коммуникационный протокол \selectedFont{вычисляет} функцию $ f$, если для всех пар  $ (x, y) \in  X \times Y$ этот путь заканчивается в листе с пометкой $ f(x, y)$.

	   \selectedFont{Коммуникационной сложностью} функции $ f$ называется наименьшая глубина протокола, \\вычисляющего  $ f$. Обозначается  $ D(f)$ или $ D^{cc}(f)$.

	   Каждой функции можем сопоставить матрицу  $ X \times Y$, где в клетке $ (x_i, y_j)$ стоит значение  $ f(x_i, y_j)$.
\end{defn}

\subsection{Нижние оценки для детерминированного случая}
% картинка
Пусть наша функция $ f\colon X \times Y \to  Z$. 
Запишем  для нее коммуникационную матрицу $ M$ размера $ \lvert X \rvert \times \lvert Y \rvert $, где $ M_{x, y} = f(x, y)$.

Рассмотрим такое подмножество $ R_v$ множества $ X \times Y$, что $(x, y) \in R_v \Longleftrightarrow \text{ протокол приходит в }  v$.

\begin{lm}\label{lm:lm3}
	$ R_v = X_v \times Y_v$ --- комбинаторный прямоугольник.
\end{lm}
Рассмотрим \textbf{два} доказательства:
\begin{proof}
	Пусть $ (x, y)$ и  $ (x', y')$ принадлежат  $ R_v$. Тогда  $ (x, y')$ и  $ (x', y)$ тоже принадлежат  $ R_v$, так как $ a(x) = a(x')$ и  $ b(y) = b(y')$, где $ a$ и $ b$ - ответы Алисы и Боба.

	А из этого следует, что это комбинаторный прямоугольник.
\end{proof}
\begin{proof}
	Посмотрим на множество $ X\times Y$ как на таблицу.

    Пусть Алиса перешла по какому-то ребру. Вся таблица разделилась на две части по горизонтали: какие-то строки соответствуют $ x \in X$, для которых Алиса отсылает  $ 0$, а какие-то для $ 1$. 

	Если потом ход делает Боб, то он делит все текущие прямоугольники на две части по вертикали. 

% \begin{figure}[ht]
%     \centering
%     \incfig{table-proof}
%     \label{fig:table-proof}
% \end{figure}
И так далее.

В прямоугольнике для листа у всех элементов одинаковый ответ. То есть исходную матрицу можно разбить на комбинаторные прямоугольники, причем они естественно не пересекаются.
\end{proof}

\vspace{1em}
Давайте продолжим смотреть на матрицу. Зафиксируем какой-то $O_1 \in Z$. Тогда есть входы $(x,y)$ такие, что протокол ведет их к $O_1$. По предыдущей лемме множество всех таких входных данных образует комбинаторный прямоугольник. Тогда, если $Z = \{ O_1, \dots, O_{|Z|}\}$ и для каждого $O_i$ смотрим на соответствующий комбинаторный прямоугольник мы получаем разбиение исходной матрицы. 

\vspace{1em}
Пусть $ Z = \{0, 1\}$. Рассмотрим величины $ \chi_{0}(f)$ и $ \chi_1(f)$, первая равна минимальному числу непересекающихся \\ комбинаторных прямоугольников, которыми можно покрыть все нули в таблице, в вторая --- все единицы.

Тогда листьев в двоичном дереве протокола будет хотя бы $ \chi_0(f) + \chi_1(f)$. Следовательно, $ D(f) \ge \log( \chi_0(f) + \chi_1(f))$.

Но эта оценка не всегда точна. Можно рассмотреть следующее разбиение на картинке \ref{fig:bad-rect}. 

Здесь $ \chi_0(f)  + \chi_1(f) = 4 + 1 = 5$.
\begin{figure}[h]
    \centering
    \incfig{bad-rect}
    \caption{Пример неточной оценки}
    \label{fig:bad-rect}
\end{figure}
Заметим, что для такого разбиения не существует дерева протокола. Посмотрим на первое действие игроков. Прямоугольник должен разделиться на две части, но любой разрез вдоль сторон разрежет один из внутренних прямоугольников.

Поэтому любой протокол не будет соответствовать этому разбиению. А тогда листьев будет больше пяти.

\vspace{1.5em}
\begin{thm}[G,PW 16]
Пусть $ \chi$ --- минимальное число  прямоугольников в разбиении.
	Существует $ f$ для которой
	 \[
		 D(f) \ge \log^{2 - \varepsilon } \chi (M_f)
	.\] 
	Без доказательства.
\end{thm}



\section{Методы оценки коммуникационной сложности}
\subsection{Метод ранга}
Пусть $ M_f $ --- таблица некоторой функции $ f$ со значениями  $ \{0, 1\}$.

Обозначим за $  x_1, \ldots x_n$ листья дерева коммуникационного протокола для функции $ f$, а  $ R_{x_1}, \ldots R_{x_n}$ соответствующие им прямоугольники в $ M_f$.
$\rk (M_f)$ --- ранг матрицы $M_f$.
 \[
	 \rk (M_f) \le \sum_{i=1}^{n} \rk R_{x_i} \le  \sum_{i=1}^{n} 1 = \# \text{ одноцветных прямоугольников в разбиении}
.\] 

Тогда коммуникационная сложность не меньше $ \log \rk (M_f)$.

Этот метод называется \selectedFont{методом ранга}.

\begin{lm}\label{lm:minsum}
    Для любой функции $ f\colon \{0, 1\}^{n} \times  \{0, 1\}^{m} \to \{0, 1\}^{k}$ коммуникационная сложность не больше $ \min \{n+k, n+m, m+k\}$.
\end{lm}
\begin{proof*}
	Пусть Алиса и Боб хотят вычислить значение $ f(x, y)$, причем  $ x$ знает только Алиса, а $ y$ --- только Боб.
	\begin{itemize}
		\item Для $ n+m$ они просто отправляют друг другу свои числа и локально вычисляют $ f$.
		\item Для $ n+k$ и  $ m+k$ достаточно просто отправить свое число второму, он посчитает значение функции и отправит обратно.
	\end{itemize}

\end{proof*}

\paragraph{Оценка для $ \mathbf{EQ}$}
Определим функцию $ \EQ(x, y) = (x = y) \colon \{0, 1\}^{n} \times \{0, 1\}^{n} \to \{0, 1\}$.

Для функции $\EQ$ матрица $ M_{\EQ}$ будет диагональной $ 2^{n}\times 2^{n}$.

Поэтому ее ранг равен $ 2^{n}$, а тогда коммуникационная сложность
$ D(\EQ) \ge \log 2^{n} + 1= n +1$.
\footnote{Дополнительная единица возникает из-за того, что нам нужен еще хотя бы один лист для нуля.}

С другой стороны, она не больше $ n+1$, так как за  $ n+1$ вопрос можно просто сравнить все биты ($ n$) и отослать результат обратно (1).

\paragraph{Оценка для $\mathbf{GT}$}
Определим функцию $ \GT(x, y) = (x \ge y)\colon \{0, 1\}^{n} \times \{0, 1\}^{n} \to  \{0, 1\}$.

Докажем, что ее коммуникационная сложность $ D(\GT) = n+1$. 

Матрица будет треугольной, поэтому $ \rk M_{\GT} = 2^{n}$. 
А тогда $ D(\GT) \ge \log 2^{n} + 1= n+1$.

По \hyperref[lm:minsum]{лемме \ref{lm:minsum}} $ D(\GT) \le n+1$, поэтому она в точности $ n+1$.


\subsection{Fooling Set}
Рассмотрим коммуникационную матрицу некоторой функции $ f$. Пусть мы хотим выбрать некоторое множество клеток 
\[
	S = \{(x_1, y_1), (x_2, y_2) , \ldots (x_{n}, y_{n})\}
,\] 
такое что каждая пара точек не лежит в одном прямоугольнике.

Чтобы все были в разных прямоугольниках, для всех $ i \ne j \in [n]$ либо клетка $ (x_i, y_j)$, либо  $ (x_j, y_i)$ была  другого цвета\footnote{Цвет = 0 или 1}.

Из условия  на разные прямоугольники следует, что в дереве не менее $ n$ листьев, а поэтому высота хотя бы  $  \log n$.

\paragraph{Оценка для $\mathbf{EQ}$}
Применим этот метод к $ \EQ$. Берем в качестве точек главную диагональ из единиц. Никакие из них не находятся в одном одноцветном прямоугольнике. 

Следовательно, высота дерева не меньше $ n$.

Плюс, так как нужен хотя бы один лист для нуля, $ n$ не хватит, следовательно,  $ D(\EQ) \ge n+1$.

\begin{thm}
	Если существует \textbf{Fooling set} размера $ s$, то $ \rk_R s \ge \sqrt{ s} - \o(1) $.
	Без доказательства.
\end{thm}


\section{Балансировка протоколов}
\begin{thm}
	Пусть для функции $ f$ существует коммуникационный протокол $ P$ с $ l$ листьями. Тогда  $ D(f) \le 3 \log l$.\footnote{Вроде на лекциях этого не было, зато есть в билетах}
\end{thm}
\begin{proof*}
	\begin{lm}
	    В двоичном дереве с $ l$ листьями можно найти внутреннюю вершину  $ u$, которая разбивает граф на три части, каждая из которых содержит не более   $ \frac{l}{2}$ листьев.
	\end{lm}
	\begin{proof*}
	    Обозначим через $ l_u$ поддерево с корнем во внутренней вершине $ u$.

		Найдем самую низкую вершину $ u$, для которой  $  \lvert l_u \rvert > \frac{l}{2}$. Пусть ее дети $ v $ и  $ w$, причем $ l_v \le \frac{l}{2}$  и $ l_w \le \frac{l}{2}$ (если бы было не так, то могли бы взять ребенка у которого нарушается неравенство).

		При этом количество листьев не из поддерева $ u$ будет меньше  $ l - l_u < \frac{l}{2}$.

		Следовательно, $ u$ подходит.
	\end{proof*}
	
	\begin{note}
	Такая вершина называется \textit{центроид}.
	\end{note}
	
	\vspace{1em}
	\textit{Интуиция:} Хотим перебалансировать дерево так, чтобы прыгать только по центроидам, в следствие чего глубина нового протокола уменьшиться (центроидная декомпозиция).\\

    Опишем протокол $ P_0$ для вычисления  $ f$. 

	\begin{itemize}
		\item Зафиксируем вершину $ u$, которая делит исходный протокол на три части, в каждой из которых не более $  \frac{l}{2}$ листьев.
		\item Пусть вершина $ u$ соответствует ходу Алисы. 
			Сначала проверим, что и Алиса, и Боб доходят до этой вершины в исходном протоколе $ P$: отправляем по одному биту (сначала Алиса, потом Боб обратно отсылает результат).

			\begin{itemize}
				\item Если и Боб, и Алиса могут добраться (по \hyperref[lm:lm3]{лемме \ref{lm:lm3}}), то Алиса говорит Бобу, в какое поддерево она бы пошла с ее информацией. Тем самым мы опускаемся в одно из поддеревьев, листьев в котором не больше $ \frac{l}{2}$.
				\item Если нет, то нам точно не подходят оба поддерева $ u$ (в них нет листа ответа для $ (x, y)$), а поэтому нужно подняться в третье поддерево (к родителю  $ u$) --- для этого Алиса может ничего не отправлять, так как Боб уже знает, что спуска вниз не будет.
			\end{itemize}
			Таким образом, обменявшись $ \le$ тремя битами, Алиса и Боб уменьшают количество листьев вдвое. Теперь мы можем не рассматривать недостижимые вершины и составить рекурсивно новый протокол $  P_1$, где листьев $ l_1 \le \frac{l}{2}$. 

			В итоге на один <<шаг>> нужно не более трех битов, при этом количество листьев уменьшается в два раза, следовательно, сложность такого протокола будет не более $ 3 \log l$.
	\end{itemize}
\end{proof*}


\section{Сложная функция. Теорема Шеннона}

\begin{defn}
	\selectedFont{Формульная (схемная) сложность} $ L(f)$ формулы  $ f$ --- минимальное возможное число вершин двоичного дерева, вычисляющего  $ f$.
\end{defn}

\begin{thm}[Шеннон]
	Существует $ f \colon \{0, 1\}^{n} \to  \{0, 1\}$, такая что 
	$$ L(f) \ge \Omega\left( \tfrac{2^{n}}{n} \right) .$$
\end{thm}
\begin{proof}
\begin{figure}[h]
	\begin{minipage}{0.7\textwidth}
    Всего функций такого вида $ 2^{2^{n}}$, так как можно задать таблицей истинности.

	Посчитаем число схем. Каждую схему можно представить в виде ациклического графа и того, что записано в его узлах.

	Пусть каждая вершина (считаем, что размер схемы $ S$, поэтому их столько же) выбирает себе двух предков. Для этого она должна хранить их номера. 
	Так же в каждую вершину нужно записать операцию ($ \land$ или $ \lor$), а на ребре можно ставить отрицание. Чтобы это закодировать хватит 
	$$
	\underbrace{S \cdot 2 ( \log S + \log n)}_{\text{у вершины 2 предка: либо другие вершины, либо вход}} + \underbrace{3S}_{\text{операция плюс отрицания}}
	$$
	\end{minipage}
	\begin{minipage}{0.27\textwidth}
		\centering
		\incfig{scheme-hard}
		\label{fig:scheme-hard}
	\end{minipage}
\end{figure}

	Итого схем может быть: $2^{ S \cdot 2 (\log S + \log n) + 3S}$.

	Чтобы мы могли закодировать все функции в виде схем тогда и только тогда, когда 
	схем не меньше  количества функций:
	\begin{align*}
		2^{S \cdot  2( \log S + \log n) + 3S} &\ge  2^{2^n} \\
		S \cdot  ( 2\log S + 2\log n + 3)&\ge  2^n 
	\end{align*}
	Пусть для всех схем $S < \frac{1}{4}\cdot\frac{2^n}{n}$, тогда 
	\begin{align*}
	    &S\cdot(2\log S + 2 \log n + 3) < \frac{2^n}{4n}(2n - 4 + 3) = 2^n\left(\frac{1}{2} - \frac{1}{4n}\right) \le 2^n \cdot \frac{1}{2} < 2^n
	\end{align*}
	Противоречие. Значит есть схема со сложностью $\ge \frac{1}{4}\cdot\frac{2^n}{n}$.
\end{proof}

\textbf{Открытый вопрос:} Можно ли предъявить $ f \in \NP$, что $ L(f) \ge  10n$


\section{Теорема Карчмера-Вигдерсона}

Пусть нам дана $ f\colon \{0, 1\}^{n } \to  \{0, 1\}$.

Алиса получает число $ x \in f^{-1}(1)$, а Боб $ y \in f^{-1}(0)$. Их цель найти любой бит, в котором $x$ и $y$ отличаются.

\begin{thm}[Karchmer-Wigderson, 1990]
	$ L(f) $ --- размер минимальной формулы для  $ f$, тогда и только тогда $ L(f)$ --- размер минимального протокола для  $ KW_f$
\end{thm}
\begin{proof}
    $ $
    \begin{description}
		\item [\boxed{ 1 \Longrightarrow 2}] Нарисуем дерево вверх корнем. Также спустим все отрицания к листьям. Пусть в корне считается функция $ f = g \vee h$, где  $ g$ и  $h$ --- соседи  $ f$.

			Тогда $ f(x) = 1$,  $ f(y) = 0$. Тогда $g(y) = h(y) = 0    $, а для Алисы хотя бы одно из двух значений единица.Тогда Алиса посылает информацию, где именно единица, то есть куда нам нужно спуститься (потому что в этом отрезке битов точно есть отличие). Далее игра продолжается по тем же правила рекурсивно. Стоит заметить, что если в вершине конъюнкция, то Боб пошлет информацию, где происходит обнуление. Так за глубину формулы мы нашли решение для $KW_f$ той же глубины. Т.е. оптимальный размер протокола меньше или равен $L(f)$.
		\item [\boxed{ 2 \Longrightarrow 1}] 
			Пусть у нас есть некоторый протокол для игры. Это некоторое дерево. Обозначим за $ R_v \coloneqq X_v \times Y_v$ --- прямоугольник входов для вершины $ v$, из которых мы получаем $ v$.

			Мы хотим построить $ f\colon \{0, 1\}^{n} \to \{0, 1\}$.

			Будем подниматься снизу и строить формулу по протоколу. Обозначим за $ f_v$ построенную формулу в вершине  $ v$. Хотим получить следующие свойства для формулы: $ f_v(X_v) = 1$ и  $ f_v(Y_v) = 0$.

			Если они выполняются, то $ \forall x \in X_v \colon f(x) = 1$ и $ \forall y \in Y_v \colon f(y) = 0$.

			В корне $ f = f_r$.

			\begin{itemize}
				\item Если мы в листе $ l$. Здесь написан некоторый ответ $i$. То есть $ \forall x \in X_l ~\forall y \in Y_l \colon x_i \ne  y_i$.

					Тогда либо $ x_i = 0 \wedge  y_i  = 1$, либо наоборот. (Причём одинаково для всех пар $ x_i, y_i$) % Пояснение?

					В качестве $ f_{l}(z) $ можем в первом случае взять $ \neg z_i$, во втором $z_i$.
				\item Теперь мы находимся в вершине $ v$ с потомками  $ a $ и $ b$.

					Если ходит Алиса, то прямоугольник  $ R_v$ разрезается на   $ R_a$ и  $ R_b$ горизонтально (если  Боб, то наоборот, вертикально).

					У нас уже есть две функции  $ f_a$ и  $ f_b$, построенные по предположению индукции.  $ \forall y \in Y_v\colon  f_a(y) = f_b(y) = 0$, так как $ Y_v = Y_a = Y_b$.
					А так как $ X_v \subseteq X_a \cup X_b$, $ \forall x \in X_v$ либо $ f_a(x) = 1$, либо  $ f_b(x) = 1$.
					Поэтому нам подходит  $ f_v \coloneqq f_a \vee f_b$.

					Если же ходит Боб нужно будет сделать конъюнкцию.
			\end{itemize}
    \end{description} 
\end{proof}


\section{Вероятностная модель}
Теперь Алиса и Боб могут подбрасывать монетки. Либо эти монетки (оракулы) \textit{публичны} (оба видят значения), либо \textit{приватны} (тогда никто не видит, кроме пользователя).

Каждый шаг будет зависеть от входа $ x$ и случайной строки  $ r \in \{0, 1\}^{l}$.

Так как Алиса или Боб в случае публичного оракула, могут закрыть глаза на сообщения другого, публичный протокол не меньше приватного.

\selectedFont{Вероятность ошибки} на входе $ (x, y)$ --- доля случайных слов $ r$, при которых протокол выдает неправильный ответ.

Скажем, что \selectedFont{протокол отработал корректно}, если\footnote{Вместо $\frac{2}{3}$ может быть любое $\varepsilon \in (\frac{1}{2}, 1)$ }
\[
	\forall x, y \colon \Pr[\pi(x, y) = f(x, y)] \ge \frac{2}{3}, \quad \pi(x, y) \text{ --- результат работы}
.\] 
\begin{defn}[]
	Вероятностный протокол \selectedFont{$ \varepsilon$ -вычисляет $ f$}, если для любой пары $ x, y$ с вероятностью не менее $ 1 - \varepsilon$ результат протокола равен $ f(x, y)$ (с точки зрения обоих игроков).

	Через $ R_{ \varepsilon }(f) $ обозначается минимальная высота вероятностного протокола $ \varepsilon $-вычисляющего $ f$. 

	Через $ R_{ \varepsilon }^{pub}$ --- минимальная высота в случае публичного протокола.
\end{defn}
\subsection{Эффективные протоколы для $ \mathbf{EQ}$ и  $ \mathbf{GT}$}
\begin{lm}\label{lm:eq}
	$ R^{pub}_{ \varepsilon } (\EQ) = \O( \log \varepsilon ^{-1})$
\end{lm}
\begin{proof*}
	Рассмотрим следующий протокол. На входах $ x, y \in  \{0, 1\}^{n}$ Алиса и Боб выбирают случайную строку $ r \in \{0, 1\}^{n}$, затем Алиса считает скалярное произведение $  \langle x, r \rangle$ над $ \mathbb{F}_2$ и передает результат (один бит) Бобу, который считает свое скалярное произведение $ \langle y, r \rangle$.  
	Если биты равны, отвечает $ 1$, иначе  $ 0$.

	\begin{itemize}
		\item Если  $ x = y$, то ответ точно будет одинаковый и протокол работает правильно.
		\item Если $ x \ne y$, протокол ошибается (то есть выдает единицу, хотя должен нуль), если $  \langle x  - y, r \rangle = 0$. Это линейное уравнение на $ r$. Соответственно, его решения --- некоторое линейное пространство размерности $ n-1$ над  $ \mathbb{F}_{2}$. 

			Тогда решений будет ровно $ 2^{n-1}$. А это половина от всех возможных $ r$. Следовательно, вероятность ошибки  $ \frac{1}{2}$.
	\end{itemize}
	Теперь просто повторяем этот протокол $ k$ раз с независимыми битами  $ r$, причем будем выдавать  $ 1$, если получили все  $k$ единиц. За счет этого теперь вероятность ошибки станет  $ 2^{-k}$. 

	Если мы хотим добиться ошибки $ \varepsilon $, достаточно повторить протокол $  \log \varepsilon ^{-1}$ раз.
\end{proof*}

\begin{lm}
	$ R_{ \varepsilon }^{pub}(\GT) = \O( \log n \cdot \log \frac{\log n}{\varepsilon})$
\end{lm}
\begin{proof*}
	Чтобы сравнить $ x, y \in \{0, 1\}^{n}$, Алисе и Бобу нужно найти первый (самый старший) бит, в котором их входы отличаются, и обменяться этими битами.

	Будем искать этот бит бинпоиском. Каждый раз мы делим текущий блок на две части и проводит тест на равенство левых частей (который мы умеем делать по \hyperref[lm:eq]{лемме \ref{lm:eq}}). Если они оказались равны, то выбираем правые, иначе левые, и запускаемся рекурсивно.

	После каждого деления блок уменьшается не меньше, чем в два раза, следовательно, тест на равенство нужно провести $ \O(\log n)$ раз.

	Чтобы общая вероятность была меньше $ \varepsilon $, вероятность ошибки на одной проверке должна быть меньше $ \delta  = \frac{\varepsilon}{\log n}$.

	В итоге получается $ R^{pub}_{ \varepsilon }(\GT) = \O( \log n \cdot  \log \tfrac{\log n}{\varepsilon})$.
\end{proof*}
