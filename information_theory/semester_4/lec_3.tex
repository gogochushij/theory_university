\lecture{3}{15 April}{\dag}
\subsection{Подсчет углов в графе}
Рассмотрим ориентированный граф.

Назовем треугольником тройку $ (x, y, z)$, если это цикл из трех вершин. Углом назовем тройку  $ (x, y, z)$, если есть ребра  $ xy$ и $xz$, при этом  $ y $ может совпадать  $ z$.

Чего в графе больше: углов или треугольников?
\begin{note}
	Каждое ребро тоже угол, например, $ (x, y, y)$.
\end{note}
\begin{thm}
    Число углов в графе всегда больше числа треугольников.
\end{thm}
\begin{proof}
 	Пусть случная величина $ \alpha = (X, Y, Z)$ равна случайному треугольнику.

	Так как распределение количества треугольников равномерно,
	\begin{align*}
		\log (\# \Delta)& = H(X, Y, Z)  = \tag{Chain rule} \\
					  &= H(X) + H(Y \mid  X) + H(Z \mid  Y, X) \le  \\
					  & \le  H(X) + H(Y \mid X) + H(Z \mid Y) = \tag{циклический сдвиг в треугольнике} \\
		 & = H(X) + 2 H(Y \mid X)
	\end{align*}
Найдем какое-то распределение на углах, энтропия которого хотя бы $ H(X) + 2H(Y \mid X)$, тогда эта сумма будет не более  $  \log (\# \angle)) $.
	% с картинкой будет лучше!!

	Пусть мы выбрали случайный треугольник $ (x, y, z)$. Оставим $ x$ и выберем для него найдем случайный треугольник с $ x$ и берем из него следующую за $ x$ вершину $ y'$. Повторяем эту операцию еще раз для $ x$ и находим  $ z'$. Тогда $ (x,  y', z')$ --- угол.
	\begin{align*}
		H(x, y', z') & = H(x) + H(y' \mid x) + H(z' \mid x, y') = \tag{Так как $ y'$ и  $ z'$ независимы при выбранном  $ x$}  \\
					 & =H(x) + H(y'\mid x) + H(z' \mid x) = \tag{Выбор аналогичный} \\
					 & = H(x) + 2 H(y' \mid x)
	\end{align*}
	$ H(x)$ здесь совпадает с  $ H(x) $ выше, так как мы выбираем треугольник и вершину аналогично.

	$ y'$ выбирается при фиксированном  $ x$ также, как и выше (выбрали случайный треугольник и в нем вершиной после $ x$ будет  $ y'$).

	Таким образом, мы нашли распределение с такой же энтропией.
\end{proof}

\chapter{Теория кодирования}
\section{Префиксные коды}
Код --- отображение алфавита $ C \colon \Sigma \to \{0, 1\}^{*}$.

Что хочется требовать?
\begin{enumerate}
    \item Однозначное декодирование. При этом не обязательно у каждой строки $ \{0, 1\}^{*}$ есть слово, но склейки нет.
	\item Префиксный код --- то есть код каждого символа не является префиксом кода другого. Очевидно, из этого следует предыдущий пункт.
\end{enumerate} 

\begin{thm}
    Любой однозначно декодируемый код можно переделать в префиксный с сохранением длин кодовых слов.
\end{thm}
\begin{proof}
	Пусть есть $  c_1, \ldots , c_n$ --- кодовые слова.

	Для префиксного кода $ \sum_{}^{} 2^{-\lvert c_i \rvert } \le 1$, причем, если если выполнено это неравенство, то есть префиксный код с такими длинами кодовых слов.

	Докажем, что для любого декодируемого кода выполнено такое неравенство.

	Построим многочлен для всех слов длины $ L$. 
	Для этого воспользуемся следующей идеей.
	Строка длины $L$ переходит в конкатенацию кодовых слов для каждого символа исходной строки. Давайте в кодовых словах заменим $0$ на $x$, а $1$ на $y$. Тогда всем кодовым словам соответствуют некоторые мономы (например, $c_i = 010$ соответствует моном $xyx$). Давайте будем считать, что $x$ и $y$ не коммутируют, чтобы удобнее было различать слова $xyx$, соответствующие $010$ и $xxy$, соответствующие $001$. Будем говорить, что слову $c_i$ соответствует $p_i(x,y)$. Тогда строка длины $L$ есть произведение $L$ таких мономов. Тогда коды всех слов длины $L$ можно представить в виде многочлена $P(x, y)$, в котором операция сложения будет разделять разные коды 

	\[
		P(x, y) = \left( \sum_{i}^{} p_i(x, y) \right) ^{L} = \sum_{j=L}^{L\cdot\max|c_i|} M_j(x, y)
	.\] 
	В $M_j(x, y)$ сгруппированны в сумму все мономы степени $j$, получающиеся при раскрытии скобок (то есть все различные слова длины $j$, получаемые из кодирования слов длины $L$). Так как код однозначно декодируемый, каждое слово является образом не более чем одной исходной строки. Тогда в $M_j(x, y)$ не более $2^j$ мономов.

	Посчитаем $ P(\frac{1}{2}, \frac{1}{2})$.

	\[
		P(\tfrac{1}{2},\tfrac{1}{2}) = \sum_{j=L}^{L\cdot\max|c_i|} M_{j}(\tfrac{1}{2},\tfrac{1}{2}) \le \sum_{j=L}^{\max_{i} c_i}2^{j} \cdot 2 ^{-j} = \O(L)
	.\] 

	Посчитаем еще раз по второму представлению
	\[
		P(\tfrac{1}{2},\tfrac{1}{2}) = \left( \sum_{i}^{} 2^{-\lvert c_i \rvert } \right) ^{L}
	.\] 
	Если сумма в скобках больше $ 1$, получаем экспоненциальную оценку снизу.
	Следовательно, для больших $ N$ она обгонит линейную. Противоречие.
	
	Как, используя это неравенство, построить префиксный код по декодируемому? Достаточно научиться по набору длин кодовых слов, для которого выполняется неравенство, построить префиксный код. Для этого давайте будем строить бинарное дерево. Изначально у нас есть только непомеченный корень и множество $A = \{l_1, \dots, \l_n\}$~--- длины кодовых слов. На каждом шаге мы смотрим наше множество $A$ и проверяем, нет ли непомеченной вершины на глубине $l_i$. Если есть, помечаем ее и удаляем $l_i$ из множества. После того, как таких вершин не осталось, раздваиваем все непомеченные вершины и повторяем алгоритм, пока множество не останется пустым. Нетрудно убедиться, что если выполнено неравенство, то для каждой длины найдется слово, так как если мы в вершине на высоте $h$ запишем $2^{-h}$, то сумма в листьях будет 1. А у нас кодовым словам соответствуют помеченные вершины, которые являются листьями (это, к слову, важно для беспрефиксности).
\end{proof}


\begin{thm}[Шеннон]
Пусть есть множество $ \Sigma $, и с вероятностью $ p_i$ получаем  $ i$-й символ.
   Тогда
   \[
	   \sum_{i}^{} p_i \lvert c_i \rvert  \ge H(p) \qquad  c_i \text{ --- однозначно декодируемы}
   .\] 
\end{thm}
\begin{proof}
	\begin{align*}
		H(p) - \sum_{i}^{} p_i \lvert c_i \rvert &= \sum_{}^{} p_i \log \frac{2^{-\lvert c_i \rvert }}{p_i} \le \tag{Неравенство Йенсена}\\
												 & \le  \log \sum_{}^{} p_i \cdot \frac{2^{-\lvert c_i \rvert }}{p_i} \le \tag{Неравенство Крафта} \\
												 & <= 0
	\end{align*}
\end{proof}


\begin{thm}[Шеннон]
	Существует такой код, что \footnote{Единичка обязательно возникает, так как мы приводим непрерывную энтропию к дискретной величине}
	\[
		\sum_{i}^{} p_i \cdot \lvert c_i \rvert \le H(p) + 1
	.\] 
\end{thm}
\begin{proof}
    Угадаем длины кодов, чтобы выполнялось неравенство Крафта-Макмиллана.
	% Добавить само неравенство Крафта-Макиллана
	Пусть $  \lvert c_i \rvert = \lceil \log \frac{1}{p_i} \rceil$,
	\[
		\sum_{}^{} 2^{- \lvert c_i \rvert } = \sum_{}^{} 2^{- \log \lceil \frac{1}{p_i} \rceil} \le \sum_{}^{} p_i \le 1
	.\] 
	Заметим, что для таких длин выполняется неравенство на энтропию. А мы знаем, что если выполнено неравенство Крафта-Макмиллана, то существует код с заданными длинами кодовых слов.
\end{proof}

\section{Примеры эффективных кодов}
\subsection{Код Шенона-Фано}
Отсортируем вероятности по убыванию $  p_1 \ge p_2 \ge  \ldots \ge p_n$. Затем уложим их в отрезок $ [0, 1]$.

Разделим отрезок пополам и скажем, что слева кодовые слова начинается с  $ 0$, справа с  $ 1$, а центральный  $ p_i$ будет начинаться с нуля, если это $ p_1$, с единицы, если $ p_n$, и, наконец, иначе выдираем любое значение.

Далее рекурсивно запускаемся на группе нулей и на группе единиц.

Когда остался один кусок, останавливаемся.

\begin{thm}
	\[
		\sum_{0}^{n} p_i \cdot \lvert c_i \rvert  \le H(p) + \O(1), \quad n \to \infty, ~\O(1) \approx 3 \text{ или } 5 
	.\] 
\end{thm}
\begin{proof*}
    Упражнение со зведочкой.
\end{proof*}


\subsection{Код Хаффмана}
Опять отсортируем $  p_1 \ge  p_2 \ge  \ldots \ge p_n$. Возьмем $ p_{n-1}$ и $ p_n$. Заменим их на один символ с вероятностью  $ p_n + p_{n-1}$, теперь по индукции строим код для  $ n-1$ символа.

Теперь если объединенному символу соответствовал код  $  \overline{c}$, то для $ p_{n-1}$ задаем код  $ \overline{c 0}$, а для $ p_n$ код  $ \overline{c 1}$
 
Проверим, что $ \sum_{i=1}^{n} p_i \lvert c_i \rvert \le H(p) + 1$, причем для любого другого кода $c_i'$: $ \sum_{i=1}^{n} p_i \lvert c_i \rvert  \le \sum_{i=1}^{n} p_i \lvert c_i' \rvert $

Достаточно доказать второе, а потом сравнить с кодом, который нам дает теорема Шеннона (1.5.3), и получить нужное неравенство.

Рассмотрим набор $  c_1', \ldots c_n'$.
Будем считать, что этот код префиксный, так как мы научились любой декодируемый код переделывать в префиксный с той же длиной кодовых слов. 


\begin{itemize}
    \item Шаг 1. Возьмем два минимальных $ c_{n-1}'$ и $ c_n'$. Заметим, что можно поменять их с символами максимальной длины  $ c_i'$ и $ c_j'$, при этом средняя длина кода не увеличится. Значит, перестроили так, что код не ухудшился и $c_n$, $c_{n-1}$ соответствуют символам с самой маленькой вероятностью и самой большой длиной кодовых слов.
    
	\item Шаг 2. Изучим коды $ c_{n-1}'$ и $ c_n'$. Пусть они не имеют вид $ \overline{v 0}$ и $ \overline{v 1}$. Пусть $ \lvert c_{n-1}' \rvert  \le  \lvert c_n' \rvert $. Посмотрим на $ c_{n-1}'$: не умаляя общности он будет заканчиваться на $ 0$ ($c_{n-1}'= \overline{s 0}$). Заменим $ c_n'$ на $ s 1$. Что при этом могло сломаться? Так как наш код префиксный, нам нужно проверить, что он префиксным и остался. Заметим, что так как $c_{n-1}' = \overline{s 0}$, префиксов $s$ нет среди кодовых слов. Единственная проблема тогда: среди кодовых слов может быть само $\overline{s 1}$. Тогда поступим следующим образом. Заменим $c_n'$ на слово длины $|s|+1$, а затем поменяем его местами с кодовым словом равным $\overline{s1}$. Почему мы можем найти новое слово подходящей длины? Воспользуемся неравенством Крафта-Макмиллана. Для целого $q$ верно $\sum 2^{-|c_i|} = \frac{q}{2^{|c_{n-1}|}} + \frac{1}{2^{|c_n|}} \le 1$. Но раз $q$ целое, $\frac{q+1}{2^{|c_n|}} \le 1$. То есть мы уменьшили среднюю длину кода, сохранив при этом неравенство Крафта-Макмиллана. Значит, перестроили так, что средняя длина кода не увеличилась и $c_{n-1} = \overline{v0}$, а $c_n = \overline{v1}$.
	
	\item Шаг 3. Заменим $c_{n-1}$ и $c_n$ на один символ с кодовым словом $v$. И применим предположение, что код Хаффмана оптимален для алфавита из $n-1$ символа. Тогда, раскрыв обратно, получим, что код Хаффмана оптимален и для $n$.
\end{itemize}

\section{Арифметическое кодирование}
Уложим вероятности аналогично на отрезок, при этом не обязательно в порядке убывания.

Назовем \selectedFont{стандартным} интервал $ \bigl[\overline{0. v 0}, \overline{0. v 1}\bigr)$. 
Найдем максимальный стандартный интервал в отрезке $[p_1 + \dots +p_{i-1}, p_1 + \dots + p_i]$.
Тогда $ v$ будет кодом  $i$-ого символа. 
Заметим, что такой код будет префиксным, так как отрезки не пересекаются.

\begin{proof*}
	Если рассмотреть отрезок $ [a, b]$, есть стандартный интервал длиной  $ \frac{b-a}{8}$. Упражнение
\end{proof*}

