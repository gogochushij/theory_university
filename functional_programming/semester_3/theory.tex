\documentclass[11pt,a4paper]{article}
\input{preamble.tex}

\title{Билеты к экзамену по функциональному программированию}
\author{Тамарин Вячеслав}


\makeindex


\begin{document}
\maketitle


\section{Сравнение функционального и императивного подходов к программированию}
\subsection{Императивное программирование}
Вычисление (программа) описывается в терминах \mf{инструкций}, изменяющих \mf{состояние} вычислителя.
\begin{itemize}
	\item Инструкции выполняются последовательно;
	\item Состояние изменяется инструкциями \mf{присваивания} значений изменяемым переменным;
	\item Если механизм условного исполнения (if, switch);
	\item Инструкции можно повторять с помощью циклов (while, for);
	\item Типы данных описываются с оглядкой на их физическое представление в памяти.
\end{itemize}
Такой стиль иногда называют стилем фон Неймана.
\begin{ccode}
long factorial(int n) {
	long res = 1;
	for (int i = 0; i < n; i++) 
		res *= i;
	return res;
}
\end{ccode}
Выполнение программы --- переход вычислителя из начального состояния в конечное с помощью последовательных инструкций.

Часть конечного состояния может интерпретироваться как результат вычислений.

\subsection{Функциональное программирование}
	Функциональная программа --- \mf{выражение}, ее выполнение --- вычисление (\mf{редукция}) этого выражения.
\begin{hscode}
factorial n = if n == 0 then 1 else n * factorial(n-1)
\end{hscode}
Выполнение программы --- редукция выражения с помощью \mf{подстановки} определений функций в места их ,,вызова'' с заменой формальных параметров на фактические.
\begin{minted}[fontsize=\footnotesize,numbersep=3pt,framesep=1mm,linenos,bgcolor=lbg]{hs}
factorial 3
-> if 3 == 0 then 1 else 3 * factorial (3 - 1)
-> ...
-> 3 * factorial (3 - 1)
-> 3 * if (3 - 1) == 0 then 1 else (3 - 1) * factorial ((3 - 1) - 1)
-> ...
-> 3 * 2 * 1 * 1 
-> 6
\end{minted}

\begin{minipage}{0.47\linewidth}
\begin{itemize}
	\item Нет состояний --- нет изменяемых переменных;
	\item Нет переменных --- нет присваивания;
	\item Нет циклов, так как нет различий между итерациями -- состояниями
	\item Последовательность не важна, поскольку выражения независимы.
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}{0.47\linewidth}
	\begin{itemize}
		\item Рекурсия --- замена циклов;
		\item Функции высших порядков;
		\item Сопоставление с образцом;
		\item Все функции --- чистые.
    \end{itemize}
\end{minipage}
\subsection{Сильные стороны ФП}
\begin{itemize}
	\item Регулярный синтаксис, удобство анализа кода;
	\item Мощная типизация, при этом можно практически не использовать типы в коде за счет эффективным алгоритмам вывода типов;
	\item Возможность генерации программ по набору свойств;
	\item Эффективная доказуемость свойств программ алгебраическими методами;
	\item Высокоурвневые оптимизации на базе эквивалентных преобразований.
\end{itemize}

\section{Основы $ \lambda$-исчисления. $ \lambda$-термы, свободные и связанные переменные.}
$ \lambda$-исчисление --- формальная система, лежащая в основе ФП. Разработано Алонзо Чёрчем в 1930-х для формализации и анализа понятия вычислимости.

\noindent
В \LMCисчислении тремя основными понятиями являются:
\begin{itemize}
	\item применение (аппликация, application) --- задает синтаксис применения функции к ее фактическим аргументам.
		Применение функции $ F$ к аргументу $ X$ записывается как $ FX$;
	\item лямбда-абстрацкия (abstraction) --- описывает синтаксис определения функции на основе параметризованного выражения, представляющего ее тело. Абстракция по x: $ \lam{x}{F}$;
	\item редукция (reduction) --- определяет отношение вычисления, основывающегося на подстановке фактических параметров вместо формальных.
\end{itemize}
\begin{defn}[$ \lambda$-термы]\index{$ \lambda $-терм}
	Множество \mf{$ \lambda $-термов} $ \Lambda$ индуктивно строится из переменных  $ V = \{x, y, z, \ldots \}$ с помощью применения и абстракции:
\[
\begin{aligned}
	x \in V && \Longrightarrow &&& x \in \Lambda \\
	M, N \in \Lambda && \Longrightarrow &&& (MN) \in \Lambda \\
	M \in \Lambda, ~  x \in  V && \Longrightarrow &&& (\lam{x}{M}) \in \Lambda
\end{aligned}
\]
В абстрактном синтаксисе 
\[
	\Lambda \Coloneqq V \mid (\Lambda \Lambda) \mid (\lam{V}{\Lambda})
.\] 
\end{defn}
Терм может быть \textit{переменной} (например, $ x \in \Lambda$), \textit{аппликацией} (например, $ (xy) \in \Lambda$) или \textit{лямбда-абстракцией} (например, $ \lam{x}{((x(yx)))} \in  \Lambda$).

\begin{defn}[Подтермы]\index{подтерм}
	Множество \mf{подтермов} терма $ Q$ определяется индуктивно:
	\[
	\begin{aligned}
		&\subterms(x) && = && \{x\} \\
		&\subterms(MN) && = && \{MN\} \cup \subterms(M) \cup \subterms(N) \\
		&\subterms(\lam{x}{M}) && = && \{\lam {x}{M}\} \cup \subterms(M)
	\end{aligned}
	\]
\end{defn}


\subsection{Соглашения}
Общеприняты следующие соглашения для термов:
\begin{itemize}
	\item Внешние скобки опускаются
	\item Применение  ассоциативно \textit{влево}:
		\[
			FXYZ \equiv (((FX)Y)Z)
		.\] 
	\item Абстракция ассоциативна \textit{вправо}:
		\[
			\lam{x y z}{M} \equiv (\lam{x}{(\lam{y}{(\lam{z}{M})})})
		.\] 
	\item Тело абстракции простирается вправо насколько это возможно:
		\[
			\lam{x}{MNK} \equiv \lam{x}{(MNK)}
		.\] 
\end{itemize}

\begin{defn}[Свободные переменные]\index{свободные переменные}
	Множество \mf{свободных переменных} в терме $ Q$ ($ FV(Q)$) определяется следующим образом:
	\[
	\begin{aligned}
		& FV(x) && = && \{x\} \\
		& FV(MN) && = && FV(M) \cup FV(N) \\
		& FV(\lam{x}{M} && = && FV(M) \setminus \{x\}
	\end{aligned}
	\]
\end{defn}

\begin{defn}[Связвнные переменные]\index{связанные переменные}
	Множество \mf{связанных переменных} в терме $ Q$ ($ BV(Q)$) определяется следующим образом:
	\[
	\begin{aligned}
		& BV(x) && = && \varnothing \\
		& BV(MN) && = && BV(M) \cup BV(N) \\
		& BV(\lam{x}{M} && = && BV(M) \cup  \{x\}
	\end{aligned}
	\]
\end{defn}

\subsection{Комбинаторы}
\begin{defn}[Комбинатор]\index{комбинатор}
$ M$ --- \mf{замкнутый $ \lambda$-терм (комбинатор)}, если $ FV(M) = \varnothing$. 

\noindent
Множество замкнутых $ \lambda$-термов обозначается $ \Lambda^{0}$.
\end{defn}
\begin{enumerate}[noitemsep]
	\item $ I = \lam{x}{x}$
	\item $ \omega = \lam{x} {x x}$
	\item $ \Omega = \omega \omega = \left( \lam{x}{x x} \right) \left( \lam{x}{x x} \right) $
	\item $ K = \lam{x y} {x}$
	\item  $ K_{*} = \lam{x y}{y}$
	\item $ C = \lam{f x y}{f y x}$ 
	\item $ B = \lam{f g x}{f (g x)}$
	\item $ S = \lam{f g x}{f x (g x)}$
\end{enumerate} 


\section{Подстановка $ \lambda$-терма. Лемма подстановки.}
\begin{defn}[Подстановка]\index{подстановка}
	\mf{Подстановка} терма $ N$ вместо \textit{свободных} вхождений переменной $ x$ в терм $ M$ ($ \subst{x}{N}{M}$) задается следующими правилами:
	\[
	\begin{aligned}
		& \subst{x}{N}{x} && = && N \\
		& \subst{x}{N}{y} && = && y \\
		& \subst{x}{N}{PQ} && = && \left( \subst{x}{N}{P} \right) \left( \subst{x}{N}{Q} \right)   \\
		& \subst{x}{N}{\lam{x}{P}} && = && \lam{x}{P} \\
		& \subst{x}{N}{\lam{y}{P}} && = && \lam{y}{\subst{x}{N}{P}}, && \text{ если } y \notin FV(N)\\
		& \subst{x}{N}{\lam{y}{P}} && = && \lam{x}{\subst{y}{z}{P}}\left( \subst{y}{z}{P} \right) , && \text{ если } y \in FV(N)
	\end{aligned}
	\]
	Предполагается, что $ x$ и $ y$ различны, а $ z$ --- ,,свежая'' переменная, то есть $ z \notin FV(P) \cup FV(N)$.
\end{defn}
\begin{ex}[Пример подстановки]
    \[
	\subst{x}{uv}{\left( \left( \lam{\color{red}x}{(\lam{\color{green}x}{{\color{green}x}z}){\color{red}x}} \right) x  \right) } = 
	\left( \lam{\color{red}x}{(\lam{\color{green}x}{{\color{green}x}z})\color{red}x} \right) (uv)
    .\] 
\end{ex}
\begin{lm}[подстановки]
	Пусть $ M, N, L \in \Lambda$, $ x \not\equiv y $ и $ x \notin FV(L)$. Тогда 
	\[
		\subst{y}{L}{\subst{x}{N}{M}} = \subst{x}{\subst{y}{L}{N}}{\subst{y}{L}{M}}
	.\] 
\end{lm}

\section{$ \alpha $- и $ \beta $-конверсии. $ \eta$-конверсия и экстенсиональная эквивалентность.}
\subsection{$ \alpha $-эквивалентность}\index{$ \alpha $-эквивалентность}
Позволяет менять переменную на ,,свежую''.
Главная аксиома $ \alpha $-преобразования:
\[
	\tag{правило $\alpha$}
	\lam{x}{M} \eqa \lam{y}{\subst{x}{y}{M}}, \text{ если } y \notin FV(M)
.\] 
Аналогично $ \beta $-эквивалентности можно определить совместимость.
\subsection{$ \beta $-эквивалентность}
\mf{Основная схема аксиом}: для любых $ M, N \in \Lambda$:
\[
	(\lam{x}{M})N \eqb \subst{x}{N}{M} \tag{правило $ \beta $ }
.\] 
Чтобы сделать $ \eqb$ отношением эквивалентности добавим логические аксиомы и правила:
\[
\begin{aligned}
	& && && M \eqb M \\
	& M \eqb N && \Rightarrow && M \eqb N \\
	& M \eqb N, ~ N \eqb L && \Rightarrow && M \eqb L
\end{aligned}
\]
Также определим правила совместимости:
\begin{align*}
	& M \eqb N  \Rightarrow  ZM \eqb ZN \\
	& M \eqb N  \Rightarrow  MZ \eqb NZ \\
	& M \eqb N  \Rightarrow  \lam{x}{M} \eqb \lam{x}{N} \tag{правило $ \xi$}
\end{align*}

Если $ M \eqb N$ доказуемо в $ \lambda$-исчислении, пишут 
 \[
\lambda \vdash M \eqb N
.\] 
\subsection{$ \eta$-эквивалентность}\index{$ \eta $-эквивалентность}
Схема аксиом $ \eta$-преобразования:
\[
	\tag{правило $ \eta$ }
	\lam{x}{Mx} \eqn M, \text{ если } x \notin FV(M)
.\] 
Аналогично можем определить правила и совместимость, как для $ \beta $.

Смысл этой эквивалентности в том, что поведение данных двух термов одинаково; для произвольного $ N$ будет верно
\[
	(\lam{x}{M})N \eqb MN
.\] 
\paragraph{Принцип экстенсиональности}
Две функции считаются \mf{экстенсионально эквивалентными}, если они дают одинаковый результат при одинаковом входе:
\[
\forall N\colon FN \eqb GN
.\] 
Выберем $ u \notin FV(F) \cup FV(G)$, теперь
\[
	Fy \eqb Gy \Longrightarrow \lam{y}{Fy} \eqb \lam{y}{Gy} \Longrightarrow F =_{\beta \eta} G
\]


\section{Кодирование булевых значений, кортежей в чистом беcтиповом $ \lambda $-исчислении.}
\subsection{Булевы значения}
\[
\begin{aligned}
	&\tru &&\equiv&& \lam{t f}{t} \\
	&\fls &&\equiv&& \lam{t f}{f}
\end{aligned}
\]
\subsection{Булевы операции}
\[
\begin{aligned}
	&\fpif &&\equiv&& \lam{b x y}{b x y} \\
	&\fpnot &&\equiv && \lam{b}{b \fls \tru} \\
	&\fpand &&\equiv && \lam{x y} {x y \fls} \\
	&\fpor &&\equiv && \lam{x y}{x \tru y}
\end{aligned}
\]
\subsection{Кортежи}
Пара и стандартные операции:
\[
\begin{aligned}
	&\pair &&\equiv&& \lam{x y f}{f x y} \\
	&\fst &&\equiv && \lam{p}{p \tru} \\
	&\snd &&\equiv && \lam{p}{p \fls}
\end{aligned}
\]
\section{Кодирование чисел Чёрча в чистом бестиповом $ \lambda $-исчислении.}
\[
\begin{aligned}
	& 0 &&\equiv && \lam{s z}{z} \\
	& 1 && \equiv && \lam{s z}{s z} \\
	& 2 && \equiv && \lam{s z}{s(s z)} \\
	& 3 &&\equiv && \lam{s z}{s(s(s z))} \\
	& 4 &&\equiv && \lam{s z}{s(s(s(s z)))} \\
	&&& \dots && 
\end{aligned}
\]
Определим $ F^{n}(X)$, где $ n \in \N$, $ F, Z \in \Lambda$:
\[
\begin{aligned}
	&F^{0}(X) &&\equiv && X \\
	&F^{n+1}(X) && \equiv && F(F^{n}(X))
\end{aligned}
\]
Теперь число Чёрча принимает следующий вид
\[
	n \equiv \lam{s z}{s^{n}(z)}
.\] 
Функция проверки на ноль:
\[
	\iszero \equiv \lam{n}{n (\lam{x}{\fls}) \tru}
.\] 
Переход к следующему числу:
\[
	\fpsucc \equiv \lam{n s z}{s (n s z)}
.\] 
Сложение:
\[
	\plus \equiv \lam{m n s z}{m s (n s z)}
.\] 
Умножение:
\[
\begin{aligned}
	&\fpmult &&\equiv&& \lam{m n}{m (\plus n) 0}\\
	&\fpmult &&\equiv&& \lam{m n s z}{m (n s) x}
\end{aligned}
\] 

\section{Теорема о неподвижной точке. Y-комбинатор.}
\subsection{Решение уравнений на термы}
Например, хотим найти $ F$ такой, что $ \forall M, N, L\colon \lambda \vdash FMNL = ML(NL)$.
\[
\begin{aligned}
	& FMNL && = && ML(NL) \\
	& FMNL && = && (\lam{l}{Ml(Nl)})L \\
	& FMN && = && \lam{l}{Ml(Nl)} \\
	& FM && = && \lam{n}{\lam{l}{Ml(nl)}} \\
	& F && = && \lam{mnl}{ml(nl)}
\end{aligned}
\]
А что делать, если уравнение рекурсивное? Например, $ FM = MF$.
\subsection{Теоремы о неподвижной точке}
\begin{thm}
    Для любого $ \lambda$-терма $ F$ существует неподвижная точка:
	\[
	\forall F \in \Lambda ~ \exists X \in \Lambda\colon \lambda \vdash FX = X
	.\] 
\end{thm}
\begin{proof}
	Пусть $ W \equiv \lam{x}{F(x x)}$ и $ X \equiv WW$. Тогда
	\[
		X \equiv WW \equiv (\lam{x}{F(x x)})W = F(WW) \equiv F X
	.\] 
\end{proof}
\begin{thm}\index{комбинатор неподвижной точки}
	Существует комбинатор неподвижной точки $\Y$ такой, что
	 \[
		 \forall F\colon F(\Y F) = \Y F
	.\] 
\end{thm}
\begin{proof}
	Пусть $ \Y = \lam{f}{(\lam{x}{f(xx)})(\lam{x}{f(x x)})}$.
	Тогда
	\[
		\Y F \equiv (\lam{x}{F(x x)})(\lam{x}{F(x x)}) = F(\underbrace{(\lam{x}{F(x x)})(\lam{x}{F(x x)})}_{\Y F} \equiv F(\Y F)
	.\] 
\end{proof}

\subsection{Рекурсия}
$\Y$-комбинатор позволяет ввести рекурсию в  $ \lambda$-исчисление.
Например, можно задать факториал рекурсивно:
\[
	\fac = \lam{n}{\fpif (\iszero n) 1 (\fpmult n (\fac (\pred n)))}
.\] 
Можно переписать:
\[
	\fac = \underbrace{(\lam{f n}{\fpif (\iszero n) 1 (\fpmult n (f (\pred n))))}}_{\fac'} \fac
.\] 
Тогда $ \fac$ --- неподвижная точка для $ \fac'$, поэтому  $ \fac = \Y \fac'$.


\section{Редексы. Одношаговая и многошаговая редукция. Нормальная форма. Редукционные графы.}
Если мы хотим доказать равенство, то эффективным способом будет сокращение всех редексов:
\[
\begin{aligned}
	& KI &&\equiv && \left( \lam{xy}{x} \right) \left( \lam{z}{z} \right) = \lam{yz}{z} \\
	& I I K_{*} &&\equiv && (\lam{x}{x})I K_{*} = IK_{*} = (\lam{x}{x})(\lam{y z}{z}) = \lam{yz}{z}
\end{aligned}
\]
Но как доказать неравенство?
\subsection{Редукция}
\begin{defn}[Совместимое отношение]\index{совместимое отношение}
	Бинарное отношение $ \mathcal{R}$ над $ \Lambda$ называют \mf{совместимым} (с операциями $ \lambda$-исчисления), если для всех $ M, N, Z \in \Lambda$ :
	\[
	\begin{aligned}
		M ~\mathcal{R} ~N && \Rightarrow  && (ZM) ~ \mathcal{R} ~ (ZN), \\
						  &&&& (MZ) ~ \mathcal{R} ~(NZ), \\
						  &&&& (\lam{x}{M}) ~\mathcal{R}~(\lam{x}{N})
	\end{aligned}
	\]
\end{defn}
\begin{defn}
     Совместимое отношение эквивалентности называют \mf{отношением конгруэнтоности} над $ \Lambda$.

	 \noindent
	 Совместимое, рефлексивное и транзитивное отношение называют \mf{отношением редукции} над $ \Lambda$.
\end{defn}

\begin{defn}
	Бинарное отношение \mf{$ \beta $-редукции за один шаг} $ \to_{\beta}$ над $ \Lambda$:
	\[
	\begin{aligned}
		&(\lam{x}{M})N &&\lba&& \subst{x}{N}{M} \\ 
		&M \lba N && \Longrightarrow && ZM \lba ZN \\
		&M \lba N && \Longrightarrow && MZ \lba NZ \\
		&M \lba N && \Longrightarrow && \lam{x}{M} \lba \lam{x}{N} \\
	\end{aligned}
	\]
	Это правило и совместимость.
\end{defn}
\begin{defn}[$ \beta$-редукция]\index{$ \beta $-редукция}    
	Бинарное отношение \mf{$ \beta $-редукции} $ \llba$ над $ \Lambda$ определяется индуктивно:
\begin{align*}
	&M \llba M   \tag{refl} \\
	M \lba N ~\Rightarrow~ &  M \llba N  \tag{ini} \\
	M \llba N, ~ N \llba L ~\Rightarrow ~&  M \llba L  \tag{trans}
\end{align*}
\end{defn}
Это отношение --- транзитивное, рефлексивное замыкание $ \lba$, поэтому является отношением редукции. 

\begin{defn}[Конвертируемость]\index{конвертируемость}
	Бинарное отношение \mf{конвертируемости} $ \eqb$ над $ \Lambda$ определяется индуктивно:
	\begin{align*}
		M \llba N & \Rightarrow  M \eqb N \tag{ini}\\
		M \eqb N & \Rightarrow  N \eqb M \tag{sym}\\
		M \eqb N, ~ N \eqb L & \Rightarrow  M \eqb L \tag{trans}
	\end{align*}
\end{defn}
Это отношение является отношением конгруэнтности.

\begin{st}
    $ M \eqb N \Longleftrightarrow \lambda \vdash M = N$.
\end{st}
\begin{proof}
	Индукция по количеству шагов, расписываем по определению.
\end{proof}
Два терма $ M, N$ связаны отношением $ \eqb$, если есть связывающая цепочка стрелок $ \lba$:
\begin{figure}[ht]
    \centering
    \incfig{beta-equiv}
    \label{fig:beta-equiv}
\end{figure}

\mf{Редукционный граф} для терма $ M \in \Lambda$ (нотация $ G_{\beta}(M)$) --- ориентированный мультиграф с вершинами в $ \{N \mid M \llba N\}$, ребро проводится между $ N$ и $ L$, если  $ N \lba L$.

Отношение $ \beta $-эквивалентности не является разрешимым в общем случае (то есть для пары термов не существует универсального алгоритма, проверяющего эквивалентность).

\subsection{Нормальная форма}\index{нормальная форма}
Это то, что лежит в самом низу на картинке.
\begin{defn}
$ \lambda$-терм $ M$ \textit{находится} в \mf{$ \beta $-нормальной форме} (\bNF), если в нем нет подтермов, являющихся  $ \beta $-редексами.

\noindent
$ \lambda$-терм $ M$ \textit{имеет} $\beta $-нормальную форму, если для некоторого $ N$ выполняется $ M \eqb N$ и $ N$ находится в \bNF.
\end{defn}
\begin{ex}
	~\begin{itemize}
		\item $ \lam{xy}{x(\lam{z}{zx})y}$ находится в \bNF
		\item $ (\lam{x}{xx})y$ не находится в \bNF, но имеет в качестве \bNF терм $ yy$
		\item $ \Omega $ не имеет нормальной формы
    \end{itemize}
\end{ex}


\section{Теорема Чёрча-Россера и ее следствия.}
\begin{thm}[Черч, Россер]\index{теорема Чёрча-Россера}
	Если $ M \llba N$, $ M \llba K$, то существует такой $ L$, что
	$N \llba L$ и $ K \llba L$.
\end{thm}
Иначе говоря, $ \beta $-редукция обладает \textit{свойством ромба} или \textit{конфлюентностью}:

\begin{center}
\begin{tikzcd}%
	&M\arrow[rd, two heads]\arrow[ld, two heads]&\\
	N\arrow[rd, dotted, two heads]&&K\arrow[ld, dotted, two heads]\\
	&L&
\end{tikzcd}
\end{center}
\begin{cor}[о существовании общего редукта]
    Если $ M \eqb N$, то существует $ L$ такой, что $ M \llba L$ и $ N \llba L$.
\end{cor}
\begin{proof}
   Индукция по генерации $ \eqb$. 
   Разберем три случая вывода $ M \eqb N$ :
   \begin{description}
	   \item[$ M \llba N$.] Возьмем $ L = N$. 
	   \item[$ N \eqb M$.] По предположению индукции есть общий  $ \beta$-редукт $ L_1$ для $ N$ и $ M$. Можем взять $ L = L_1$.
	   \item[$ M \eqb N', ~ N' \eqb N$.]  Тогда
\begin{center}
\begin{tikzcd}%
	M\arrow[rd, two heads]&(\text{по ПИ})&N'\arrow[ld, two heads]\arrow[rd, two heads]&(\text{по ПИ})&N\arrow[ld, two heads]\\
						  &L_1\arrow[rd, dotted, two heads]&(CR)&L_2\arrow[ld, dotted, two heads]&\\
						  &&L&&
\end{tikzcd}
\end{center}
   \end{description}
\end{proof}
\begin{cor}[о редуцируемости к \bNF]
    Если $ M$ имеет $ N$ в качестве \bNF, то  $ M \llba N$.
\end{cor}
\begin{cor}[о единственности \bNF]
    $ \lambda$-терм имеет не более одной \bNF.
\end{cor}


\section{Стратегии редукции. Теорема о нормализации. Механизмы вызова в функциональных языках.}
Рассмотрим три варианта терма:
\begin{itemize}
	\item Переменная $ \nu $, редукция завершена, ничего интересного
	\item Абстракция $ \lam{x}{M}$, просто редуцируем $ M$
	\item Аппликация  $ MN$. Разбираем аппликацию влево  (в $ M$) до не-аппликации. Пока получаем аппликацию, разделяем дальше.
		Два варианта остановки:
		\begin{itemize}
			\item Переменная.  Тогда мы получили такой вид
				\[
					(\ldots (( \nu N_1)N_2) \ldots N_k)
				.\] 
				Теперь нам нужно просто проредуцировать каждый $ N_i$, общая структура от этого не изменится. 
			\item Абстракция. Получили:
				\[
					(\ldots (((\lam{x}{M'})N_1)N_2)\ldots N_k)
				.\] 
				Будем работать дальше.
				Здесь есть две стратегии:
				\begin{itemize}
					\item \textbf{Нормальная стратегия}: сразу сокращаем редекс $ (\lam{x}{M})N_1$.
					\item \textbf{Аппликативная стратегия}: сначала редуцируем отдельно все $ N_i$ слева направо до нормальной формы $ N_j'$, а уже потом сокращаем редекс $ (\lam{x}{M})N_1'$.

						Также можно редуцировать только $ N_1$ и сразу сократить.
				\end{itemize}
		\end{itemize}
\end{itemize}
Разбор терма можно представить в виде дерева, где узлы $ @$ задают аппликацию, а узлы $ \lambda$ --- абстракцию.
\begin{thm}
    Лямбда-терм может иметь одну из двух форм:
	\begin{align*}
		&\lam{\vec{x}}{y\vec{N}} &&\equiv&& \lam{x_1 x_2 \ldots x_n }{y N_1, N_2, \ldots N_k}, \quad n,k \ge 0 \tag{HNF} \\
		&\lam{\vec{x}}{(\lam{z}{M})\vec{N}} &&\equiv&& \lam{x_1 x_2 \ldots x_n }{(\lam{z}{M}) N_1, N_2, \ldots N_k}, \quad n \ge 0, k >0 
	\end{align*}
\end{thm}
\begin{defn}\index{головная нормальная форма}
	\mf{Головная нормальная форма} --- форма следующего вида:
	\[
		\lam{\vec{x}}{y\vec{N}} \equiv \lam{x_1 x_2 \ldots x_n }{y N_1, N_2, \ldots N_k}, \quad n,k \ge 0 \tag{HNF}
	.\] 

	\noindent
	\mf{Слабая головная нормальная форма} ($ WHNF$) --- это  $ HFN$ или лямбда-абстракция (то есть не редекс на верхнем уровне). 

	\noindent
	Переменная $ y$ называется \mf{головной переменной}.
	Редекс $ (\lam{z}{M})N_1$ называется \mf{головным редексом}.
\end{defn}
Переменная $ y $ может совпадать с одним из $ x_i$.

В Haskell вычисления как раз форсируются до слабой нормальной формы.
\begin{thm}[о нормализации]
    Если терм $ M$ имеет нормальную форму, то последовательное сокращение самого левого внешнего редекса приводит к этой нормальной форме.
\end{thm}
То есть, если $HNF$ есть, то нормальная стратегия гарантировано приводит к ней.

\subsection{Механизмы вызова в ФЯ}
Аппликативная стратегия более эффективная, хоть и не всегда приводит к $ HNF$, поэтому применяется во многих языках программирования.

Пусть $ N$ --- очень большой терм, который вычисляется сутки.
Если мы запустим нормальную стратегию на 
\[
	(\lam{x}{Fx(Gx)x})N 
,\] 
получим $ FN(GN)N$ и  $ N$ придется в дальнейших редукциях сократить трижды.
Но для такого нормальная стратегия не вычислит $ N$ ни разу:
\[
	(\lam{xy}{y})N \lba \lam{y}{y}
.\] 

Аппликативная стратегия будет вычислять $ N$ только один раз в каждом из примеров.

В ,,ленивых'' языках программирования (Haskell, Clean) используется похожая на нормальную стратегия, а для решения проблем с эффективностью используют механизм \textit{разделения}: вместо непосредственной подстановки терма подставляют указатель на терм, который хранится в памяти как \textit{отложенное вычисление}.

\textbf{Механизм вызова} в функциональных языках:
\begin{itemize}
	\item \textit{вызов по значению} --- аппликативый порядок редукций до $ WHNF$ 
	\item \textit{вызов по имени} --- нормальный порядок редукций до $ WHNT$
	\item \textit{вызов по необходимости} --- ,,вызов по имени'' с разделением.
\end{itemize}


\section{Функция предшествования для чисел Черча. Комбинатор примитивной рекурсии.}
\subsection{Функция предшествования}
Введем вспомогательные функции:
\[
\begin{aligned}
	& \zp && \equiv && \pair 0 0 \\
	& \fpsp && \equiv && \lam{p}{\pair (\snd p) (\fpsucc (\snd p)))}
\end{aligned}
\]
Вторая функция позволяет, приняв пару $ (\_, j)$, вернуть пару  $ (j, j+1)$:
 \[
	 \fpsp(\pair i~ j) = \pair j~ (j+1)
.\] 
Если взять композицию $ m > 0$ раз от $\zp$:
\[
\begin{aligned}
	\fpsp^{0} (\zp) & = \pair 0 0 \\
	\fpsp^{m}(\zp) &= \pair (m-1)~ m
\end{aligned}
\]
Тогда можно определить функцию предшествования:
\[
	\fppred = \lam{m}{\fst (m \, \fpsp \zp)}
.\] 
Тогда 
\[
	\fpminus = \lam{m\,n}{n\, \fppred m}
.\] 

\subsection{Комбинатор примитивной рекурсии}
Обобщим конструкцию. Второй элемент пары оставим счетчиком, а в первом храним результат.
\[
\begin{aligned}
	\fpxz & \equiv \lam{x}{\pair x \, 0} \\
	\fpfs & \equiv \lam {f \, p}{\pair (f (\fst p) (\snd p)) (\fpsucc (\snd p))} \\
	\fprec & \equiv \lam{m\,f\,x}{\fst (m (\fpfs f) (\fpxz x))}
\end{aligned}
\]
Теперь можно выразить $ \fppred$:
 \[
	 \fppred' = \lam{n}{\fprec n\, (K_{*})\, 0}
.\] 
И факториал:
\[
	\fac = \lam{n}{\fprec n \, \left( \lam{x\,y}{\fpmult x (\fpsucc y)} \right) \, 1}
.\] 

\subsection{Списки}
\[
\begin{aligned}
	\nil & \equiv \lam{c\, n}{n} \\
	\cons &\equiv \lam{e\,l\,c\,n}{c \, e (l\, c\, n)}
\end{aligned}
\]
Теперь
\[
\begin{aligned}
	&[\,] = \nil \\
	&[5,3,2] = \cons 5 (\cons 3 (\cons 2 \nil)) = \lam{c\,n}{c\,5(c\,3(c\,2\,n))}
\end{aligned}
\]
\[
	\isempty \equiv \lam{l}{l \, (\lam{h\,t}{\fls}) \tru}
.\] 


\section{Просто типизированное $ \lambda$-исчисление в стиле Карри. Предтермы. Утверждения о типизации. Контексты. Правила типизации.}
\subsection{Понятие типа}
\mf{Система типов} --- гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений (Бенджамин Пирс). 

В $ \lambda $-исчислении:
\begin{itemize}
	\item выражения --- $ \lambda$-термы
	\item вычисления --- их редукция
	\item значения ---  $ (WH)NF$
\end{itemize}
Типы рассматриваются как \textit{синтаксические} конструкции, приписываемые термам про определенным правилам:
\[
M \colon \sigma 
.\] 
\subsection{Для чего нужны типы?}
\begin{itemize}
	\item Частичная спецификация:
		\[
			f\colon \N \to  \N, \qquad g\colon ( \forall n \colon \N. ~ \exists m\colon \N. ~ m \le  n)
		.\] 
	\item Проверка типов помогает отлавливать простые ошибки
\end{itemize}
\subsection{Тип функции}
Стрелка --- базовый способ конструирования типа, задающая функциональный тип. Например, для функции $ I \equiv \lam{x}{x}$ может быть приписан тип:
\[
I \colon \alpha \to \alpha 
.\] 
В общем случае типом функции из $ \alpha $ в $ \beta $ будет $ \alpha \to  \beta $.

Если $ y\colon \alpha $ является аргументом функции $ f\colon \alpha  \to \beta $, то возвращаемое значение $ f \, y$ имеет тип $ \beta $.

Гипотеза о типе переменных записывают в контексте:
\[
	y\colon a \vdash (I y) \colon \alpha 
.\] 
\subsection{Системы в стиле Карри}
Оставляем термы такими же, что и в бестиповой теории. Каждый терм может обладать множеством различных типов (пустое, одно-, многоэлементное, бесконечное).
\subsection{Просто типизированное $ \lambda $-исчисление}
\begin{defn}
	\mf{Множество типов} $ \mathbb{T}$ системы $ \lambda_{\to}$ определяется индуктивно:
	\begin{align*}
		& \alpha , \beta \ldots \in \mathbb{T} \tag{переменные типа} \\
		& \sigma , \tau \in \mathbb{T} \Rightarrow (\sigma \to \tau) \in \mathbb{T} \tag{типы пространства функций}
	\end{align*}
	В абстрактном синтаксисе: $ \mathbb{T} \Coloneqq \mathbb{V \mid (T \to T)}$, где $ \mathbb{V} = \{ \alpha , \beta \ldots \}$.
\end{defn}
Стрелка \textit{правоассоциативна}: если $ \sigma_1 ,\ldots \sigma _n \in \mathbb{T}$, то
\[
	\sigma _1 \to \sigma _2 \to  \ldots \to \sigma _n \equiv (\sigma_1 \to ( \sigma _2 \to  \ldots \to (\sigma_{n-1} \to  \sigma _n)\ldots ))
.\] 
Всякий тип может быть записан в виде:
\[
\sigma _1 \to  \ldots \to \sigma _n \to  \alpha 
.\] 

\begin{defn}[Предтермы]
	Множество \mf{предтермов} $ \Lambda$ строится из переменных из $ V = \{x, y, z, \ldots \}$ с помощью аппликации и абстракции:
	\[
	\begin{aligned}
		x \in V && \Longrightarrow && x \in \Lambda \\
		M, N \in \Lambda && \Longrightarrow && (MN) \in \Lambda \\
		M \in \Lambda, x \in V && \Longrightarrow && (\lam{x}{M}) \in \Lambda
	\end{aligned}
	\]
	В абстрактном стиле: $ \Lambda \Coloneqq V \mid (\Lambda \Lambda) \mid (\lam{V}{\Lambda})$.
\end{defn}
Предтермы системы в стиле Карри --- термы бестипового $ \lambda $-исчисления.

\begin{defn}
	\mf{Утверждение о типизации $ \lambda _{\to}$ по Карри} имеет вид $ M \colon  \tau $, где субъект $ M \in \Lambda$ и предикат $ \tau \in \mathbb{T}$.
\end{defn}
\begin{ex}
	Примеры утверждений типизации
    \[
    \begin{aligned}
		&\lam{x}{x} \colon \alpha \to \alpha \\
		& \lam{x}{x}\colon ( \alpha  \to  \beta ) \to \alpha \to  \beta \\
		& \lam{x \, y}{x} \colon  \alpha  \to \beta  \to \alpha 
    \end{aligned}
    \]
\end{ex}
\begin{defn}[Объвление]
	\mf{Объявление} --- утверждение типизации с термовой переменной в кресле субъекта.
\end{defn}
\begin{ex}
    Примеры объявлений
	\[
	\begin{aligned}
		&x \colon \alpha \\
		&y \colon \beta \\
		&f \colon ( \alpha  \to  \beta ) \to \gamma 
	\end{aligned}
	\]
\end{ex}
\begin{defn}[Контекст]\index{Контекст}
	\mf{Контекст} --- множество объявлений с \textit{различными} переменными в качестве субъекта:
	\[
	\Gamma = \{x_1\colon \sigma _1, ~ x_2\colon \sigma _2, \ldots , ~ x_{n} \colon \sigma_{n}\}
	.\] 
	Контекст иногда называют \textit{базисом} или \textit{окружением}.
\end{defn}
Фигурные скобки иногда опускают:
\[
	\Gamma = x\colon \alpha , ~ f\colon \alpha \to \beta , ~ g\colon ( \alpha \to  \beta ) \to \gamma  \equiv x^{ \alpha }, ~ f^{ \alpha \to \beta }, ~ g ^{( \alpha \to  \beta ) \to  \gamma }
.\] 
Контексты можно расширять, добавляя объявление новой переменной.

Также контексты можно рассматривать как частичные функции из $ V$ в множество типов $ \mathbb{T}$.
\subsection{Правила типизации}
\begin{defn}
	Утверждение $ M \colon \tau $ называется \mf{выводимым} в контексте  $ \Gamma $, обозначается 
	\[
	\Gamma \vdash M \colon \tau 
	,\] 
	если его вывод может быть произведен по правилам:
	\[
	\begin{aligned}
		x^{ \sigma } \in \Gamma && \Longrightarrow && \Gamma \vdash x\colon \sigma \\
		\Gamma \vdash M \colon \sigma \to  \tau , ~ \Gamma \vdash N \colon \sigma  && \Longrightarrow && \Gamma  \vdash MN \colon \tau \\
		\Gamma, ~ x^{\sigma} \vdash M\colon \tau  && \Longrightarrow  && \Gamma \vdash \lam{x}{M}\colon \sigma \to  \tau 
	\end{aligned}
	\]
	Если существуют $ \Gamma $ и $ \tau $ такие, что $ \Gamma \vdash M\colon \tau $, то предтерм $ M$ называют \mf{(допустимым) термом}.
\end{defn}
Запись в виде дерева вывода:
\begin{align*}
	& \Gamma \vdash x \colon \sigma , \text{ если } x^{ \alpha } \in \Gamma  \tag{аксиома} \\
	& \frac{ \Gamma \vdash M \colon \sigma  \to  \tau  \qquad \Gamma \vdash N \colon \sigma }{\Gamma \vdash MN \colon \tau } \tag{ $\to Elim$} \\
	& \frac{\Gamma, ~ x^{\alpha} \vdash M \colon \tau }{ \Gamma \vdash \lam{x}{M} \colon \sigma \to \tau } \tag{ $\to  Intro$}
\end{align*}


\section{Просто типизированное $ \lambda$-исчисление в стиле Черча. Предтермы. Утверждения о типизации. Контексты. Правила типизации.}
\subsection{Системы в стиле Черча}
Термы --- аннотированные версии бестиповых термов. Каждый терм имеет обычно уникальный тип, выводимый из способа, которым терм аннотирован.
\begin{defn}[Предтермы]
	Множество \mf{предтермов} $ \Lambda_{\mathbb{T}}$ строится из переменных из $ V = \{x, y, z, \ldots \}$ с помощью аппликации и \textit{аннотированной типами} абстракции:
	\[
	\begin{aligned}
		x \in V && \Longrightarrow && x \in \Lambda _{\mathbb{T}}\\
		M, N \in \Lambda_{\mathbb{T}} && \Longrightarrow && (MN) \in \Lambda _{\mathbb{T}}\\
		M \in \Lambda_{\mathbb{T}}, x \in V, \sigma \in {\mathbb{T}} && \Longrightarrow && (\lam{x^{\sigma}}{M}) \in \Lambda_{\mathbb{T}}
	\end{aligned}
	\]
	В абстрактном стиле: $ \Lambda _{\mathbb{T}}\Coloneqq V \mid (\Lambda_{\mathbb{T}} \Lambda_{\mathbb{T}}) \mid (\lam{V^{\mathbb{T}}}{\Lambda_{\mathbb{T}}})$.
\end{defn}
\begin{defn}
	\mf{Утверждение о типизации $ \lambda _{\to}$ по Черчу} имеет вид $ M \colon  \tau $, где субъект $ M \in \Lambda^{\mathbb{T}}$ и предикат $ \tau \in \mathbb{T}$.
\end{defn}
\begin{ex}
	Примеры утверждений типизации
    \[
    \begin{aligned}
		&\lam{x^{\alpha}}{x} \colon \alpha \to \alpha \\
		& \lam{x^{ \alpha \to  \beta }}{x}\colon ( \alpha  \to  \beta ) \to \alpha \to  \beta \\
		& \lam{x^{\alpha} \, y^{ \beta }}{x} \colon  \alpha  \to \beta  \to \alpha 
    \end{aligned}
    \]
\end{ex}
\subsection{Правила типизации}
\begin{defn}
	Утверждение $ M \colon \tau $ называется \mf{выводимым} в контексте  $ \Gamma $, обозначается 
	\[
	\Gamma \vdash M \colon \tau 
	,\] 
	если его вывод может быть произведен по правилам:
	\[
	\begin{aligned}
		x^{ \sigma } \in \Gamma && \Longrightarrow && \Gamma \vdash x\colon \sigma \\
		\Gamma \vdash M \colon \sigma \to  \tau , ~ \Gamma \vdash N \colon \sigma  && \Longrightarrow && \Gamma  \vdash MN \colon \tau \\
		\Gamma, ~ x^{\sigma} \vdash M\colon \tau  && \Longrightarrow  && \Gamma \vdash \lam{x}{M}\colon \sigma \to  \tau 
	\end{aligned}
	\]
	Если существуют $ \Gamma $ и $ \tau $ такие, что $ \Gamma \vdash M\colon \tau $, то предтерм $ M$ называют \mf{(допустимым) термом}.
\end{defn}
Запись в виде дерева вывода:
\begin{align*}
	& \Gamma \vdash x \colon \sigma , \text{ если } x^{ \alpha } \in \Gamma  \tag{аксиома} \\
	& \frac{ \Gamma \vdash M \colon \sigma  \to  \tau  \qquad \Gamma \vdash N \colon \sigma }{\Gamma \vdash MN \colon \tau } \tag{ $\to Elim$} \\
	& \frac{\Gamma, ~ x^{\alpha} \vdash M \colon \tau }{ \Gamma \vdash \lam{x^{\alpha}}{M} \colon \sigma \to \tau } \tag{ $\to  Intro$}
\end{align*}


\section{Свойства систем просто типизированного $ \lambda $-исчисления}
\begin{lm}[об инверсии или о генерации]
	~\begin{itemize}
		\item $ \Gamma \vdash x \colon \sigma \Longrightarrow x^{\sigma} \in \Gamma $
		\item $ \Gamma \vdash \lam{x}{M}\colon \tau \Longrightarrow \exists \sigma \colon [\Gamma \vdash M \colon \sigma  \to  \tau  \wedge \Gamma \vdash N \colon \sigma ]$ 
		\item Карри: $ \Gamma \vdash \lam{x}{M}\colon \rho \Longrightarrow \exists \sigma , \tau \colon [\Gamma, x^{\sigma} \vdash M\colon \tau  \wedge  \rho \equiv \sigma  \to  \tau ]$ 
		\item Черч: $ [ \Gamma  \vdash \lam{x^{\sigma}}{M}\colon \rho \Longrightarrow \exists \tau \colon [ \Gamma , x^{\sigma} \vdash M \colon \tau \wedge \rho \equiv \sigma  \to  \tau ]$
    \end{itemize}
\end{lm}
\begin{lm}[о типизируемости подтерма]
    Пусть $ M'$ --- подтерм $ M$. Тогда для некоторых  $ \Gamma '$ и $ \sigma '$
	\[
		\Gamma \vdash M \colon \sigma  \Longrightarrow \Gamma ' \vdash M'\colon \sigma '
	.\]
	То есть, если терм имеет тип, что и подтерм имеет тип.
\end{lm}
\subsection{Леммы о контекстах}
\begin{lm}[,,разбавления'']
    Пусть $ \Gamma $ и $ \Delta $ --- контексты, причем $ \Gamma \subset  \Delta $. Тогда 
	\[
	\Gamma \vdash M \colon \sigma  \Longrightarrow \Delta \vdash M\colon \sigma 
	.\] 
	Расширение контекста не влияет на выводимость утверждения типизации.
\end{lm}
\begin{lm}[о свободных переменных]
	Свободные переменные типизированного терма должны \\ присутствовать в контексте:
    \[
		\Gamma \vdash M \colon \sigma  \Longrightarrow FV(M) \subset \dom( \Gamma )
	.\]
\end{lm}
\begin{lm}[сужения]
    Сужение контекста до множества свободных переменных терма не влияет на выводимость утверждения типизации:
	\[
		\Gamma \vdash M \colon \sigma \Longrightarrow \Gamma \!\!\upharpoonright _{FV(M)} \vdash M \colon \sigma 
	.\] 
\end{lm}
Вместе эти леммы отвечают на вопрос: какой контекст требуется, чтобы произвести присваивание типов? Ответ следующий: в контексте обязательно должны присутствовать свободные переменные типизируемого терма; все остальные переменные опциональны, не влияют на типизацию и могут быть безболезненно отброшены по лемме сужения.

Рассмотрим предтерм $ x x$. Пусть это терм.
Тогда есть  $ \Gamma $ и $\tau $:
\[
\Gamma \vdash x x \colon \tau 
.\] 
По лемме об инверсии существует $ \sigma $, что правый подтерм $ x\colon \sigma$, левый подтерм (тоже $ x$) имеет тип  $ \sigma  \to  \tau $.

По лемме о контекстах $ x \in \dom(\Gamma)$ и должен иметь там единственное связывание по определению контекста. То есть $ \sigma = \sigma  \to  \tau $ --- получили, что тип является подвыражением себя, чего не может быть, так как типы конечны.

Тогда $ \omega $,  $ \Omega $ и \Y не имеют типа по лемме о типизируемости подтерма.

\begin{defn}
	Для $ \sigma , \tau \in \mathbb{T}$ \mf{подстановку} $ \tau $ вместо $ \alpha $ в $ \sigma $ обозначим $ \subst{\alpha}{\tau}{\sigma}$.
\end{defn}
\begin{ex}
	\[
		\subst{ \alpha }{( \gamma  \to \gamma )}{ \alpha \to  \beta  \to  \alpha } = ( \gamma \to  \gamma ) \to  \beta \to  \gamma  \to \gamma 
		.\]
\end{ex}
\begin{lm}[подстановки типа]
	Подстановка в выводимое утверждение типизации некоторого типа вместо переменной типа порождает выводимое утверждение типизации.
	\begin{description}
		\item[Карри:] 
			\[
				\Gamma \vdash M\colon \sigma  \Longrightarrow \subst{ \alpha }{ \tau } \Gamma \vdash M \colon \subst{ \alpha }{ \tau }{ \sigma }
			.\] 
		\item[Черч:]
			\[
				\Gamma \vdash M\colon \sigma  \Longrightarrow \subst{ \alpha }{ \tau } \Gamma \vdash \subst{ \alpha }{ \tau }{M} \colon \subst{ \alpha }{ \tau }{ \sigma }
			.\] 
	\end{description}
\end{lm}
\begin{ex}
	Подстановка $\subst{ \alpha }{ (\gamma \to  \gamma )}{}$ в утверждение типизации для системы Черча
	\[
		x^{ \alpha } \vdash \lam{y^{\alpha} z^{ \beta }}{x}\colon \alpha  \to  \beta  \to  \alpha 
	\] 
осуществляется и в тип, и в терм, и в контекст и дает новое утверждение типизации
\[
	x^{\gamma \to \gamma } \vdash (\lam{y ^{ \gamma  \to  \gamma } z ^{ \beta }}{x})\colon ( \gamma \to  \gamma ) \to  \beta \to \gamma  \to  \gamma 
.\] 
Поскольку первое утверждение типизации выводимо, то и второе тоже
выводимо.
\end{ex}
\begin{lm}[подстановке терма]
	Пусть $ \Gamma , ~ x^{\sigma} \vdash M\colon \tau $ и $ \Gamma \vdash N\colon \sigma $, тогда
	\[
		\Gamma \vdash \subst{x}{N}{M}\colon \tau 
	.\] 
	Подходящая по типу подстановка терма сохраняет тип.
\end{lm}
\begin{ex}
	Берем выводимое утверждение типизации
	\[
		x^{ \gamma \to \gamma }\vdash \lam{y^{ \beta }}{x} \colon \beta  \to \gamma \to \gamma 
	.\] 
	и подставляем в него вместо свободной переменной $ x$ типа $ \gamma  \to  \gamma $ терм $\lam{z ^{\gamma}}{z}$ подходящего типа $ \gamma  \to  \gamma $. 
	Получаем
	\[
		\vdash \lam{y^{\beta}z^{\gamma}}{z}\colon \beta \to \gamma \to  \gamma 
	.\] 
\end{ex}
\begin{thm}[о редукции субъекта]
    Пусть $ M \llba N$, тогда 
	\[
	\Gamma \vdash M\colon \sigma  \Longrightarrow \Gamma \vdash N \colon \sigma 
	.\] 
	Тип терма сохраняется про $ \beta $-редукциях.
\end{thm}
\begin{proof}
    Следует из леммы о подстановке терма.
\end{proof}
\begin{cor}
    Множество типизируемых в $ \lambda_{\to}$  термов замкнуто относительно редукции.
\end{cor}
В обратную сторону теорема и следствие не верны для $ \lambda_{\to}$.

\begin{thm}[о единственности типа для $ \lambda_{\to}$ по Черчу]
    Пусть $ \Gamma \vdash M\colon \sigma $ и $ \Gamma \vdash M\colon \tau $. Тогда $ \sigma \equiv \tau $.

	Терм в $ \lambda_{\to}$ по Черчу имеет единственный тип.
\end{thm}
\begin{cor}
    Пусть $ \Gamma \vdash M\colon \sigma, ~ \Gamma \vdash N\colon \tau  $ и $ M \eqb N$. Тогда $ \sigma \equiv \tau $.

	Типизируемые $ \beta $-конвертируемые термы имеют одинаковый тип в $ \lambda_{\to}$ по Черчу.
\end{cor}

\begin{ex}[Контрпример для системы по Карри]
	Следующие два типа подходят для $ K = \lam{x\,y}{x}$ по Карри:
	 \[
	\begin{aligned}
		&\vdash \lam{x\,y}{x} \colon \alpha \to ( \delta  \to  \gamma \to  \delta ) \to  \alpha \\
		&\vdash \lam{x\,y}{x} \colon ( \gamma \to \gamma ) \to  \beta \to \gamma \to \gamma 
	\end{aligned}
	\]
\end{ex}


\section{Связь между системами Карри и Черча. Проблемы разрешимости. Сильная и слабая нормализация.}
Зададим для Черча \textit{стирающее отображение} $ \lvert \cdot \rvert \colon \Lambda_{\mathbb{T}} \to \Lambda$:
\[
\begin{aligned}
	\lvert x \rvert  && \equiv && x \\
	\lvert MN \rvert  && \equiv && \lvert M \rvert \lvert N \rvert \\
	\lvert \lam{x^{\sigma}}{M} \rvert && \equiv && \lam{x}{\lvert M \rvert }
\end{aligned}
\]
Все атрибутированные типами термы из версии по Черчу ,,проектируются'' в термы в версии по Карри:
\[
	M \in \Lambda_{\mathbb{T}} \wedge \Gamma \vdash_{ч} M\colon \sigma  \Longrightarrow \Gamma \vdash_{к} \lvert M \rvert \colon \sigma 
.\] 

Также можно ,,поднять'' в обратную строну из Карри в Черча, правильно подобрав типы:
\[
	M \in \Lambda \wedge \Gamma \vdash_{к} M\colon \sigma  \Longrightarrow \exists N \in \Lambda_{\mathbb{T}} \colon [ \Gamma \vdash_{ч} N\colon \sigma  \wedge  \lvert N \rvert  \equiv \lvert M \rvert ]
.\] 

Для произвольного типа $ \sigma \in \mathbb{T}$ обитаемость в версии по Карри равносильна обитаемости в версии по Черчу.
\subsection{Проблемы разрешимости}
Для любой системы типов важную роль имеют проблемы разрешимости основных задач: есть ли алгоритм, решающий данную задачу?
\begin{figure}[ht]
	\centering
	\begin{tabular}{l|l|l}
		$ \vdash M\colon \sigma ?$ & Задача проверки типа & ЗПТ, TCP \\
		\hline
		$ \vdash M \colon ?$ & Задача синтеза типа & ЗСТ, TSP / TAP \\
		\hline
		$ \vdash ? \colon \sigma $ & Задача обитаемости типа & ЗОТ, TIP
	\end{tabular}
\end{figure}
Для $ \lambda_{\to}$ все эти задачи разрешимы.
Первые две задачи будут решены с помощью теоремы Хиндли-Миллера.

\begin{defn}\index{нормализуемость}
	Терм называется \mf{слабо (weak) нормализуемым} (WN), если существует последовательность редукций, приводящих его к нормальной форме.

	\noindent
	Терм называется \mf{сильно (strong) нормализуемым} (SN), если любая последовательность редукций, приводящих его к нормальной форме.
\end{defn}
\begin{ex}
    $ KIK$ сильно нормализуем, $ KI \Omega $ слабо нормализуем, $ \Omega $ не нормализуем вообще.
\end{ex}

\begin{defn}
	Систему типов называют \mf{слабо нормализуемой}, если все ее допустимые термы слабо нормализуемы.

	\noindent
	Систему типов называют \mf{сильно нормализуемой}, если все ее допустимые термы сильно нормализуемы.
\end{defn}

\begin{thm}[о нормализации $ \lambda_{\to}$]
	Обе системы (по Карри и по Черчу) сильно нормализуемы.

	То есть любой допустимый терм в $ \lambda_{\to}$ всегда редуцируется к нормальной форме независимо от выбранной стратегии редукции.
\end{thm}


\section{Понятие главного (наиболее общего) типа. Подстановка типа и их композиция.}
Для систем Карри и {\color{red}Черча} верна \textit{лемма подстановки типа}:
\[
	\Gamma \vdash M\colon \sigma  \Longrightarrow \subst{ \alpha }{ \tau } {\Gamma} \vdash {\color{red} \subst{\alpha}{\tau}{}}M \colon \subst{\alpha}{\tau}{\sigma}
.\] 
В версии Черча $ \lambda_{\to}$ термы атрибутированы типами, поэтому тип терма единственен:
\[
\begin{aligned}
	& \lam{f^{ \sigma \to \tau \to \rho} g^{ \sigma \to  \tau } z^{ \sigma }}{f\,z(g\,z)} \colon ( \sigma \to  \tau \to  \rho) \to (\sigma \to \tau ) \to  \sigma \to  \rho \\
	& \lam{f^{ \sigma \to \tau \to \sigma} g^{ \sigma \to  \tau } z^{ \sigma }}{f\,z(g\,z)} \colon ( \sigma \to  \tau \to  \sigma) \to (\sigma \to \tau ) \to  \sigma \to  \sigma \\
	& \lam{f^{ (\tau \to \rho) \to \tau \to \rho} g^{ (\tau \to \rho) \to  \tau } z^{ (\tau \to \rho) }}{f\,z(g\,z)} \colon ( (\tau \to \rho) \to  \tau \to  \rho) \to ((\tau \to \rho) \to \tau ) \to  (\tau \to \rho) \to  \rho 
\end{aligned}
\]
Любой из этих типов можно приписать терму
$S = \lam{f\, g\, z}{f\, z (g\, z)}$ в версии Карри.

Однако, первый ,,лучше'' в том смысле, что остальные получаются из него подстановками типа вместо типовых переменных. Он называется \mf{главным (principle)}. Также он отличается тем, что в нем меньше всего стрелок и максимальное разнообразие типов. 

\subsection{Вывод главного типа}
Пусть у нас есть комбинатор
\[
	S = \lam{x\,y}{y(\lam{z}{y\,x})}
.\] 
Припишем всем термовым переменным типовую метапеременную:
\[
	\lam{x^{\alpha}\,y^{\beta}}{y^{\beta}(\lam{z^{\gamma}}{y^{\beta}\,x^{\alpha}})}
.\] 
Припишем типовую переменную метапеременную всем аппликативным подтермам: $ (y\,x) '\colon \delta , ~ y(\lam{z}{y\,z})\colon \varepsilon $
\[
	\lam{x^{\alpha}\,y^{\beta}}{\underbrace{y^{\beta}(\lam{z^{\gamma}}{\overbrace{y^{\beta}\,x^{\alpha}}^{\delta}})}_{\varepsilon}}
.\] 
Теперь можем связать некоторые метапеременные уравнениями, необходимыми для типизируемости терма:
\[
	\beta \sim \alpha \to \delta , \quad \beta \sim ( \gamma \to \delta ) \to \varepsilon 
.\] 
Найдем главный унификатор для типовых переменных (подстановку), дающий решения уравнений:
\[
	\alpha \coloneqq \gamma \to  \delta , ~ \beta \coloneqq (\gamma \to \delta ) \to  \varepsilon , ~ \delta \coloneqq  \varepsilon 
.\] 
Главный тип 
\[
	\lam{x\,y}{y(\lam{z}{y\,z})} \colon ( \gamma \to  \varepsilon ) \to (( \gamma \to  \varepsilon ) \to \varepsilon) \to  \varepsilon 
.\] 
\begin{defn}[Подстановка типа]
	\mf{Подстановка типа} --- операция $ S \colon \T \to  \T$ такая, что
	\[
		S( \sigma \to \tau ) \equiv  S( \sigma ) \to S( \tau )
	.\] 
\end{defn}
Можно представлять типы как вершины бинарного дерева, пара ребер соответствует подстановке.
Обычно подстановка тождественна на всех типовых переменных, кроме конечного носителя
\[
	\sup (S) = \{ \alpha \mid S( \alpha ) \not \equiv \alpha \}
.\] 
Пример подстановки:
\[
S = [a \coloneq \gamma \to  \beta , \beta \coloneqq   \alpha \to  \gamma ]
.\] 
Тождественная подстановка (то есть с пустым носителем) обозначают $ []$.

Все подстановки происходят \textit{параллельно}: для  $ \tau = \alpha \to \beta \to \gamma $ :
\[
\begin{aligned}
	S( \tau ) & = [ \alpha \coloneq \gamma \to \beta , \beta \coloneqq \alpha \to  \gamma ] ( \alpha \to  \beta \to \gamma ) = \\
			  &= ( \gamma \to  \beta ) \to ( \alpha \to \gamma ) \to  \gamma 
\end{aligned}
\]
\begin{defn}[Композиция подстановок]
	\mf{Композиция двух подстановок} --- подстановка с носителем,
являющимся объединением носителей, над которым
последовательно выполнены обе подстановки.
\end{defn}
Подстановки образуют моноид относительно композиции и с $ []$ в роли нейтрального элемента.

\begin{defn}[Унификатор]
	\mf{Унификатор для типов} $ \sigma $ и $ \tau $ --- подстановка $ S$ такая, что $ S( \sigma ) \equiv S( \tau )$.
\end{defn}
\begin{ex}
	Пусть $ \sigma  = \alpha \to \beta \to \gamma $, $ \tau  = (\delta \to  \varepsilon ) \to  \phi$.
	Унификатор:
	\[
		S = [ \alpha \coloneqq \delta \to  \varepsilon , \varphi \coloneqq \beta \to \gamma ]
	.\] 
	В результате такой подстановки
	\[
		S( \sigma ) \equiv S( \tau ) \equiv ( \delta \to \varepsilon ) \to (\beta \to \gamma )
	.\] 
\end{ex}
Когда выделяем одну элементарную подстановку нужно сразу выполнить ее повсюду.

\begin{defn}[Главный унификатор]
	Унификатор $ S$ --- \mf{главный унификатор} для $ \sigma $ и $ \tau $, если для любого другого унификатора $ S'$ существует подстановка $ T$ такая,  что
	\[
	S' \equiv T \circ S 
	.\] 
\end{defn}


\section{Алгоритм унификации}
\begin{thm}[Робинсон, 1965]
    Существует алгоритм унификации $U$, который для заданных типов $ \sigma $ и $ \tau $ возвращает:
	\begin{itemize}
		\item главный унификатор $ S$ для $\sigma$ и $ \tau $, если $ \sigma $ и $ \tau $ могут быть унифицированы;
		\item сообщение об ошибке в противном случае.
	\end{itemize}
\end{thm}
Алгоритм $ U( \sigma , \tau )$ позволяет искать минимальное решение уравнения на типы $ \sigma \sim \tau $.

\mf{Ключевой момент} всех рассуждений про унификацию:
\[
\sigma _1 \to \sigma _2 \equiv \tau _1 \to  \tau _2 \Longleftrightarrow \sigma _1 \equiv \tau _1 \wedge \sigma _2 == \tau _2
.\] 

\subsection{Алгоритм }
Опишем алгоритм:
\[
\begin{aligned}
	& U( \alpha , \alpha ) &&=&& [] \\
	& U( \alpha , \tau ) \mid \alpha \in FV( \tau ) &&=&& error \\
	& U( \alpha , \tau ) \mid \alpha \notin FV( \tau ) &&=&& [ \alpha \coloneqq \tau ] \\
	& U( \sigma _1 \to \sigma _2, \alpha ) && = && U( \alpha , \sigma _1, \sigma _2) \\
	& U( \sigma _1 \to \sigma _2, \tau _1 \to \tau _2) &&=&& U(U_2 \sigma _1, U_2 \sigma _1) \circ U_2 \quad \text{where } U_2 = U( \sigma _2, \sigma _1)
\end{aligned}
\]
\begin{itemize}
	\item $ U( \sigma , \tau )$ завершается, так как деревья типа конечны и количество типовых переменных сокращается на $ 1$ через конечное число шагов: интересен только последний шаг (остальные сразу точно завершаются), но мы дойдем до переменных, так как увеличение происходит из-за обход по поддереву, а его высота каждый раз уменьшается, с некоторого момента, общая высота станет уменьшаться; когда мы дошли до переменной, их количество уменьшиться.
	\item $ U( \sigma, \tau )$ унифицирует: по индукции, если $ S$ унифицирует $ ( \sigma, \tau )$, то $ S \circ [ \alpha \coloneqq \rho]$ унифицирует $ ( \sigma \to \alpha , \tau \to \rho)$.
	\item $ U ( \sigma , \tau )$ выдает главный унификатор.
\end{itemize}


\section{Алгоритм построения системы ограничений.}
Наша первая цель --- построить систему ограничений на типы для терма $M$ (возможно незамкнутого).

Для типизации таких термов необходим контекст $ \Gamma $, в котором объявляются типы всех свободных переменных.

Для подстановки $ S$, унифицирующей систему уравнений на типы
\[
E = \{ \sigma _1 \sim \tau _1, \ldots \sigma _n \sim \tau _n\}
,\] 
введем обозначение $ S \vDash E$.
\begin{thm}[Теорема о существовании системы ограничений]
	Для любых терма $ M \in \Lambda$, контекста $ \Gamma $ ($ FV(M) \subseteq \dom(\Gamma)$) и типа $ \sigma \in \T$ существует конечное множество уравнений на типы $E = E(\Gamma , M, \sigma )$, такое что для некоторой подстановки $ S$:
	\begin{itemize}
		\item
			$ S \vDash E( \Gamma , M, \sigma ) \Longrightarrow S(\Gamma) \vdash M\colon S(\sigma)$ 
		\item $ S(\Gamma) \vdash M \colon S(\sigma) \Longrightarrow S' \vDash E( \Gamma , M, \sigma )$, для некоторого $ S'$, имеющего тот же эффект, что и $ S$, на типовых переменных в $ \Gamma $ и $ \sigma $.
	\end{itemize}
\end{thm}
\subsection{Алгоритм}
\[
\begin{aligned}
	&E(\Gamma, x, \sigma ) &&=&& \{\sigma \Gamma (x)\} \\
	&E( \Gamma , MN, \sigma ) &&=&& E( \Gamma , M, \alpha \to \sigma )\\
	&E( \Gamma , \lam{x}{M}, \sigma ) &&=&& E( \Gamma \cup \{x \colon \alpha \}, M, \beta ) \cup \{ \alpha \to \beta ~ \sigma \}
\end{aligned}
\]
В первом равенстве контекст $ \Gamma$ рассматривается как функция из множества переменных в множество типов.

Переменные $ \alpha $ во втором и третьем равенствах и $ \beta $ в третьем всякий раз должны быть ,,свежими''!


\section{Главная пара и главный тип. Теорема Хиндли-Миллера.}
\begin{defn}[Главная пара]
	\mf{Главная пара} для $ M \in \Lambda$ --- пара $ ( \Gamma , \sigma )$ такая, что
	\begin{itemize}
		\item $ \Gamma \vdash M \colon \sigma $
		\item $ \Gamma ' \vdash M \colon \sigma ' \Longrightarrow \exists S \colon S(\Gamma) \subseteq \Gamma ' \wedge S(\sigma) \equiv \sigma '$
\end{itemize}
\end{defn}
\begin{ex}
	Для $M = \lam{x}{x\, y}$ имеем
	\[
	\begin{aligned}
		&PP(M) = (y\colon \alpha , ( \alpha \to  \beta ) \to  \beta 
		\\
		& y\colon \alpha \vdash (\lam{x}{x\,y})\colon ( \alpha \to \beta ) \to \beta 
	\end{aligned}
	\]
\end{ex}
\begin{thm}[Теорема Хиндли – Милнера]
Существует алгоритм $PP$, возвращающий для $M \in  \Lambda$ главную пару $(\Gamma , \sigma )$, если $ M$ имеет тип и сообщение об ошибке в противном случае.
\end{thm}
Пусть 
\[
	FV(M) = \{x_1 , \ldots  , x_n \}
\]
\[
	\Gamma_ 0 = {x_1 \colon  \alpha _1 , \ldots  , x_n \colon  \alpha _n }, \quad\sigma_0 = \beta 
.\] 
\subsection{Алгоритм PP}
\[
\begin{aligned}
PP(M) \mid U(E(\Gamma_0 , M, \sigma _0 )) \equiv  error = error \\
PP(M) \mid U(E(\Gamma_0 , M, \sigma _ 0 )) \equiv  S = (S(\Gamma_0 ), S(\sigma_0 ))
\end{aligned}
\]
Стартуем с произвольных переменных типа, приписанных свободным переменным типизируемого терма $M$ и всему терму.

\subsection{Главный тип (Principle Type)}
\begin{defn}[Главный тип]
	Для $M \in  \Lambda_0$ \mf{главным типом} называют тип $ \sigma $, такой что
	\begin{itemize}
		\item
			$ M \colon \sigma $
		\item $ M \colon \sigma ' \Longrightarrow \exists S\colon S(\sigma) \equiv \sigma '$
\end{itemize}
\end{defn}
\begin{cor}[Следствие теоремы Хиндли – Милнера]
Существует алгоритм $PT$ , возвращающий для $M \in  \Lambda_0$ главный тип $ \sigma $, если $ M$ имеет тип и сообщение об ошибке в противном случае.
\end{cor}






\end{document}
