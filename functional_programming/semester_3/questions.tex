\documentclass[11pt,a4paper]{article}
\input{preamble.tex}

\title{Билеты к экзамену по функциональному программированию}
\author{Тамарин Вячеслав}


\makeindex


\begin{document}
\maketitle


\section{Сравнение функционального и императивного подходов к программированию}
\subsection{Императивное программирование}
Вычисление (программа) описывается в терминах \mf{инструкций}, изменяющих \mf{состояние} вычислителя.
\begin{itemize}
	\item Инструкции выполняются последовательно;
	\item Состояние изменяется инструкциями \mf{присваивания} значений изменяемым переменным;
	\item Если механизм условного исполнения (if, switch);
	\item Инструкции можно повторять с помощью циклов (while, for);
	\item Типы данных описываются с оглядкой на их физическое представление в памяти.
\end{itemize}
Такой стиль иногда называют стилем фон Неймана.
\begin{ccode}
long factorial(int n) {
	long res = 1;
	for (int i = 0; i < n; i++) 
		res *= i;
	return res;
}
\end{ccode}
Выполнение программы --- переход вычислителя из начального состояния в конечное с помощью последовательных инструкций.

Часть конечного состояния может интерпретироваться как результат вычислений.

\subsection{Функциональное программирование}
	Функциональная программа --- \mf{выражение}, ее выполнение --- вычисление (\mf{редукция}) этого выражения.
\begin{hscode}
factorial n = if n == 0 then 1 else n * factorial(n-1)
\end{hscode}
Выполнение программы --- редукция выражения с помощью \mf{подстановки} определений функций в места их ,,вызова'' с заменой формальных параметров на фактические.
\begin{minted}[fontsize=\footnotesize,numbersep=3pt,framesep=1mm,linenos,bgcolor=lbg]{hs}
factorial 3
-> if 3 == 0 then 1 else 3 * factorial (3 - 1)
-> ...
-> 3 * factorial (3 - 1)
-> 3 * if (3 - 1) == 0 then 1 else (3 - 1) * factorial ((3 - 1) - 1)
-> ...
-> 3 * 2 * 1 * 1 
-> 6
\end{minted}

\begin{minipage}{0.47\linewidth}
\begin{itemize}
	\item Нет состояний --- нет изменяемых переменных;
	\item Нет переменных --- нет присваивания;
	\item Нет циклов, так как нет различий между итерациями -- состояниями
	\item Последовательность не важна, поскольку выражения независимы.
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}{0.47\linewidth}
	\begin{itemize}
		\item Рекурсия --- замена циклов;
		\item Функции высших порядков;
		\item Сопоставление с образцом;
		\item Все функции --- чистые.
    \end{itemize}
\end{minipage}
\subsection{Сильные стороны ФП}
\begin{itemize}
	\item Регулярный синтаксис, удобство анализа кода;
	\item Мощная типизация, при этом можно практически не использовать типы в коде за счет эффективным алгоритмам вывода типов;
	\item Возможность генерации программ по набору свойств;
	\item Эффективная доказуемость свойств программ алгебраическими методами;
	\item Высокоурвневые оптимизации на базе эквивалентных преобразований.
\end{itemize}

\section{Основы $ \lambda$-исчисления. $ \lambda$-термы, свободные и связанные переменные.}
$ \lambda$-исчисление --- формальная система, лежащая в основе ФП. Разработано Алонзо Чёрчем в 1930-х для формализации и анализа понятия вычислимости.

\noindent
В \LMCисчислении тремя основными понятиями являются:
\begin{itemize}
	\item применение (аппликация, application) --- задает синтаксис применения функции к ее фактическим аргументам.
		Применение функции $ F$ к аргументу $ X$ записывается как $ FX$;
	\item лямбда-абстрацкия (abstraction) --- описывает синтаксис определения функции на основе параметризованного выражения, представляющего ее тело. Абстракция по x: $ \lam{x}{F}$;
	\item редукция (reduction) --- определяет отношение вычисления, основывающегося на подстановке фактических параметров вместо формальных.
\end{itemize}
\begin{defn}[$ \lambda$-термы]\index{$ \lambda $-терм}
	Множество \mf{$ \lambda $-термов} $ \Lambda$ индуктивно строится из переменных  $ V = \{x, y, z, \ldots \}$ с помощью применения и абстракции:
\[
\begin{aligned}
	x \in V && \Longrightarrow &&& x \in \Lambda \\
	M, N \in \Lambda && \Longrightarrow &&& (MN) \in \Lambda \\
	M \in \Lambda, ~  x \in  V && \Longrightarrow &&& (\lam{x}{M}) \in \Lambda
\end{aligned}
\]
В абстрактном синтаксисе 
\[
	\Lambda \Coloneqq V \mid (\Lambda \Lambda) \mid (\lam{V}{\Lambda})
.\] 
\end{defn}
Терм может быть \textit{переменной} (например, $ x \in \Lambda$), \textit{аппликацией} (например, $ (xy) \in \Lambda$) или \textit{лямбда-абстракцией} (например, $ \lam{x}{((x(yx)))} \in  \Lambda$).

\begin{defn}[Подтермы]\index{подтерм}
	Множество \mf{подтермов} терма $ Q$ определяется индуктивно:
	\[
	\begin{aligned}
		&\subterms(x) && = && \{x\} \\
		&\subterms(MN) && = && \{MN\} \cup \subterms(M) \cup \subterms(N) \\
		&\subterms(\lam{x}{M}) && = && \{\lam {x}{M}\} \cup \subterms(M)
	\end{aligned}
	\]
\end{defn}


\subsection{Соглашения}
Общеприняты следующие соглашения для термов:
\begin{itemize}
	\item Внешние скобки опускаются
	\item Применение  ассоциативно \textit{влево}:
		\[
			FXYZ \equiv (((FX)Y)Z)
		.\] 
	\item Абстракция ассоциативна \textit{вправо}:
		\[
			\lam{x y z}{M} \equiv (\lam{x}{(\lam{y}{(\lam{z}{M})})})
		.\] 
	\item Тело абстракции простирается вправо насколько это возможно:
		\[
			\lam{x}{MNK} \equiv \lam{x}{(MNK)}
		.\] 
\end{itemize}

\begin{defn}[Свободные переменные]\index{свободные переменные}
	Множество \mf{свободных переменных} в терме $ Q$ ($ FV(Q)$) определяется следующим образом:
	\[
	\begin{aligned}
		& FV(x) && = && \{x\} \\
		& FV(MN) && = && FV(M) \cup FV(N) \\
		& FV(\lam{x}{M} && = && FV(M) \setminus \{x\}
	\end{aligned}
	\]
\end{defn}

\begin{defn}[Связвнные переменные]\index{связанные переменные}
	Множество \mf{связанных переменных} в терме $ Q$ ($ BV(Q)$) определяется следующим образом:
	\[
	\begin{aligned}
		& BV(x) && = && \varnothing \\
		& BV(MN) && = && BV(M) \cup BV(N) \\
		& BV(\lam{x}{M} && = && BV(M) \cup  \{x\}
	\end{aligned}
	\]
\end{defn}

\subsection{Комбинаторы}
\begin{defn}[Комбинатор]\index{комбинатор}
$ M$ --- \mf{замкнутый $ \lambda$-терм (комбинатор)}, если $ FV(M) = \varnothing$. 

\noindent
Множество замкнутых $ \lambda$-термов обозначается $ \Lambda^{0}$.
\end{defn}
\begin{enumerate}[noitemsep]
	\item $ I = \lam{x}{x}$
	\item $ \omega = \lam{x} {x x}$
	\item $ \Omega = \omega \omega = \left( \lam{x}{x x} \right) \left( \lam{x}{x x} \right) $
	\item $ K = \lam{x y} {x}$
	\item  $ K_{*} = \lam{x y}{y}$
	\item $ C = \lam{f x y}{f y x}$ 
	\item $ B = \lam{f g x}{f (g x)}$
	\item $ S = \lam{f g x}{f x (g x)}$
\end{enumerate} 


\section{Подстановка $ \lambda$-терма. Лемма подстановки.}
\begin{defn}[Подстановка]\index{подстановка}
	\mf{Подстановка} терма $ N$ вместо \textit{свободных} вхождений переменной $ x$ в терм $ M$ ($ \subst{x}{N}{M}$) задается следующими правилами:
	\[
	\begin{aligned}
		& \subst{x}{N}{x} && = && N \\
		& \subst{x}{N}{y} && = && y \\
		& \subst{x}{N}{PQ} && = && \left( \subst{x}{N}{P} \right) \left( \subst{x}{N}{Q} \right)   \\
		& \subst{x}{N}{\lam{x}{P}} && = && \lam{x}{P} \\
		& \subst{x}{N}{\lam{y}{P}} && = && \lam{y}{\subst{x}{N}{P}}, && \text{ если } y \notin FV(N)\\
		& \subst{x}{N}{\lam{y}{P}} && = && \lam{x}{\subst{y}{z}{P}}\left( \subst{y}{z}{P} \right) , && \text{ если } y \in FV(N)
	\end{aligned}
	\]
	Предполагается, что $ x$ и $ y$ различны, а $ z$ --- ,,свежая'' переменная, то есть $ z \notin FV(P) \cup FV(N)$.
\end{defn}
\begin{ex}[Пример подстановки]
    \[
	\subst{x}{uv}{\left( \left( \lam{\color{red}x}{(\lam{\color{green}x}{{\color{green}x}z}){\color{red}x}} \right) x  \right) } = 
	\left( \lam{\color{red}x}{(\lam{\color{green}x}{{\color{green}x}z})\color{red}x} \right) (uv)
    .\] 
\end{ex}
\begin{lm}[подстановки]
	Пусть $ M, N, L \in \Lambda$, $ x \not\equiv y $ и $ x \notin FV(L)$. Тогда 
	\[
		\subst{y}{L}{\subst{x}{N}{M}} = \subst{x}{\subst{y}{L}{N}}{\subst{y}{L}{M}}
	.\] 
\end{lm}

\section{$ \alpha $- и $ \beta $-конверсии. $ \eta$-конверсия и экстенсиональная эквивалентность.}
\subsection{$ \alpha $-эквивалентность}\index{$ \alpha $-эквивалентность}
Позволяет менять переменную на ,,свежую''.
Главная аксиома $ \alpha $-преобразования:
\[
	\tag{правило $\alpha$}
	\lam{x}{M} \eqa \lam{y}{\subst{x}{y}{M}}, \text{ если } y \notin FV(M)
.\] 
Аналогично $ \beta $-эквивалентности можно определить совместимость.
\subsection{$ \beta $-эквивалентность}
\mf{Основная схема аксиом}: для любых $ M, N \in \Lambda$:
\[
	(\lam{x}{M})N \eqb \subst{x}{N}{M} \tag{правило $ \beta $ }
.\] 
Чтобы сделать $ \eqb$ отношением эквивалентности добавим логические аксиомы и правила:
\[
\begin{aligned}
	& && && M \eqb M \\
	& M \eqb N && \Rightarrow && M \eqb N \\
	& M \eqb N, ~ N \eqb L && \Rightarrow && M \eqb L
\end{aligned}
\]
Также определим правила совместимости:
\begin{align*}
	& M \eqb N  \Rightarrow  ZM \eqb ZN \\
	& M \eqb N  \Rightarrow  MZ \eqb NZ \\
	& M \eqb N  \Rightarrow  \lam{x}{M} \eqb \lam{x}{N} \tag{правило $ \xi$}
\end{align*}

Если $ M \eqb N$ доказуемо в $ \lambda$-исчислении, пишут 
 \[
\lambda \vdash M \eqb N
.\] 
\subsection{$ \eta$-эквивалентность}\index{$ \eta $-эквивалентность}
Схема аксиом $ \eta$-преобразования:
\[
	\tag{правило $ \eta$ }
	\lam{x}{Mx} \eqn M, \text{ если } x \notin FV(M)
.\] 
Аналогично можем определить правила и совместимость, как для $ \beta $.

Смысл этой эквивалентности в том, что поведение данных двух термов одинаково; для произвольного $ N$ будет верно
\[
	(\lam{x}{M})N \eqb MN
.\] 
\paragraph{Принцип экстенсиональности}
Две функции считаются \mf{экстенсионально эквивалентными}, если они дают одинаковый результат при одинаковом входе:
\[
\forall N\colon FN \eqb GN
.\] 
Выберем $ u \notin FV(F) \cup FV(G)$, теперь
\[
	Fy \eqb Gy \Longrightarrow \lam{y}{Fy} \eqb \lam{y}{Gy} \Longrightarrow F =_{\beta \eta} G
\]


\section{Кодирование булевых значений, кортежей в чистом беcтиповом $ \lambda $-исчислении.}
\subsection{Булевы значения}
\[
\begin{aligned}
	&\tru &&\equiv&& \lam{t f}{t} \\
	&\fls &&\equiv&& \lam{t f}{f}
\end{aligned}
\]
\subsection{Булевы операции}
\[
\begin{aligned}
	&\fpif &&\equiv&& \lam{b x y}{b x y} \\
	&\fpnot &&\equiv && \lam{b}{b \fls \tru} \\
	&\fpand &&\equiv && \lam{x y} {x y \fls} \\
	&\fpor &&\equiv && \lam{x y}{x \tru y}
\end{aligned}
\]
\subsection{Кортежи}
Пара и стандартные операции:
\[
\begin{aligned}
	&\pair &&\equiv&& \lam{x y f}{f x y} \\
	&\fst &&\equiv && \lam{p}{p \tru} \\
	&\snd &&\equiv && \lam{p}{p \fls}
\end{aligned}
\]
\section{Кодирование чисел Чёрча в чистом бестиповом $ \lambda $-исчислении.}
\[
\begin{aligned}
	& 0 &&\equiv && \lam{s z}{z} \\
	& 1 && \equiv && \lam{s z}{s z} \\
	& 2 && \equiv && \lam{s z}{s(s z)} \\
	& 3 &&\equiv && \lam{s z}{s(s(s z))} \\
	& 4 &&\equiv && \lam{s z}{s(s(s(s z)))} \\
	&&& \dots && 
\end{aligned}
\]
Определим $ F^{n}(X)$, где $ n \in \N$, $ F, Z \in \Lambda$:
\[
\begin{aligned}
	&F^{0}(X) &&\equiv && X \\
	&F^{n+1}(X) && \equiv && F(F^{n}(X))
\end{aligned}
\]
Теперь число Чёрча принимает следующий вид
\[
	n \equiv \lam{s z}{s^{n}(z)}
.\] 
Функция проверки на ноль:
\[
	\iszero \equiv \lam{n}{n (\lam{x}{\fls}) \tru}
.\] 
Переход к следующему числу:
\[
	\fpsucc \equiv \lam{n s z}{s (n s z)}
.\] 
Сложение:
\[
	\plus \equiv \lam{m n s z}{m s (n s z)}
.\] 
Умножение:
\[
\begin{aligned}
	&\fpmult &&\equiv&& \lam{m n}{m (\plus n) 0}\\
	&\fpmult &&\equiv&& \lam{m n s z}{m (n s) x}
\end{aligned}
\] 

\section{Теорема о неподвижной точке. Y-комбинатор.}
\subsection{Решение уравнений на термы}
Например, хотим найти $ F$ такой, что $ \forall M, N, L\colon \lambda \vdash FMNL = ML(NL)$.
\[
\begin{aligned}
	& FMNL && = && ML(NL) \\
	& FMNL && = && (\lam{l}{Ml(Nl)})L \\
	& FMN && = && \lam{l}{Ml(Nl)} \\
	& FM && = && \lam{n}{\lam{l}{Ml(nl)}} \\
	& F && = && \lam{mnl}{ml(nl)}
\end{aligned}
\]
А что делать, если уравнение рекурсивное? Например, $ FM = MF$.
\subsection{Теоремы о неподвижной точке}
\begin{thm}
    Для любого $ \lambda$-терма $ F$ существует неподвижная точка:
	\[
	\forall F \in \Lambda ~ \exists X \in \Lambda\colon \lambda \vdash FX = X
	.\] 
\end{thm}
\begin{proof}
	Пусть $ W \equiv \lam{x}{F(x x)}$ и $ X \equiv WW$. Тогда
	\[
		X \equiv WW \equiv (\lam{x}{F(x x)})W = F(WW) \equiv F X
	.\] 
\end{proof}
\begin{thm}\index{комбинатор неподвижной точки}
	Существует комбинатор неподвижной точки $\Y$ такой, что
	 \[
		 \forall F\colon F(\Y F) = \Y F
	.\] 
\end{thm}
\begin{proof}
	Пусть $ \Y = \lam{f}{(\lam{x}{f(xx)})(\lam{x}{f(x x)})}$.
	Тогда
	\[
		\Y F \equiv (\lam{x}{F(x x)})(\lam{x}{F(x x)}) = F(\underbrace{(\lam{x}{F(x x)})(\lam{x}{F(x x)})}_{\Y F} \equiv F(\Y F)
	.\] 
\end{proof}

\subsection{Рекурсия}
$\Y$-комбинатор позволяет ввести рекурсию в  $ \lambda$-исчисление.
Например, можно задать факториал рекурсивно:
\[
	\fac = \lam{n}{\fpif (\iszero n) 1 (\fpmult n (\fac (\pred n)))}
.\] 
Можно переписать:
\[
	\fac = \underbrace{(\lam{f n}{\fpif (\iszero n) 1 (\fpmult n (f (\pred n))))}}_{\fac'} \fac
.\] 
Тогда $ \fac$ --- неподвижная точка для $ \fac'$, поэтому  $ \fac = \Y \fac'$.


\section{Редексы. Одношаговая и многошаговая редукция. Нормальная форма. Редукционные графы.}
Если мы хотим доказать равенство, то эффективным способом будет сокращение всех редексов:
\[
\begin{aligned}
	& KI &&\equiv && \left( \lam{xy}{x} \right) \left( \lam{z}{z} \right) = \lam{yz}{z} \\
	& I I K_{*} &&\equiv && (\lam{x}{x})I K_{*} = IK_{*} = (\lam{x}{x})(\lam{y z}{z}) = \lam{yz}{z}
\end{aligned}
\]
Но как доказать неравенство?
\subsection{Редукция}
\begin{defn}[Совместимое отношение]\index{совместимое отношение}
	Бинарное отношение $ \mathcal{R}$ над $ \Lambda$ называют \mf{совместимым} (с операциями $ \lambda$-исчисления), если для всех $ M, N, Z \in \Lambda$ :
	\[
	\begin{aligned}
		M ~\mathcal{R} ~N && \Rightarrow  && (ZM) ~ \mathcal{R} ~ (ZN), \\
						  &&&& (MZ) ~ \mathcal{R} ~(NZ), \\
						  &&&& (\lam{x}{M}) ~\mathcal{R}~(\lam{x}{N})
	\end{aligned}
	\]
\end{defn}
\begin{defn}
     Совместимое отношение эквивалентности называют \mf{отношением конгруэнтоности} над $ \Lambda$.

	 \noindent
	 Совместимое, рефлексивное и транзитивное отношение называют \mf{отношением редукции} над $ \Lambda$.
\end{defn}

\begin{defn}
	Бинарное отношение \mf{$ \beta $-редукции за один шаг} $ \to_{\beta}$ над $ \Lambda$:
	\[
	\begin{aligned}
		&(\lam{x}{M})N &&\lba&& \subst{x}{N}{M} \\ 
		&M \lba N && \Longrightarrow && ZM \lba ZN \\
		&M \lba N && \Longrightarrow && MZ \lba NZ \\
		&M \lba N && \Longrightarrow && \lam{x}{M} \lba \lam{x}{N} \\
	\end{aligned}
	\]
	Это правило и совместимость.
\end{defn}
\begin{defn}[$ \beta$-редукция]\index{$ \beta $-редукция}    
	Бинарное отношение \mf{$ \beta $-редукции} $ \llba$ над $ \Lambda$ определяется индуктивно:
\begin{align*}
	&M \llba M   \tag{refl} \\
	M \lba N ~\Rightarrow~ &  M \llba N  \tag{ini} \\
	M \llba N, ~ N \llba L ~\Rightarrow ~&  M \llba L  \tag{trans}
\end{align*}
\end{defn}
Это отношение --- транзитивное, рефлексивное замыкание $ \lba$, поэтому является отношением редукции. 

\begin{defn}[Конвертируемость]\index{конвертируемость}
	Бинарное отношение \mf{конвертируемости} $ \eqb$ над $ \Lambda$ определяется индуктивно:
	\begin{align*}
		M \llba N & \Rightarrow  M \eqb N \tag{ini}\\
		M \eqb N & \Rightarrow  N \eqb M \tag{sym}\\
		M \eqb N, ~ N \eqb L & \Rightarrow  M \eqb L \tag{trans}
	\end{align*}
\end{defn}
Это отношение является отношением конгруэнтности.

\begin{st}
    $ M \eqb N \Longleftrightarrow \lambda \vdash M = N$.
\end{st}
\begin{proof}
	Индукция по количеству шагов, расписываем по определению.
\end{proof}
Два терма $ M, N$ связаны отношением $ \eqb$, если есть связывающая цепочка стрелок $ \lba$:
\begin{figure}[ht]
    \centering
    \incfig{beta-equiv}
    \label{fig:beta-equiv}
\end{figure}

\mf{Редукционный граф} для терма $ M \in \Lambda$ (нотация $ G_{\beta}(M)$) --- ориентированный мультиграф с вершинами в $ \{N \mid M \llba N\}$, ребро проводится между $ N$ и $ L$, если  $ N \lba L$.

Отношение $ \beta $-эквивалентности не является разрешимым в общем случае (то есть для пары термов не существует универсального алгоритма, проверяющего эквивалентность).

\subsection{Нормальная форма}\index{нормальная форма}
Это то, что лежит в самом низу на картинке.
\begin{defn}
$ \lambda$-терм $ M$ \textit{находится} в \mf{$ \beta $-нормальной форме} (\bNF), если в нем нет подтермов, являющихся  $ \beta $-редексами.

\noindent
$ \lambda$-терм $ M$ \textit{имеет} $\beta $-нормальную форму, если для некоторого $ N$ выполняется $ M \eqb N$ и $ N$ находится в \bNF.
\end{defn}
\begin{ex}
	~\begin{itemize}
		\item $ \lam{xy}{x(\lam{z}{zx})y}$ находится в \bNF
		\item $ (\lam{x}{xx})y$ не находится в \bNF, но имеет в качестве \bNF терм $ yy$
		\item $ \Omega $ не имеет нормальной формы
    \end{itemize}
\end{ex}


\section{Теорема Чёрча-Россера и ее следствия.}
\begin{thm}[Черч, Россер]\index{теорема Чёрча-Россера}
	Если $ M \llba N$, $ M \llba K$, то существует такой $ L$, что
	$N \llba L$ и $ K \llba L$.
\end{thm}
Иначе говоря, $ \beta $-редукция обладает \textit{свойством ромба} или \textit{конфлюентностью}:

\begin{center}
\begin{tikzcd}%
	&M\arrow[rd, two heads]\arrow[ld, two heads]&\\
	N\arrow[rd, dotted, two heads]&&K\arrow[ld, dotted, two heads]\\
	&L&
\end{tikzcd}
\end{center}
\begin{cor}[о существовании общего редукта]
    Если $ M \eqb N$, то существует $ L$ такой, что $ M \llba L$ и $ N \llba L$.
\end{cor}
\begin{proof}
   Индукция по генерации $ \eqb$. 
   Разберем три случая вывода $ M \eqb N$ :
   \begin{description}
	   \item[$ M \llba N$.] Возьмем $ L = N$. 
	   \item[$ N \eqb M$.] По предположению индукции есть общий  $ \beta$-редукт $ L_1$ для $ N$ и $ M$. Можем взять $ L = L_1$.
	   \item[$ M \eqb N', ~ N' \eqb N$.]  Тогда
\begin{center}
\begin{tikzcd}%
	M\arrow[rd, two heads]&(\text{по ПИ})&N'\arrow[ld, two heads]\arrow[rd, two heads]&(\text{по ПИ})&N\arrow[ld, two heads]\\
						  &L_1\arrow[rd, dotted, two heads]&(CR)&L_2\arrow[ld, dotted, two heads]&\\
						  &&L&&
\end{tikzcd}
\end{center}
   \end{description}
\end{proof}
\begin{cor}[о редуцируемости к \bNF]
    Если $ M$ имеет $ N$ в качестве \bNF, то  $ M \llba N$.
\end{cor}
\begin{cor}[о единственности \bNF]
    $ \lambda$-терм имеет не более одной \bNF.
\end{cor}


\section{Стратегии редукции. Теорема о нормализации. Механизмы вызова в функциональных языках.}
Рассмотрим три варианта терма:
\begin{itemize}
	\item Переменная $ \nu $, редукция завершена, ничего интересного
	\item Абстракция $ \lam{x}{M}$, просто редуцируем $ M$
	\item Аппликация  $ MN$. Разбираем аппликацию влево  (в $ M$) до не-аппликации. Пока получаем аппликацию, разделяем дальше.
		Два варианта остановки:
		\begin{itemize}
			\item Переменная.  Тогда мы получили такой вид
				\[
					(\ldots (( \nu N_1)N_2) \ldots N_k)
				.\] 
				Теперь нам нужно просто проредуцировать каждый $ N_i$, общая структура от этого не изменится. 
			\item Абстракция. Получили:
				\[
					(\ldots (((\lam{x}{M'})N_1)N_2)\ldots N_k)
				.\] 
				Будем работать дальше.
				Здесь есть две стратегии:
				\begin{itemize}
					\item \textbf{Нормальная стратегия}: сразу сокращаем редекс $ (\lam{x}{M})N_1$.
					\item \textbf{Аппликативная стратегия}: сначала редуцируем отдельно все $ N_i$ слева направо до нормальной формы $ N_j'$, а уже потом сокращаем редекс $ (\lam{x}{M})N_1'$.

						Также можно редуцировать только $ N_1$ и сразу сократить.
				\end{itemize}
		\end{itemize}
\end{itemize}
Разбор терма можно представить в виде дерева, где узлы $ @$ задают аппликацию, а узлы $ \lambda$ --- абстракцию.
\begin{thm}
    Лямбда-терм может иметь одну из двух форм:
	\begin{align*}
		&\lam{\vec{x}}{y\vec{N}} &&\equiv&& \lam{x_1 x_2 \ldots x_n }{y N_1, N_2, \ldots N_k}, \quad n,k \ge 0 \tag{HNF} \\
		&\lam{\vec{x}}{(\lam{z}{M})\vec{N}} &&\equiv&& \lam{x_1 x_2 \ldots x_n }{(\lam{z}{M}) N_1, N_2, \ldots N_k}, \quad n \ge 0, k >0 
	\end{align*}
\end{thm}
\begin{defn}\index{головная нормальная форма}
	\mf{Головная нормальная форма} --- форма следующего вида:
	\[
		\lam{\vec{x}}{y\vec{N}} \equiv \lam{x_1 x_2 \ldots x_n }{y N_1, N_2, \ldots N_k}, \quad n,k \ge 0 \tag{HNF}
	.\] 

	\noindent
	\mf{Слабая головная нормальная форма} ($ WHNF$) --- это  $ HFN$ или лямбда-абстракция (то есть не редекс на верхнем уровне). 

	\noindent
	Переменная $ y$ называется \mf{головной переменной}.
	Редекс $ (\lam{z}{M})N_1$ называется \mf{головным редексом}.
\end{defn}
Переменная $ y $ может совпадать с одним из $ x_i$.

В Haskell вычисления как раз форсируются до слабой нормальной формы.
\begin{thm}[о нормализации]
    Если терм $ M$ имеет нормальную форму, то последовательное сокращение самого левого внешнего редекса приводит к этой нормальной форме.
\end{thm}
То есть, если $HNF$ есть, то нормальная стратегия гарантировано приводит к ней.

\subsection{Механизмы вызова в ФЯ}
Аппликативная стратегия более эффективная, хоть и не всегда приводит к $ HNF$, поэтому применяется во многих языках программирования.

Пусть $ N$ --- очень большой терм, который вычисляется сутки.
Если мы запустим нормальную стратегию на 
\[
	(\lam{x}{Fx(Gx)x})N 
,\] 
получим $ FN(GN)N$ и  $ N$ придется в дальнейших редукциях сократить трижды.
Но для такого нормальная стратегия не вычислит $ N$ ни разу:
\[
	(\lam{xy}{y})N \lba \lam{y}{y}
.\] 

Аппликативная стратегия будет вычислять $ N$ только один раз в каждом из примеров.

В ,,ленивых'' языках программирования (Haskell, Clean) используется похожая на нормальную стратегия, а для решения проблем с эффективностью используют механизм \textit{разделения}: вместо непосредственной подстановки терма подставляют указатель на терм, который хранится в памяти как \textit{отложенное вычисление}.

\textbf{Механизм вызова} в функциональных языках:
\begin{itemize}
	\item \textit{вызов по значению} --- аппликативый порядок редукций до $ WHNF$ 
	\item \textit{вызов по имени} --- нормальный порядок редукций до $ WHNT$
	\item \textit{вызов по необходимости} --- ,,вызов по имени'' с разделением.
\end{itemize}


\section{Функция предшествования для чисел Черча. Комбинатор примитивной рекурсии.}
\subsection{Функция предшествования}
Введем вспомогательные функции:
\[
\begin{aligned}
	& \zp && \equiv && \pair 0 0 \\
	& \fpsp && \equiv && \lam{p}{\pair (\snd p) (\fpsucc (\snd p)))}
\end{aligned}
\]
Вторая функция позволяет, приняв пару $ (\_, j)$, вернуть пару  $ (j, j+1)$:
 \[
	 \fpsp(\pair i~ j) = \pair j~ (j+1)
.\] 
Если взять композицию $ m > 0$ раз от $\zp$:
\[
\begin{aligned}
	\fpsp^{0} (\zp) & = \pair 0 0 \\
	\fpsp^{m}(\zp) &= \pair (m-1)~ m
\end{aligned}
\]
Тогда можно определить функцию предшествования:
\[
	\fppred = \lam{m}{\fst (m \, \fpsp \zp)}
.\] 
Тогда 
\[
	\fpminus = \lam{m\,n}{n\, \fppred m}
.\] 

\subsection{Комбинатор примитивной рекурсии}
Обобщим конструкцию. Второй элемент пары оставим счетчиком, а в первом храним результат.
\[
\begin{aligned}
	\fpxz & \equiv \lam{x}{\pair x \, 0} \\
	\fpfs & \equiv \lam {f \, p}{\pair (f (\fst p) (\snd p)) (\succ (\snd p))} \\
	\fprec & \equiv \lam{m\,f\,x}{\fst (m (\fpfs f) (\fpxz x))}
\end{aligned}
\]
Теперь можно выразить $ \fppred$:
 \[
	 \fppred' = \lam{n}{\fprec n\, (K_{*})\, 0}
.\] 
И факториал:
\[
	\fac = \lam{n}{\fprec n \, \left( \lam{x\,y}{\fpmult x (\fpsucc y)} \right) \, 1}
.\] 

\end{document}
