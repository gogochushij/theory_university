\documentclass[11pt,a4paper]{article}
\input{preamble.tex}

\title{Билеты к экзамену по функциональному программированию. Haskell}
\author{Тамарин Вячеслав}

\makeindex

\begin{document}
\maketitle


\section{Основы программирования на Haskell. Связывание. Рекурсия. Базовые конструкции языка.}
% Базовыми ,,строительными кирпичиками'' для выражения служат \textit{Литералы}: символьные ('a', 'X', '\''); строковые ("Hello, world!"); целочисленные (42) и с плавающей точной (3.14159).
% Булевы значение определены через пользовательский тип данных.
\section{Основные встроенные типы языка Haskell. Система модулей. Частичное применение, каррирование.}


\section{Операторы и их сечения в Haskell. Бесточечный тип.}


\section{Ошибки. Основание. Строгие и нестрогие функции. Ленивое и энергичное исполнение.}
\subsection{Ошибки}
Специальное обозначение ошибки исполнения: $ \bot$ --- основание, дно, bottom. Библиотечная константа \mintinline{haskell}|undefined| --- пример реализации $\bot$. Другая реализация:
\begin{hscode}
bot = 1 + bot
fortyTwos = 42 : fortyTwos
\end{hscode}
Это пример продуктивной расходимости --- \mintinline{haskell}|take 5 fortyTwos|.

Теперь мы можем написать более ,,аккуратную'' версию факториала
\begin{hscode}
factorial n =
	if n < 0
	then error "factorial: negative argument"
	else if n > 1
		then n * factorial (n-1)
		else 1
\end{hscode}
Использованная здесь библиотечная функция \mintinline{haskell}|error| --- это гибкая версия \mintinline{haskell}|undefined| с настраеваемым сообщением об ошибке:
\begin{minted}{c}
GHCi> factorial (-3)
*** Exception: factorial: negative argument
\end{minted}
Тип \mintinline{haskell}|Bool| будет иметь три значения: \mintinline{haskell}|True, False, undefined|, так как вычисление могло не завершится.
\begin{hscode}
\bot :: forall {a}. a
\end{hscode}

\subsection{Строгость функций}
Haskell гарантирует вызов по необходимости, если мы запустим функцию, игнорирующую аргумент даже с расходимостью, то получим ответ. Функции, игнорирующие значение своего аргумента, называются \textit{нестрогими} по этому аргументу.

Для \textit{строгих} функций всегда результатом расходимости будет расходимость.

Небольшой неэффективностью ленивого вычисления является удержание всех незавершенных вычислений через указатели. Компилятор борется с этим с помощью анализатора строгости -- если вычисления гарантировано строгие, он снимает нестрогость.

Другая неэффективность --- нарастание отложенных вычислений (thunk). Чтобы форсировать вычисление можно использовать следующую функцию:
\begin{hscode}
seq :: a -> b -> b
seq :: \bot b =  \bot
seq a b = b, если a != \bot
\end{hscode}
Форсирование происходит до слабой головной нормальной формы, то есть до барьера распространения $ \bot$: конструктор данных, лямбда-абстрацкия, частично примененная функция.
\begin{hscode}
GHCi> seq (undefined, undefined) 42
42
GHCi> seq (\x -> undefined) 42
42
GHCi> seq ((+) undefined) 42
42
\end{hscode}
Через \mintinline{haskell}|seq| определяется энергичная аппликация
(с вызовом-по-значению):
\begin{hscode}
infixr 0 $!
($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x
\end{hscode}
Форсирование приводит к ,,худшей определенности''
\begin{hscode}
GHCi> ignore undefined
42
GHCi> ignore $! undefined
*** Exception: Prelude.undefined
\end{hscode}
Пример использования \mintinline{haskell}|seq|:
вспомним факториал c аккумулирующим параметром
\begin{hscode}
factorial n = helper 1 n where
  helper acc k | k > 1 = helper (acc * k) (k - 1)
               | otherwise = acc
\end{hscode}
Из-за ленивости \mintinline{haskell}|acc| будет содержать thunk вида
$$(...((1 * n) * (n - 1)) * (n - 2) * ... * 2)$$

Оптимизатор GHC обычно справляется, имея встроенный
анализатор строгости. Но можно, не полагаясь на него,
написать
\begin{hscode}
factorial n = helper 1 n where
  helper acc k | k > 1 = (helper $! acc * k) (k - 1)
               | otherwise = acc
\end{hscode}


\section{Алгебраические типы данных. Сопоставление с образцом, его семантика.}
Из базовых кирпичиков типов можно строить новые с помощью суммы, произведения и возведения в степень.							

\subsection{Сопоставление с образцом}
Пусть мы хотим поменять местами два элемента в паре:
\begin{hscode}
swap :: (a, b) -> (b, a)
swap :: (x, y) = (y, x)
\end{hscode}
Здесь конструкция \mintinline{haskell}|(x, y)| представляет собой \mf{образец}.
\begin{hscode}
GHCi> swap (5 + 2, True)
(True, 7)
\end{hscode}
При вызове функции происходит \mf{сопоставление с  образцом}:
\begin{itemize}
	\item проверяется, что конструктор \hs{(, )} подходящий
	\item переменные \hs{x} и \hs{y} связываются с выражениями \hs{5 + 2} и \hs{True}
	\item осуществляется подстановка вместо переменных в теле функции \hs{swap}
\end{itemize}

\subsection{Тип суммы}
\mf{Перечисление} --- тип с 0-арными конструкторами данных:
\begin{hscode}
data CardinalDirection = North | East | South | West deriving Show
\end{hscode}
Конструкторы данных имеют тип \hs{CardinalDirection}:
\begin{hscode}
GHCi> dir = North
GHCi> :t dir
dir :: CardinalDirection
\end{hscode}
Сопоставление с образцом происходит сверху вниз
\begin{hscode}
hasPole :: CardinalDirection -> Bool
hasPole North = True
hasPole South = True
hasPole _ = False
\end{hscode}
Подчеркивание (или переменная) задают неопровержимый
образец.
\begin{hscode}
GHCi> hasPole North
True
GHCi> hasPole West
False
\end{hscode}
Встроенные типы данных (\hs{Char, Int, Integer}) ведут себя так, как будто определены как перечисления, поэтому можно использовать литералы как образцы.

\subsection{Декартово произведение}
Тип-произведение с одним конструктором данных
\begin{hscode}
data PointDouble = PtD Double Double
deriving Show

GHCi> :type PtD
PtD :: Double -> Double -> PointDouble

midPointDouble :: PointDouble -> PointDouble
-> PointDouble
midPointDouble (PtD x1 y1) (PtD x2 y2) =
PtD ((x1 + x2) / 2) ((y1 + y2) / 2)

GHCi> midPointDouble (PtD 3.0 5.0) (PtD 9.0 8.0)
PtD 6.0 6.5
\end{hscode}
Можно параметризовывать типовым параметром:
\begin{hscode}
data Point a = Pt a a
deriving Show

GHCi> :type Pt
Pt :: a -> a -> Point a
\end{hscode}
\hs{Point} --- оператор над типами, конкретный тип получается его аппликацией к некоторому типу, например, \hs{Int}.
\begin{hscode}
GHCi> :kind Point
Point :: * -> *

GHCi> :kind Point Int
Int :: *
\end{hscode}
\mf{Кайнды} --- система типов над системой типов Haskell.
\subsection{Экспоненциальные типы}
\mf{Экспоненциальный} тип --- это тип функции.
\begin{hscode}
data Endom a = Endom (a -> a)
appEndom :: Endom a -> a -> a
appEndom (Endom f) = f

GHCi> e = Endom (\n -> 2 * n + 3)
GHCi> :t e
e :: Num a => Endom a
GHCi> :t appEndom e
appEndom e :: Num a => a -> a
GHCi> e `appEndom` 5
13
\end{hscode}
\subsection{Рекурсивные типы}
При объявлении типов можно использовать рекурсию. Это значит, что допустимо указывать объявляемый тип в качестве аргумента конструктора данных:
\begin{hscode}
GHCi> data Nat = Zero | Suc Nat deriving Show
\end{hscode}
Конструктор \hs{Suc} при этом оказывается эндоморфизмом над типом \hs{Nat}
\begin{hscode}
GHCi> :t Zero
Zero :: Nat
GHCi> :t Suc
Suc :: Nat -> Nat
\end{hscode}
Это позволяет строить неограниченное число обитателей данного типа:
\begin{hscode}
GHCi> one = Suc Zero
GHCi> two = Suc (Suc Zero)
GHCi> three = Suc two
GHCi> four = Suc three
\end{hscode}
Это так называемые числа Пеано. Их можно рассматривать как способ кодирования натуральных чисел в унарной системе исчисления. Поскольку тип \hs{Nat} это тип суммы, тотальные функции над ним, использующие опровержимые образцы, определяются
несколькими равенствами
\begin{hscode}
GHCi> {pred (Suc n) = n; pred Zero = Zero}
GHCi> pred two
Suc Zero
\end{hscode}

\subsection{Стандартные алгебраические типы}
\begin{itemize}
\item Тип \hs{Maybe a} позволяет задать ,,необязательное'' значение
\begin{hscode}
data Maybe a = Nothing | Just a
maybe :: b -> (a -> b) -> Maybe a -> b
find :: (a -> Bool) -> [a] -> Maybe a
\end{hscode}
\item Тип \hs{Either a b} описывает одно значение из двух
\begin{hscode}
data Either a b = Left a | Right b
either :: (a -> c) -> (b -> c) -> Either a b -> c

head' :: [a] -> Either String a
head' (x:_) = Right x
head' [] = Left "head': empty list"
\end{hscode}
\end{itemize}

\subsection{Сопоставление с образцом}
Сопоставление происходит сверху вниз, затем слева направо.
Сопоставление бывает
\begin{itemize}
	\item
успешным (succeed);
\item 
неудачным (fail);
\item
расходящимся (diverge).
\end{itemize}
\begin{hscode}
bar (1, 2) = 3
bar (0, _) = 5
\end{hscode}
\begin{itemize}[noitemsep]
	\item(0, 7) --- неудача в первом, успех во втором;
	\item(2, 1) --- две неудачи и, как следствие, расходимость;
	\item(1, 5-3) --- успех, так как для сопоставления нужно приходится форсировать
	\item(1, undefined) --- расходимость, так как форсируем undefined 
	\item(0, undefined) --- неудача на первом, успех на втором
\end{itemize}


\section{Объявления \texttt{type, newtype}. Метки полей.}


\section{Списки, стандартные функции работы с ними. Генерация (выделение) списков.}
Списки встроены, но мы можем определить их сами:
\begin{hscode}
data [] a = [] | a : ([] a)
infixr 5 :
\end{hscode}
Для удобства введён синтаксический сахар
\begin{hscode}
[1,2,3] = 1:(2:(3:[])) = 1:2:3:[]
\end{hscode}
\subsection{Стандартные функции из \hs{Data.List}}

\begin{hscode}
head :: [a] -> a
head (x:_) = x
head [] = error "Prelude.head: empty list"

tail :: [a] -> [a]
tail (x:xs) = xs
tail [] = error "Prelude.tail: empty list"
\end{hscode}
Это частичная функция, в современном Haskell использовать
их не рекомендуется.

Еще одним важнейшим оператором для списков служит оператор бинарной конкатенации: он делает из двух списков один, присоединяя первый к началу второго.
\begin{hscode}
infixr 5 ++
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : xs ++ ys
\end{hscode}
Из реализации оператора видно, что его сложность (число рекурсивных вызовов до наступления терминирующего условия) линейно зависит от размера первого списка и не зависит от второго.

\begin{hscode}
length :: [a] -> Int

concat :: [[a]] -> [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss

infix 4 `elem`
elem :: (Eq a) => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = x == y || elem x ys
\end{hscode}

Функция, осуществляющая поиск значения с заданным ключом в ассоциативном списке (то есть списке пар ключ-значение)
\begin{hscode}
lookup :: Eq a => a -> [(a,b)] -> Maybe b
lookup _ [] = Nothing
lookup key ((k,v):kvs)
  | key == k = Just v
  | otherwise = lookup key kvs
\end{hscode}

Оператор, возвращающий элемент списка с заданным индексом
\begin{hscode}
infixl 9 !!
(!!) :: [a] -> Int -> a
xs     !! n | n < 0 = error "Prelude.!!: negative index"
[]     !! _         = error "Prelude.!!: index too large"
(x:_)  !! 0         = x
(_:xs) !! n         = xs !! (n-1)
\end{hscode}
Левая ассоциативность позволяет удобно обслуживать вложенные списки:
\begin{hscode}
GHCi> ["Hello","world"] !! 0 !! 1
'e'
GHCi> ["Hello","world"] !! 1 !! 2
'r'
\end{hscode}
\subsubsection{Подсписки}
Функция \hs{take} получает целое число $ n$ и список и возвращает первые $ n$ элементов списка. Если элементов меньше, чем $ n$, возвращается сколько есть. Если $ n$ не положительно, возвращается пустой список.
\begin{hscode}
take :: Int -> [a] -> [a]
take n _ | n <= 0 = []
take _ []         = []
take n (x:xs)     = x : take (n - 1) xs
\end{hscode}

\begin{hscode}
drop :: Int -> [a] -> [a]
drop n xs | n <= 0 = xs
drop _ []          = []
drop n (_:xs)      = drop (n - 1) xs
\end{hscode}

\subsubsection{Функции высших порядков над списками}
В библиотеке \hs{Data.List} много функций высших порядков. У следующих двух функций первый аргумент --- функция типа \hs{a -> Bool}, то есть унарный предикат.
\begin{hscode}
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) 
  | p x = x : filter p xs
  | otherwise = filter p xs

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (x:xs)
  | p x = x : takeWhile p xs
  | otherwise = []
\end{hscode}
У функции высшего порядка map функциональный аргумент — произвольная функция:
\begin{hscode}
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
\end{hscode}

Функция map обрабатывает каждый элемент списка переданной функцией-обработчиком, формируя список результатов той же длины, но, возможно, другого типа.
\subsubsection{Семейства \hs{zip} и \hs{zipWith}}
\begin{hscode}
zip :: [a] -> [b] -> [(a,b)]
zip [] _ = []
zip _ [] = []
zip (a:as) (b:bs) = (a,b) : zip as bs

zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
...

unzip :: [(a,b)] -> ([a],[b])
unzip3 :: [(a,b,c)] -> ([a],[b],[c])
...

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith _ [] _ = []
zipWith _ _ [] = []
zipWith f (a:as) (b:bs) = f a b : zipWith f as bs

zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
...
\end{hscode}
Все перечисленные семейства содержат функции вплоть до 7 аргументов.
\subsubsection{Способы генерации списков}
\begin{hscode}
GHCi> take 2 ones
[1,1]
GHCi> take 4 (numsFrom 3)
[3,4,5,6]

take 2 ones → -- (1)
take 2 (1 : ones) → -- (2)
1 : take (2-1) ones) → -- (3)
1 : take 1 (1 : ones) → -- (4)
1 : 1 : take (1-1) ones) → -- (5)
1 : 1 : take 0 ones) → -- (6)
1 : 1 : []
\end{hscode}

\begin{itemize}
\item (1) сопоставление с образцом форсирует вычисление ones до $WHNF$;
\item (2) подходит последнее уравнение в определении \hs{take}, используем его;
\item (3) сопоставление с образцом форсирует вычисление до $WHNF$ обоих аргументов \hs{take}: первого, чтобы отвергнуть первое из уравнений в определении \hs{take}, второго — чтобы отвергнуть второе;
\item (4) используем последнее уравнение в определении \hs{take};
	\item (5) сопоставление с образцом форсирует вычисление до $WHNF$ первого аргумента \hs{take};
	\item (6) подходит первое уравнение в определении \hs{take}, используем его.
\end{itemize}

\begin{hscode}
GHCi> squares = map (^2) (numsFrom 0)
GHCi> takeWhile (<=100) squares
[0,1,4,9,16,25,36,49,64,81,100]

GHCi> fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
GHCi> take 10 fibs
[0,1,1,2,3,5,8,13,21,34]
\end{hscode}

Для формирования ,,нелинейных'' последовательностей имеется другая техника, носящая название выделение списка (\mf{list comprehension}) 
\begin{hscode}
GHCi> digits = [0..9]
GHCi> [ x^2 | x <- digits ]
[0,1,4,9,16,25,36,49,64,81]
\end{hscode}
Часть справа от вертикальной черты носит название генератора: элементы, связываемые с переменной \hs{x} пробегают по всему списку \hs{digits}. Слева от вертикальной черты находится выражение, в котором можно использовать \hs{x}. 

При наличии нескольких генераторов чаще обновляется тот, что правее:
\begin{hscode}
GHCi> [ [x,y] | x <- "ABC", y <- "de" ]
["Ad","Ae","Bd","Be","Cd","Ce"]
\end{hscode}
Генераторы могут ссылаться на значения из предыдущих генераторов; кроме того можно использовать предикаты над этими значениями для фильтрации результатов.

\subsubsection{Последовательности}
\begin{hscode}
GHCi> [1..10]
[1,2,3,4,5,6,7,8,9,10]
GHCi> [1,3..17]
[1,3,5,7,9,11,13,15,17]

ones = 1 : ones
numsFrom n = n : numsFrom (n + 1)
\end{hscode}

\section{Специальный полиморфизм. Классы типов. Объявление представителей. Классы типов \texttt{Eq, Ord, Enum, Bound}.}
\subsection{Параметрический полиморфизм}
Когда в определение функции входит тип как параметр, и мы вместо него можем подставить любой тип. Например,
\begin{hscode}
id :: a -> a
id x = x

id True     :: Bool
id "Badger" :: [Char]
id id       :: a -> a
\end{hscode}
Этот код универсален: можем использовать любой тип параметра и реализация не зависит от какой-то специфики типа.

Изучим функцию, определяющую принадлежность списку:
\begin{hscode}
elem :: a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = x == y || elem x ys
\end{hscode}
Очевидно, для элементов нужно отношение равенства. Если для встроенных типов сравнение определено, для пользовательских типов тоже можно определить отношение равенства, то для функций все сложнее:
\begin{hscode}
suc :: (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a
suc = \n s z -> n s (s z)

suc' :: (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a
suc' = \n s z -> s (n s z)

suc ?= suc'
\end{hscode}
С точки зрения $ \beta $-эквивалентности это две разные функции в \bNF. За счет использования \hs{forall} передать можно только числа Черча.

Эти функции поточечно равны, но не равны \textit{интенсинонально} (совпали по \bNF). Такие называются \textit{экстенсионально} равными.
Чтобы доказать, что функции равны придется для всех различные рассуждения использовать, поэтому в хаскеле функции несравнимы. 

\subsection{Специальный полиморфизм}
Это вид полиморфизма, противоположный параметрическому: интерфейс полностью общий (полиморфный), но реализация специализирована для конкретных типов. Например, так устроено сложение чисел.

\subsection{Классы типов}
\mf{Класс типов} --- именованный набор имен функций с сигнатурами, параметризованными общим типовыми параметром:
\begin{hscode}
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{hscode}
Имя класса типов задает ограничение, называемое \textit{контекстом}.
\begin{hscode}
(==) :: Eq a => a -> a -> Bool

elem :: Eq a => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = x == y || elem x ys
\end{hscode}
Чтобы сделать тип \textit{представителем класса}, нужно реализовать требуемые функции класса:
\begin{hscode}
instance Eq Bool where
  True  == True  = True
  False == False = True
  _     == _     = False
  x /= y = not (x == y)
\end{hscode}
Тип-представитель может быть полиморфным:
\begin{hscode}
instance Eq a => Eq [a] where
  [] == [] = True
  (x:xs) == (y:ys) = x == y && xs == ys
  _     == _     = False
\end{hscode}
Можно не реализовывать неравенство, оно определено по умолчанию.
Для механической реализации можно использовать \hs{deriving Eq}.

\subsection{Расширение класса}
Класс \hs{Ord} наследует все методы \hs{Eq} и содержит новые методы:
\begin{hscode}
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) , (<=), (>=), (>) :: a -> a -> Bool
  max, min :: a -> a -> a

  compate x y = if x == y then EQ 
                else if x <= y then LT
                else GT

  x < y = case compare x y of {LT -> True; _ -> False}
  x <= y = case compare x y of {GT -> False; _ -> True}
  x > y = case compare x y of {GT -> True; _ -> False}
  x >= y = case compare x y of {LT -> False; _ -> True}
  max x y = if x <= y then y else x
  min x y = if x <= y then x else y

sort :: Ord a => [a] -> [a]
\end{hscode}

Допустимо множественное наследование:
\begin{hscode}
class (Eq a, Show a) => MyClass a where
  ...
\end{hscode}

\subsection{\hs{Enum}, \hs{Bounded}}
\begin{hscode}
class Enum a where 
  succ, pred     :: a -> a
  toEnum         :: Int -> a
  fromEnum       :: a -> Int

  enumFrom       :: a -> [a]            -- [n..]
  enumFromThen   :: a -> a -> [a]       -- [n, n'..]
  enumFromTo     :: a -> a -> [a]       -- [n..m]
  enumFromThenTo :: a -> a -> a -> [a]  -- [n, n'..m]

class Bounded a where
  minBound, maxBound :: a
\end{hscode}
Класс \hs{Integer} потенциально бесконечен в обе стороны, поэтому он является \hs{Enum}, но не является \hs{Bounded}.


\section{Внутренняя реализация классов типов.}
Организована через механизм передачи словарей. Словарь для класса --- запись его методов.
\begin{hscode}
data Eq' a = MkEq { eq, ne :: a -> a -> Bool}
\end{hscode}
Здесь хранится две \textit{функции-селекторы}, они выбирают методы равенства и неравенства из данного словаря.
\begin{hscode}
GHCi> :t eq
eq :: Eq' a -> a -> a -> Bool
GHCi> :i ne
eq :: Eq' a -> a -> a -> Bool
\end{hscode}
Теперь вместо того, что называлось контекстом, теперь просто дополнительный параметр.

Объявления представителей транслируются в функции, возвращающие словарь или в функции, принимающие словарь и возвращающие более сложный словарь:
\begin{hscode}
dEqInt :: Eq' Int
dEqInt = MkEq {
	eq = eqInt, -- это низкоуровневый способ сравнивать Intы
	ne = \x y -> not $ eqInt x y
}

dEqList :: Eq' a -> Eq' [a]
dEqList (MkEq e _) = MkEq el (\x y -> not $ el x y) -- e - словарь для сравнения элементов списка
  where el [] [] = True
        el (x:xs) (y:ys) = x `e` y && xs `el` ys
        el _ _ = False
\end{hscode}
Теперь можем написать \hs{enum'}: он требует, чтобы ему дали словарь для сравнения элементов типа \hs{a} первым аргументом, а остальное аналогично.
\begin{hscode}
elem' :: Eq' a -> a -> [a] -> Bool
elem' _ _ [] = False
elem' d x (y:ys) = eq d x y || elem' d x ys

GHCi> elem' dEqInt 2 [3, 5, 2]
True
GHCi> elem (dEqList dEqInt) [3, 5] [[4], [1, 2, 3], [3, 5]]
True
\end{hscode}


\section{Стандартные классы типов: \texttt{Num} и его наследники, \texttt{Show} и \texttt{Read}.}
\begin{hscode}
class (Eq a, Show a) => Num a where
  (+), (-), (*) :: a -> a -> a
  negate        :: a -> a
  abs, signum   :: a -> a
  fromInteger   :: Integer -> a

  x - y = x + negate y
  negate x = 0 - x
\end{hscode}
\begin{tikzcd}%
	Enum\arrow[ddd] &&& Eq\arrow[ld]\arrow[rd] && Show\arrow[ld] \\
				  && Ord\arrow[ld]\arrow[rd] && Num\arrow[ld]\arrow[d]&\\
				  & Ix && Real\arrow[llld]\arrow[d] & Fractional\arrow[ld]\arrow[rd]& \\
	Integral\arrow[d]\arrow[rd] &&& RealFrac\arrow[rd] && Floating\arrow[ld] \\
	Int & Integer &&& RealFloat\arrow[ld]\arrow[rd] & \\
		&&& Double && Float
\end{tikzcd}

Автоматического приведения типов в Хаскеле нет. Всегда нужно использовать приведение.


\section{Полугруппы и моноиды. Представители класса типов \hs{Semigroup} и \hs{Monoid}.}
\subsection{Полугруппы}
\mf{Полугруппа} --- множество с ассоциативной бинарной операцией над ним.
\begin{hscode}
infixr 6 <>
class Semigroup a where
  (<>) :: a -> a -> a
  sconcat :: NonEmpty a -> a  -- конкатенация, все : заменяем на <>
  stimes :: Integral b => b -> a -> a  -- повторяем b раз и вставляем между копиями <>

infixr 5 :|
data NonEmpty a = a :| [a]  -- произведение a и [a]
\end{hscode}
За счет ассоциативности операции, можно достичь логарифмической трудности операций.
Для любой полугруппы должен выполняться закон:
\begin{hscode}
(x <> y) <> z = x <> (y <> z)
\end{hscode}
Список --- полугруппа относительно конкатенации:
\begin{hscode}
class Semigroup [a] where
  (<>) = (++)
\end{hscode}
Можем использовать в функциях, которые не работают на пустых списках:
\begin{hscode}
GHCi> import Data.List.NonEmpty
GHCi> sconcat $ "AB" :| ["CDE", "FG"]
"ABCDEFG"
GHCi> stimes 5 "Ab"
"AbAbAbAbAb"
\end{hscode}
\subsection{Моноиды}
\mf{Моноид} --- множество с ассоциативной бинарной операцией над ним и нейтральным элементом для этой операции.
\begin{hscode}
class Semigroup a => Monoid a where
  mempty :: a  -- нейтарльный элемент
  mappend :: a -> a -> a  -- операция
  mappend = (<>)
  mconcat :: [a] -> a
  mconcat = foldr mappend mempty
\end{hscode}
Законы:
\begin{hscode}
mempty <> x = x
x <> mempty = x
(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
\end{hscode}
Список --- моноид относительно \hs{(++)}, нейтральный --- пустой список:
\begin{hscode}
instance Semigroup [a] where
  (<>) = (++)
instance Monoid [a] where
  mempty = []
  mconcat = concat
\end{hscode}
Числа тоже моноид, причем четырежды: сложение -- нуль, умножение -- единица, минимум -- \hs{maxBound}, максимум -- \hs{minBound}.
Для разделения этих вариантов при реализации можем обернуть числа в \hs{newtype}-коробочку:
\begin{hscode}
newtype Sum a = Sum { getSum :: a} deriving (Eq, Ord, Read, Show, Bounded)
instance Num a => Semigroup (Sum a) where
  Sum x <> Sum y = Sum (x + y)
instance Num a => Monoid (Sum a) where
  mempty = Sum 0

GHCi> Sum 3 <> Sum 2 
Sum {getSum = 5}
\end{hscode}
\hs{mconcat} --- сумма нескольких чисел, \hs{stimes} --- умножение.

Теперь напишем для умножения, используя \hs{coerce} -- безопасное приведение, если мы имеем два одинаковых рантаймовых представления, то можем привести одно к другому автоматически:
\begin{hscode}
newtype Product a = Product { getProduct :: a} deriving (Eq, Ord, Read, Show, Bounded)
instance Num a => Semigroup (Product a) where
  (<>) = coerce ((*) :: a -> a -> a)  -- Data.Coerce
instance Num a => Monoid (Product a) where
  mempty = Product 1

GHCi> Product 3 <> Product 2 
Product {getProduct = 6}
\end{hscode}
Для использования \hs{coerce}, нужно подключить расширение \hs{ScopedTypeVariables}, чтобы расширить область видимости \hs{a} из типа.

\hs{Integer} не имеет максимума, поэтому, хотя это и полугруппа, моноидом быть не может. Также не существует моноида для строк.

Для решения такой проблемы можем перейти к полугрупповой операции \hs{sconcat} и от списка к  \hs{NoEmpty}:
\begin{hscode}
GHCi> (getMin . sconcat . fromList . fmap Min) ["Hello", "Hi"]
"Hello"
-- вместо
GHCi> (getMin . mconcat . fmap Min) ["Hello", "Hi"]
<interactive>: error: No instance for (Bounded [Char])
\end{hscode}

Булев тип тоже является моноидом относительно конъюнкции и дизъюнкции.
\begin{hscode}
newtype All = All { getAll :: Bool} deriving (Eq, Ord, Read, ShowBounded)
instance Semigroup All where
  (<>) = coerce (&&)
instance Monoid All where
  mempty = All True

newtype Any = Any { getAny :: Bool} deriving (Eq, Ord, Read, ShowBounded)
instance Semigroup Any where
  (<>) = coerce (||)
instance Monoid Any where
  mempty = Any False
\end{hscode}


\section{Свертки списков. Правая и левая свертки. Энергичные версии. Развертки.}
\subsection{Правая свертка}
\begin{hscode}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f ini [] = ini
foldr f ini (x:xs) = x `f` (foldr f ini xs)

p : q : r : []  ======>  p `f` (q `f` (r `f` ini))
\end{hscode}
Примеры  использования:
\begin{hscode}
sum :: [Integer] -> Integer
sum = foldr (+) 0

concat :: [[a]] -> [a]
concat = foldr (++) []

allOdd :: [Integer] -> Bool
allOdd = foldr (\n b -> odd n && b) True

id = foldr (:) []
\end{hscode}
Правые свертки позволяют работать с бесконечными списками.
\subsection{Левая свертка}
\begin{hscode}
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f ini [] = ini
foldl f ini (x:xs) = foldl f (ini `f` x) xs

p : q : r : []  ======>  ((ini `f` p) `f` q) `f` r
\end{hscode}
Здесь хвостовая рекурсия оптимизируется, но нарастает thunk из цепочки вызовов: запустятся вычисления только, когда список кончится, так как форсирования нет (нет \hs{seq} или сопоставления с образцом).

\begin{hscode}
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' f ini [] = ini
foldl' f ini (x:xs) = arg `seq` foldl' f arg xs
                        where arg = f ini x
\end{hscode}
Здесь thunk не нарастает, вычисление \hs{arg} форсируется на каждом шаге, это самая эффективная из сверток, но, как и любая левая свертка, не работает с бесконечным циклом.

\subsection{Версии без начального значения}
\begin{hscode}
foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 _ [x] = x
foldr1 f (x:xs) = f x (foldr1 f xs)
foldr1 _ [] = error "foldr1: EmptyList"
\end{hscode}
\begin{hscode}
foldl1 :: (a -> a -> a) -> [a] -> a
foldl1 f (x:xs) = foldl f x xs
foldl1 _ [] = error "foldl1: EmptyList"
\end{hscode}
Аналогично можно сделать строгую версию \hs{foldl1'}.

 \subsection{Сканы}
Это списки последовательных шагов свертки:
\begin{hscode}
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl _ z [] = [z]
scanl (#) z (x:xs) = z : scanl (#) (z # x) xs

GHCi> scanl (++) "!" ["a", "b", "c"]
["!", "!a", "!ab", "!abc"]
GHCi> scanl (*) 1 [1..] !! 5 -- факториал
120
\end{hscode}
В отличие от \hs{foldl} может работать и с бесконечными списками.

\noindent Правый скан накапливает результаты в обратном порядке:
\begin{hscode}
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr _ z [] = [z]
scanr f z (x:xs) = f x q : qs
                     where qs@(q:_) = scanr f z xs  -- здесь используем псевдоним
\end{hscode}
Тождества для сканов:
\begin{hscode}
head (scanr f z xs) = foldr f z xs
last (scanl f z xs) = foldl f z xs
\end{hscode}
\subsection{Развертка}
Двойственная свертке операция.
\begin{hscode}
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
unfoldr g ini 
  | Nothing     <- next = []
  | Just (a, b) <- next = a : unfoldr g b
  where next = g ini

GHCi> helper x = if x == 0 then Nothing else Just (x, x - 1)
GHCi> unfoldr helper 10
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
\end{hscode}
Пример использования --- возможное определение \hs{iterate}
\begin{hscode}
iterate f = unfoldr (\x -> Just (x, f x))
\end{hscode}


\section{Класс типов \hs{Foldable} и его представители.}
Идея: обобщить свертки на более общий тип, то есть  заменить скобки на букву.
\begin{hscode}
class Foldable t where
  fold :: Monoid m => t m -> m
  fold = foldMap id

  foldMap :: Monoid m => (a -> m) -> t a -> m
  foldMap f = foldr (mappend . f) mempty

  foldr, foldr' :: (a -> b -> b) -> b -> t a -> b
  foldr f z t = appEndo (foldMap (Endo . f) t) z

  foldl, foldl' :: (b -> a -> b) -> a -> t b -> a
  foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z

  foldr1, foldl1 :: (a -> a -> a) -> t a -> a
\end{hscode}
Минимальное определение \hs{foldMap} или  \hs{foldr}.
Изучим  полезные функции:
\begin{hscode}
class Foldable t where
  toList :: t a -> [a]

  null :: t a -> Bool
  null = foldr (\_ _ -> False) True

  lenght :: t a -> Int
  length = foldl' (\c _ -> c + 1) 0

  elem :: Eq a => a -> t a -> Bool
  elem x = foldr f False
             where f result elem = result || x == elem 
  
  maximum, minimum :: Ord a => t a -> a

  sum, product :: Num a => t a -> a
  sum = getSum . foldMap Sum
\end{hscode}
\subsection{Представители}
\begin{hscode}
instance Foldable [] where
  foldr = Prelude.foldr
  foldl = Prelude.foldl
  foldr1 = Prelude.foldr1
  foldl1 = Prelude.foldl1

instance Foldable Maybe where
  foldr _ z Nothing = z
  foldr f z (Just x) = f x z
\end{hscode}
Еще много контейнеров: \mf{Set, Map, Tree, Seq}. Также \hs{Either, Pair}. Чтобы объявить представителя двухпараметрического типа, первый параметр нужно связать.
\begin{hscode}
GHCi> foldr (+) 5 (Right 37)
42
GHCi> foldr (+) 5 (Left 37)
5
GHCi> foldr (+) 5 ("Answer", 37)
42

GHCi> maximum (Right 37)
37
GHCi> maximum (Left 37)
*** Exception: maximum: empty structure
GHCi> maximum (100, 42)
42
\end{hscode}
Реализация:
\begin{hscode}
foldr f z t = appEndo (foldMap (Endo . f) t ) z
foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
fold        = foldMap id
length      = getSum . foldMap (Sum . const 1)
sum         = getSum . foldMap Sum
product     = getProduct . foldMap Product
minimum     = getMin . foldMap Min
maximum     = getMax . foldMap Max
foldr f z   = foldr f z . toList
foldl f z   = foldl f z . toList 
\end{hscode}

Другие моноиды: \hs{Ordering, SortedList, a -> b}.
\begin{hscode}
newtype Endo a = Endo { appEndo :: a -> a }
instance Semigroup (Endo a) where
  Endo f <> Endo g = Endo $ f . g
instance Monoid (Endo a) where
  mempty = Endo id

newtype Dual a = Dual { getDual :: a}  -- разворачивает агрументы
instance Semigroup a => Semigroup (Dual a) where
  Dual a <> Dual b = Dual (b <> a)
instance Monoid a => Monoid (Dual a) where
  mempty = Dual mempty
\end{hscode}


\section{Класс типов \hs{Functor} и его представители.}
Функтор определятся следующим образом: 
\begin{hscode}
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)
  (<$) :: a -> f b -> f a  -- стрелка направлена в ту сторону, откуда берется значение
  (<$) = fmap . const

(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$>) fmap

($>) :: Functor f => f a -> b -> f b
($>) = flip (<$)

void :: Functor f => f a -> f ()  -- это unittype, ровно одно значение
void x = () <$ x

infixl 1 <&>
(<&>) :: Functor f => f a -> (a -> b) -> f b
xs <&> f = f <&> xs
\end{hscode}
Представители этого класса должны быть конструкторами типа с одним параметром: \hs{f :: * -> *}.
\begin{hscode}
instance Functor [] where
  fmap _ [] = []
  fmap g (x:xs) = g x : fmap g xs

instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap g (Just a) - Just (g a)

data Tree a = Leaf | Branch (Tree a) a (Tree a)
instance Functor Tree where
  fmap :: (a -> b) -> Tree a -> Tree b
  fmap g (Leaf x) = Leaf (g x)
  fmap g (Branch l x r) = Branch (fmap g l) (g x) (fmap g r)
\end{hscode}
Структурно ничего не меняется после применения \hs{fmap}, \mintinline{haskell}|<$>| --- инфиксный аналог.

Расширение \hs{InstanceSigs} позволяет указывать сигнатуры методов в представителе класса типов.

Представители для двухпараметрических типов: так как \hs{Either, (,), (->) :: * -> * -> *} мы должны связать первый параметр.
\begin{hscode}
instance Functor (Either e) where
  fmap :: (a -> b) -> Either e a -> Either e b
  fmap _ (Left x) = Left x
  fmap g (Right y) = Right (g y)

instance Functor ((,) s) where
  fmap :: (a -> b) -> (s, a) -> (s, b)
  fmap g (x, y) = (x, g y)

instance Functor ((->) e) where
  fmap :: (a -> b) -> ((->) e a) -> ((->) e b)
  fmap = (.)
\end{hscode}
\subsection{Законы}
Вообще, в Хаскеле из первого следует второй закон.
\begin{hscode}
fmap id = id
fmap (f . g) = fmap f . fmap g
\end{hscode}
Смысл законов --- сохраняем структуру контейнера, воздействуя только на элементы.
Всегда нужно следить за соблюдением законов, например, есть такой нарушитель:
\begin{hscode}
instance Functor [] where
  fmap _ [] = []
  fmap g (x:xs) = g x : g x : fmap g xs
\end{hscode}
\subsection{Не-функторы}
Единственная реализация не удовлетворяет первому закону:
\begin{hscode}
instance Functor Endo where
  fmap :: (a -> b) -> Endo a -> Endo b
  fmap _ (Endo _) = Endo id
\end{hscode}
Вообще не допускает реализации:
\begin{hscode}
newtype RevArr c a = RevArr { appRevArr :: a -> c }
\end{hscode}


\section{Класс типов \hs{Applicative} и его представители}
Хотим вынуть стрелку из контейнера.
\begin{hscode}
class Functor f => Applicative f where
  {-# Minimal pure, ((<*>) | liftA2) #-}
  pure :: a -> f a

  (<*>) :: f (a -> b) -> f a -> f b
  (<*>) = liftA2 id

  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  liftA2 g a b = g <$> a <*> b

  (*>) :: f a -> f b -> fb
  a1 *> a2 = (id <$ a1) <*> a2

  (<*) :: f a -> f b -> f a
  (<*) = liftA2 const

infixl 4 <*>, *>, <*, <**>
\end{hscode}
\hs{pure} --- чистая упаковка, вложение без эффекта.

Вспомогательные функции из \hs{Control.Applicative} 
\begin{hscode}
liftA :: Applicatice f => (a -> b) -> f a -> f b
liftA f a = pure f <*> a

liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 g a b c = g <$> a <*> b <*> c

(<**>) :: Applicative f => f a -> f (a -> b) -> f b
(<**>) = liftA2 (&)
\end{hscode}

\subsection{Законы}
\begin{itemize}
	\item Закон, связывающий \hs{Applicative} и \hs{Functor}: \hs{fmap g xs =  pure g <*> xs}
	\item Identity: \hs{pure id <*> v = v}
	\item Homomorphism: \hs{pure g <*> pure x = pure (g x)}
	\item Interchange: \mintinline{haskell}|u <*> pure x = pure ($ x) <*> u|
	\item Composition: \hs{pure (.) <*> u <*> x = u <*> (v <*> x)}
\end{itemize}


\subsection{Представители}
Контекст с возможно отсутствующим значением (примитивная обработка ошибок):
\begin{hscode}
instance Applicative Maybe where
  pure = Just
  Nothing <*> _ = Nothing
  (Just g) <*> x = fmap g x

GHCi> Just (+2) <*> Just 5
Just 7
GHCi> Just (+2) <*> Nothing
Nothing
GHCi> Just (+) <*> Just 2 <*> Just 5
Just 7
\end{hscode}
Для списков есть две семантики \hs{fs <*> xs}: либо каждый с каждым (множественные результаты недетерминированного вычисления), либо \hs{zip} (коллекция упорядоченных элементов).
Список определен только для первой, так как одна расширяется до \hs{Monad}.
\begin{hscode}
instance Applicative [] where
  pure x = [x]
  gs <*> xs = [ g x | g <- gs, x <- xs ]

newtype ZipList a = ZipList { getZipList :: [a] }

instance Functor Ziplist where
  fmap f (ZipList xs) = ZipList (map f xs)
instance Applicative ZipList where
  pure x = x : pure x  -- или repeat x из Data.List
  ZipList gs <*> ZipList xs = ZipList (zipWith ($) gs xs)
\end{hscode}
Для пары выполняется семантика логгирования:
\begin{hscode}
instance Monoid s => Applicative ((,), s) where
  pure x = (mempty, x)
  (u, f) <*> (v, x) = (u <> v, f x)

GHCi> ("Answer to ", (*)) <*> ("the Ultimate ", 6) <*> ("Question ", 7)
("Answer to the Ultimate Question ", 42)
\end{hscode}


\section{Классы типов \hs{Alternative, MonadPlus} и их представители.}
\subsection{\hs{Alternative}}
\begin{hscode}
class Applicative f => Alternative f where
	empty :: f a
	(<|>) :: f a -> f a -> f a
infixl 3 <|>
\end{hscode}
Мы наделяем аппликативный функтор дополнительной моноидальной операцией с семантикой  сложения:
\begin{hscode}
instance Alternative [] where
	empty :: [a]
	empty = []
	(<|>) :: [a] -> [a] -> [a]
	(<|>) = (++)
\end{hscode}
\begin{hscode}
instance Alternative Maybe where
	empty :: Maybe a
	empty = Nothing
	
	(<|>) :: Maybe a -> Maybe a -> Maybe a
	Nothing <|> m = m
	m <|> _ = m

	some, many :: f a -> f [a]
	some v = (:) <$> v <*> many v  -- One or more
	many v = some v <|> pure []  -- Zero or more

optional :: Alternative f => f a -> f (Maybe a)
optional v = Just <$> v <|> pure Nothing
\end{hscode}
Представитель \hs{Alternative} для \hs{Maybe} ведет себя, как упаковка \hs{First}, возвращая первый не-\hs{Nothing} в цепочке альтернатив:
\begin{hscode}
GHCi> Nothing <|> (Just 3) <|> (Just 5) <|> Nothing
Just 3
\end{hscode}
Интерфейс для парсера
\begin{hscode}
instance Alternative (Parser tok) where
	empty :: Parser tok a
	empty = Parser $ \_ -> Nothing

	(<|>) :: Parser tok a -> Parser tok a -> Parser tok a
	Parser u <|> Parser v = Parser f where
		f xs = case u xs of
			Nothing -> v xs
			z -> z
\end{hscode}
СЕМАНТИКА:
\hs{empty} --- парсер, всегда возвращающий неудачу;
\hs{(<|>)} --- пробуем первый, при неудаче пробуем второй на исходной строке.

Рекурсивный парсер
\begin{hscode}
lowers :: Parser Char String
lowers = (:) <$> lower <*> lowers <|> pure ""

GHCi> runParser lowers "abCd"
Just ("Cd","ab")
GHCi> runParser lowers "abcd"
Just ("","abcd")
GHCi> runParser lowers "Abcd"
Just ("Abcd","")
\end{hscode}

\subsection{\hs{MonadPlus}}
Расширение дополнительной моноидальной операцией. Очень похоже на \hs{Alternative}.
\begin{hscode}
class (Alternative m, Monad m) => MonadPlus m where
	mzero :: m a
	mzero = empty
	mplus :: m a -> m a -> m a
	mplus = (<|>)
\end{hscode}
Минимальное полное определение: ничего не делать.
\begin{hscode}
instance MonadPlus Maybe
instance Alternative [] where
	empty = []
	(<|>) = (++)

instance MonadPlus []
\end{hscode}
\subsubsection{Законы}
Помимо ,,унаследованных'' законов требуют выполнения (Left and Right Zero)
\begin{hscode}
mzero >>= k = mzero
v >> mzero = mzero
\end{hscode}
и по крайней мере одного из двух (Left Distribution, Left Catch law)
\begin{hscode}
(a `mplus` b) >>= k = (a >>= k) `mplus` (b >>= k)
return a `mplus` b = return a
\end{hscode}
\subsubsection{Использование}
\begin{hscode}
-- Haskell 2010 :: MonadPlus m => Bool -> m ()
guard :: Alternative f => Bool -> f ()
guard True = pure ()
guard False = empty

pythags = do
	z <- [1..]
	x <- [1..z]
	y <- [x..z]
	guard (x^2 + y^2 == z^2)
	return (x, y, z)

GHCi> take 5 pythags
[(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]

asum :: (Foldable t, Alternative f) => t (f a) -> f a
asum = foldr (<|>) empty

msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
msum = asum  -- foldr mplus mzero

mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
mfilter p ma = do
	a <- ma
	if p a
	then return a
	else mzero
\end{hscode}



\section{Аппликативные парсеры}
\begin{defn}
	\mf{Парсер} --- программа, принимающая на вход строку и возвращающая некоторую структуру данных, если строка удовлетворяет заданной грамматике, или сообщение об ошибке в противном случае.
\end{defn}
Различные парсеры:
\begin{itemize}
	\item Простой, но неудобный: \hs{type Parser a = String -> a}
	\item Храним неразобранный остаток: \hs{type Parser a = String -> (String, a)}
	\item Обрабатываем ошибки: \hs{type Parser a = String -> Maybe (String, a)} или 

		\hs{type Parser a = String -> Either String (String, a)}
	\item Разбираем неоднозначные грамматики: \hs{type Parser a = String -> [(String, a)]}
\end{itemize}
Выберем третий вариант. Также существует обобщение на список токенов, который мы обрабатываем вместо строки, если перед этим мы разбили текст на лексемы / токены.
\begin{hscode}
newtype Parser tok a = Parser { runParser :: [tok] -> Maybe ([tok], a) }
\end{hscode}
Можно написать простой парсер, распознающий строку, начинающуюся с символа \hs{'A'}:
\begin{hscode}
charA :: Parser Char Char
charA = Parser f where
  f (c:cs) | c == 'A' = Just (cs, c)
  f _ = Nothing

GHCi> runParser charA "ABC"
Just ("BC", 'A')
\end{hscode}
Напишем более общую функцию, которая разбирает токен, если он удовлетворяет предикату, а иначе выдает ошибку:
\begin{hscode}
satisfy :: (tok -> Bool) -> Parser tok tok
satisfy pr = Parser f where
	f (c:cs) | pr c = Just (cs,c)
	f _ = Nothing

GHCi> runParser (satisfy isUpper) "ABC"  -- можно использовать функции из Data.Char, Data.Punctuation 
Just ("BC",'A')
GHCi> runParser (satisfy isLower) "ABC"
Nothing

lower :: Parser Char Char
lower = satisfy isLower
char :: Char -> Parser Char Char
char c = satisfy (== c) 
\end{hscode}
Чтобы поменять тип возвращаемого значения, например, возвращать цифру, а не символ, нужно сделать парсер функтором:
\begin{hscode}
digit :: Parser Char Int
digit = digitToInt <$> satisfy isDigit

instance Functor (Parser tok) where
	fmap :: (a -> b) -> Parser tok a -> Parser tok b
	fmap g (Parser p) = Parser f where
		f xs = case p xs of
			Just (cs, c) -> Just (cs, g c)
			Nothing -> Nothing
\end{hscode}
Можно сделать это компактнее, так как \hs{Parser} --- композиция трех функторов \hs{(->) [tok]}, \hs{Maybe}, \hs{(,) [tok]}:
\begin{hscode}
newtype Parser tok a = Parser { runParser :: [tok] -> Maybe ([tok], a) }

instance Functor (Parser tok) where
  fmap :: (a -> b) -> Parser tok -> Parser tok b
  fmap g (Parser p) = Parser $ (fmap . fmap . fmap) g p
\end{hscode}
Основной эффект парсера состоит в том, что мы постепенно едем по строке и отжираем от нее кусочки.

Семантика \hs{pure} --- ничего не откусить, семантика \hs{<*>} --- получить результат первого парсера, затем второго на остатке и применить первый ко второму.

Тогда можем сделать парсер аппликативным:
\begin{hscode}
instance Applicative (Parser tok) where
	pure :: a -> Parser tok a
	pure x = Parser $ \s -> Just (s, x)

	(<*>) :: Parser tok (a -> b) -> Parser tok a -> Parser tok b
	Parser u <*> Parser v = Parser f where
		f xs = case u xs of
			Nothing -> Nothing
			Just (xs', g) -> case v xs' of
				Nothing -> Nothing
				Just (xs'', x) -> Just (xs'', g x)

GHCi> runParser (pure 42) "ABCD"
Just ("ABCD",42)
GHCi> runParser (pure (,) <*> digit <*> digit) "12AB"
Just ("AB",(1,2))
GHCi> runParser ((,) <$> digit <*> digit) "1AB2"
Nothing
\end{hscode}
Постоим  парсер, который перемножает два числа:
\begin{hscode}
multiplication :: Parser Char Int
multiplication = (*) <$> digit <* char '*' <*> digit  -- <* говорит, что резуьтат звездочки просто игнорируем

GHCi> runParser multiplication "6*7"
Just ("",42)
\end{hscode}


\section{Класс типов \hs{Traversable} и его представители.}
Пусть есть список с аппликативными функторами, а мы хотим вытащить функтор наружу:
\begin{hscode}
dist :: Applicative f => [f a] -> f [a]
dist [] = pure []
dist (ax:axs) = pure (:) <*> ax <*> dist axs

GHCi> dist [Just 3,Just 5]
Just [3,5]
GHCi> dist [Just 3,Nothing]
Nothing
GHCi> getZipList $ dist $ map ZipList [[1,2],[3,4],[5,6]]
[[1,3,5],[2,4,6]]
\end{hscode}
Использование в теле определения dist тех же самых
конструкторов, что и в образцах, приводит к сохранению
трехэлементной структуры списка.

Обобщим до любого однопараматрического типа.
\begin{hscode}
class (Functor t, Foldable t) => Traversable t where
	sequenceA :: Applicative f => t (f a) -> f (t a)
	sequenceA = traverse id
	traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
	traverse g = sequenceA . fmap g
\end{hscode}
Минимальное определение: \hs{traverse} или \hs{sequenceA}.
\begin{itemize}
	\item \hs{sequenceA}: обеспечиваем правило коммутации нашего функтора \hs{t} с произвольным аппликативным функтором \hs{f}.

		Структура внешнего контейнера \hs{t} сохраняется, а аппликативные эффекты внутренних \hs{f} объединяются в результирующем \hs{f}.
	\item 
		\hs{traverse} --- это \hs{fmap} с эффектами: проезжаем по структуре \hs{t a}, последовательно применяя функцию к элементам типа \hs{a} и монтируем в точности ту же структуру из результатов типа \hs{b}, параллельно ,,коллекционируя'' эффекты.
\end{itemize}
Если реализовать \hs{Traversable}, то он будет и функтором и \hs{Foldable}.
\subsection{Представители}
\begin{hscode}
instance Traversable Maybe where
	traverse :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
	traverse _ Nothing = pure Nothing
	traverse g (Just x) = Just <$> g x

instance Traversable [] where
	traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
	traverse _ [] = pure []
	traverse g (x:xs) = (:) <$> g x <*> traverse g xs
\end{hscode}
Можно заметить, что с функтором очень схожий код, просто все происходит поднятым на уровень выше.

\subsection{Законы}
\begin{hscode}
newtype Identity a = Identity { runIdentity :: a }

instance Functor Identity where
	fmap g (Identity x) = Identity (g x)

instance Applicative Identity where
	pure = Identity
	Identity g <*> v = fmap g v
\end{hscode}
Первый закон (Identity):
\begin{hscode}
traverse Identity = Identity

GHCi> traverse Identity [1,2,3]
Identity [1,2,3]
\end{hscode}
Всякий \hs{Traversable} --- это \hs{Functor}: имея \hs{traverse} мы можем универсальным образом реализовать \hs{fmap}, удовлетворяющий законам функтора.
\begin{hscode}
fmapDefault :: Traversable t => (a -> b) -> t a -> t b
fmapDefault g = runIdentity . traverse (Identity . g)
\end{hscode}

\begin{hscode}
Identity :: b -> Identity b
(Identity . g) :: a -> Identity b
traverse (Identity . g) :: Identity (t b)
runIdentity . traverse (Identity . g) :: t b
\end{hscode}
Второй закон (Composition):
\begin{hscode}
traverse (Compose . fmap f2 . f1) = Compose . fmap (traverse f2) . traverse f1
\end{hscode}
Здесь обе части имеют тип \hs{t a -> Compose g2 g1 (t с)} в предположении, что \hs{f1 :: a -> g1 b} и \hs{f2 :: b -> g2 c}.

Третий закон (Naturality):
\begin{hscode}
h . traverse f = traverse (h . f)
\end{hscode}
Здесь \hs{h :: (Applicative f, Applicative g) => f b -> g b} -- произвольный аппликативный гомоморфизм, то есть функция удовлетворяющая требованиям:
\begin{itemize}
	\item \hs{h (pure x) = pure x};
	\item \hs{h (x <*> y) = h x <*> h y}.
\end{itemize}
В предположении, что \hs{f :: a -> f b}, обе части имеют тип \hs{t a -> g (t b)}.
\subsection{Практический смысл законов}
Законы \hs{Traversable} дают следующие гарантии:
\begin{itemize}
	\item Траверсы не пропускают элементов.
	\item Траверсы посещают элементы не более одного раза. 
	\item \hs{traverse pure} дает \hs{pure}.
	\item Траверсы не изменяют исходную структуру --- она либо сохраняется, либо полностью исчезает.
\end{itemize}
\begin{hscode}
GHCi> traverse Just [1,2,3]
Just [1,2,3]
GHCi> traverse (const Nothing) [1,2,3]
Nothing
\end{hscode}


\section{Монады. Класс типов \hs{Monad}. Законы для монад \hs{do}-нотация.}
\subsection{Эффект}
Хотим вместо простой чистой функции повесить на результат некоторый контекст.
\begin{itemize}
	\item иногда могут завершиться неудачей: \hs{a -> Maybe b}
	\item могут возвращать много результатов: \hs{a -> [b]}
	\item иногда могут завершиться ошибкой: \hs{a -> (Either s) b}
	\item могут делать записи в лог: \hs{a -> (s, b)}
	\item могут читать из внешнего окружения: \hs{a -> ((->) e) b}
	\item работают с мутабельным состоянием: \hs{a -> (State s) b}
	\item делают ввод/вывод (файлы, консоль): \hs{a -> IO b}
	\item не делают ничего: \hs{a -> Identity b}
\end{itemize}
Обобщая, получим \mf{стрелку Клейсли}: \hs{a -> m b}. Она обобщает зависимость \textit{эффекта от значения}.

На оператор над типами накладываются требования:
\begin{itemize}
	\item Должен иметься универсальный интерфейс для упаковки значения в контейнер \hs{m}
	\item Должен иметься универсальный интерфейс для композиции вычислений с эффектом (стрелок Клейсли)
\begin{hscode}
(<=<) :: (b -> m c) -> (a -> m b) -> (a -> m c)
\end{hscode}
Но используя только интерфейс функтора не реализовать, нужно сделать контекст плоским:
\begin{hscode}
k1 <=< k2 = \x -> k1 <$> (k2 x) -- увы :: m (m c)
\end{hscode}
	\item  Но нет универсального интерфейса для извлечения из контекста.
\end{itemize}
\begin{hscode}
class Applicative m => Monad m where
	return :: a -> m a
	(>>=) :: m a -> (a -> m b) -> m b -- произносят bind
	(>>) :: m a -> m b -> m b
	m1 >> m2 = m1 >>= \_ -> m2

	fail :: String -> m a  -- изгнан в MonadFali с >= 8.6
	fail s = error s
infixl 1 >>, >>=
\end{hscode}
Из обычной функции можно получить стрелку Клейсли:
\begin{hscode}
toKleisli :: Monad m => (a -> b) -> (a -> m b)
toKleisli f = \x -> return (f x)
\end{hscode}
Связыватель  \hs{(>>=)} похож на \hs{(&)}, только имеет дополнительный контекст:
\begin{hscode}
(>>=) m a -> (a -> m b) -> m b

($) :: (a -> b) -> a -> b
(&) :: a -> (a -> b) -> b
(&) = flip ($)
infixl 1 &

GHCi> 2 & (+3) & (*9) & (+(-3)) 
42
\end{hscode}

Напишем представителя \hs{Monad} для простейшего типа \hs{Identity}, представляющего собой простую упаковку для другого типа:
\begin{hscode}
newtype Identity a = Identity { runIdentity :: a }

instance Monad Identity where
	return x = Identity x
	Identity x >>= k = k x
\end{hscode}
В стрелку Клейсли k передается ,,распакованное'' значение.
\begin{hscode}
return :: a -> Identity a
(>>=) :: Identity a -> (a -> Identity b) -> Identity b
\end{hscode}
Нетривиальная стрелка Клейсли:
\begin{hscode}
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ x = Identity (succ x)

GHCi> runIdentity $ wrap'n'succ 3
4
GHCi> runIdentity $ wrap'n'succ 3 >>= wrap'n'succ
5
GHCi> runIdentity $ wrap'n'succ 3 >>= wrap'n'succ >>=
wrap'n'succ
6
\end{hscode}
\subsection{Законы}
Первые два закона выражают тривиальную природу \hs{return}, третий ---задает некоторое подобие ассоциативности.
\begin{hscode}
return a >>= k = k a
m >>= return = m
(m >>= k) >>= k' = m >>= (\x -> k x >>= k')

GHCi> runIdentity $ wrap'n'succ 3
4
GHCi> runIdentity $ return 3 >>= wrap'n'succ
4
GHCi> runIdentity $ wrap'n'succ 3 >>= return
4	

GHCi> runIdentity $ wrap'n'succ 3 >>= wrap'n'succ >>= w
rap'n'succ
6
GHCi> runIdentity $ wrap'n'succ 3 >>= (\x -> wrap'n'suc
c x >>= wrap'n'succ)
6
\end{hscode}
Запишем в одно выражение несколько строк из примера (по третьему закону, так можно) и прицепим \hs{return} (по второму):
\begin{hscode}
goWrap0 = wrap'n'succ 3 >>=
          wrap'n'succ >>=
          wrap'n'succ >>=
          return
goWrap1 = wrap'n'succ 3 >>= (\x ->
          wrap'n'succ x >>= (\y ->
          wrap'n'succ y >>= \z ->
          return z))
goWrap2 = wrap'n'succ 3 >>= (\x ->  -- это примерно присваивание!
          wrap'n'succ x >>= (\y ->
          wrap'n'succ y >>= \z ->
          return (x,y,z)))
\end{hscode}
Если нас не интересует какое-то  значение  можем его пропускать через \hs{>>}.
Для упрощения этой записи есть do-нотация:
\begin{hscode}
do {e}                  = e
do {e; stmts}           = e >> do {stmts}
do {p <- e; stmts}      = e >>= \p -> do {stmts} 
do {let v = exp; stmts} = let v = exp in do {stmts}    
\end{hscode}
Здесь все \hs{e :: m a}, а вот \hs{exp} может быть любым. В третьем правиле сопоставление с образцом p могло быть неудачным, и тогда вызывается  \hs{fail}.
\begin{hscode}
goWrap3 = let i = 3 in
          wrap'n'succ i >>= (\x ->
          wrap'n'succ x >>= (\y ->
          wrap'n'succ y >>
          return (i,x,y)))
goWrap4 = do
  let i = 3
  x <- wrap'n'succ i
  y <- wrap'n'succ x
  wrap'n'succ y
  return (i,x,y)
\end{hscode}


\section{Класс типов \hs{MonadFail}, его история и представители.}
Вызов \hs{fail} в современном GHC (>=8.6) ссылается на функцию из класса типов \\ \hs{Control.Monad.Fail.MonadFail}:
\begin{hscode}
class Monad m => MonadFail m where
	fail :: String -> m a

instance MonadFail Maybe where 
	fail _ = Nothing
\end{hscode}
При реализации представителей \hs{Monad} функцию \hs{fail} в 8.6
допустимо реализовывать, но уже бессмысленно.

Предназначен для обработки неудачного сопоставления с образцом слева от \hs{<-} в do-нотации.
\begin{hscode}
GHCi> do {3 <- Just 5; return 'Z'}
Nothing
GHCi> do {3 <- Identity 5; return 'Z'} 
error: Could not deduce (MonadFail Identity) arising from a do statement with the failable pattern `3'
\end{hscode}
\subsection{Трансляция в \hs{Kernel}}
do-нотация транслируется в Haskell Kernel по-разному, в
зависимости от того является ли образец ,,failable'' или нет:
\begin{hscode}
GHCi> :t do {x <- return 5; return 'Z'}
do {x <- return 5; return 'Z'} :: Monad m => m Char
GHCi> :t do {3 <- return 5; return 'Z'}
do {3 <- return 5; return 'Z'} :: MonadFail m => m Char
GHCi> :t do {~3 <- return 5; return 'Z'}
do {~3 <- return 5; return 'Z'} :: Monad m => m Char
\end{hscode}
Неопровержимые образцы не являются ,,failable''.

\hs{data} с одним конструктором и \hs{newtype} не ,,failable'' сами по себе, но могут оказаться ,,failable'' при вложении образцов.
\begin{hscode}
GHCi> :t do {(s,x) <- return ("Answer",42); return 'Z'}
do {(s,x) <- return ("Answer",42); return 'Z'} :: Monad m => m Char

GHCi> :t do {(s,42) <- return ("Answer",42); return 'Z'}
do {(s,42) <- return ("Answer",42); return 'Z'} :: MonadFail m => m Char

GHCi> :t do {Left x <- return (Left 42); return 'Z'}
do {Left x <- return (Left 42); return 'Z'} :: MonadFail m => m Cha
\end{hscode}


\section{Стандартные монады: \hs{Maybe} и списки.}
\subsection{\hs{Maybe}}
\begin{hscode}
instance Mondad Maybe where 
	return = Just
	(Just x) >>= k = k x
	Nothing >>= _ = Nothing

	(Just _) >> m = m
	Nothing >> _ = Nothing

	fail _ = Nothing
\end{hscode}
Рассмотрим такую ,,базу данных'':
\begin{hscode}
type Name = String
type DataBase = [(Name, Name)]

fathers, mothers :: DataBase
fathers =
	[("Bill","John"),("Ann","John"),("John","Piter")]
mothers =
	[("Bill","Jane"),("Ann","Jane"),("John","Alice") ,("Jane","Dorothy"),("Alice","Mary")]

getM, getF :: Name -> Maybe Name
getM person = lookup person mothers
getF person = lookup person fathers

lookup :: Eq a => a -> [(a, b)] -> Maybe b
\end{hscode}
Найдем прабабушку Билла по материнской линии отца:
\begin{hscode}
GHCi> getF "Bill" >>= getM >>= getM
Just "Mary"
GHCi> do { f <- getF "Bill"; m <- getM f; getM m }
Just "Mary"
\end{hscode}
\underline{Функция поиска бабушек}:
\begin{hscode}
granmas person = do
	m <- getM person
	gmm <- getM m
	f <- getF person
	gmf <- getM f
	return (gmm, gmf)

GHCi> granmas "Ann"
Just ("Dorothy","Alice")
GHCi> granmas "John"
Nothing  -- так как есть только одна бабушка
\end{hscode}

\subsection{Списки}
Монада списка представляет вычисление с нулём или большим
числом возможных результатов.
\begin{hscode}
instance Monad [] where
	return x = [x]
	xs >>= k = concat (map k xs)
	fail _ = []
\end{hscode}
Связывание \hs{(>>=)} отображает стрелку \hs{k :: a -> [b]} на список \hs{xs :: [a]} и выполняет конкатенацию получившегося списка списков типа \hs{[[b]]}.
\begin{hscode}
GHCi> "abc" >>= replicate 3
"aaabbbccc"
\end{hscode}
Следующие три списка --- одно и то же:
\begin{hscode}
list1 = [ (x, y) | x <- [1, 2, 3], y <- [1, 2, 3], x /= y ]

list2 = do
	x <- [1, 2, 3]
	y <- [1, 2, 3]
	True <- return (x /= y)
	return (x, y)

list3 = 
	[1, 2, 3] >>= (\x ->
	[1, 2, 3] >>= (\y ->
	return (x /= y) >>= (\r ->
	case r of 
		True -> return (x, y)
		_ -> fail "Will be ignored :)")))
\end{hscode}
Отличие \hs{Monad} от \hs{Applicative} --- в монадах результат предыдущего значения может влиять на структуру последующего:
\begin{hscode}
GHCi> do {a <- [1..3]; b <- [a..3]; return (a,b)}
[(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
\end{hscode}


\section{Ввод-вывод в чистых языках. Монада \hs{IO}. Взаимодействие с файловой системой.}
В чистых языках, где значение функции зависит только от её
параметров, ввод-вывод представляет собой проблему.
Функция
\begin{hscode}
getCharFromConsole :: Char
\end{hscode}
всегда должна возвращать одно и то же!

Как с этим справиться?
\begin{hscode}
getCharFromConsole :: RealWorld -> (RealWorld, Char)
\end{hscode}
При этом доступ к значениям типа \hs{RealWorld} (это то, с чем связан пользователь) должен быть
ограничен.

\subsection{\hs{IO}}
\begin{itemize}
	\item Значение типа \hs{IO} --- это вычисление, которое при выполнении может осуществлять действие ввода-вывода.
	\item Реализация в GHC (неофициально, упрощено, меняется от версии к версии)
		\begin{hscode}
newtype IO a = IO (RealWorld -> (RealWorld, a))
		\end{hscode}
	\item Про тип \hs{RealWorld} в документации сказано ,,deeply magical'', он не экспортируется из модуля, поэтому программист не имеет к нему доступа.
	\item И это очень хорошо, поскольку один и тот же \hs{RealWorld} нельзя использовать два раза!
	\item Единственный способ выполнить действие ввода-вывода --- связать его с функцией \hs{main} программы.
\end{itemize}
\begin{hscode}
newtype IO a = IO (RealWorld -> (RealWorld, a))

unIO :: IO a -> RealWorld -> (RealWorld, a)
unIO (IO a) = a

instance Monad IO where
	return x = IO $ \w -> (w, x)
	(>>=) (IO m) k = IO $ \w -> case m w of (new_w, a) -> unIO (k a) new_w
\end{hscode}
Гарантии, которые должны выполняться:
\begin{itemize}
	\item Побочные эффекты происходят в заданном порядке.
	\item Побочный эффект каждого действия происходит один раз.
\end{itemize}

\subsection{Функции}
У нас есть примитивы \hs{getChar, putChar}, про которые мы не знаем реализации, это базовые кирпичики
\begin{itemize}
	\item Ввод:
		\begin{hscode}
getChar :: IO Char
getLine :: IO String
getContents :: IO String
		\end{hscode}
	\item Вывод:
\begin{hscode}
putChar :: Char -> IO ()
putStr, putStrLn :: String -> IO ()
print :: Show a => a -> IO ()
\end{hscode}
\item Ввод-вывод: читаем ввод, обрабатываем, пишем ответ обратно
	\begin{hscode}
interact :: (String -> String) -> IO ()
	\end{hscode}
\end{itemize}
\subsection{Пример}
\hs{main} имеет такой же тип \hs{IO ()}
\begin{hscode}
main = do
	putStrLn "What is your name?"
	name <- getLine
	putStrLn $ "Nice to meet you, " ++ name ++ "!"
\end{hscode}
Как, имея \hs{getChar}, сделать \hs{getLine}?
\begin{hscode}
getLine' :: IO String
getLine' = do
	c <- getChar
	if c == '\n' then
		return []
	else do
		cs <- getLine'
		return (c:cs)
\end{hscode}
Как, имея \hs{putChar}, сделать \hs{putStr}?
\begin{hscode}
putStr' :: String -> IO ()
putStr' [] = return ()
putStr' (x:xs) = putChar x >> putStr' xs
\end{hscode}
Можно выделить общий шаблон свёртки
\begin{hscode}
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
sequence_ = foldr (>>) (return ())
\end{hscode}
Тогда
\begin{hscode}
putStr'' :: String -> IO ()
putStr'' = sequence_ . map putChar
\end{hscode}
\hs{sequence_ . map} тоже можно обобщить:
\begin{hscode}
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
mapM_ f = sequence_ . fmap f

putStr''' :: String -> IO ()
putStr''' = mapM_ putChar
\end{hscode}

\paragraph{Еще более полновесные аналоги}
\begin{hscode}
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
sequence = sequenceA

mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
mapM f = sequence . fmap f  -- traverse

GHCi> mapM_ putChar "Hello"
HelloGHCi> mapM putChar "Hello"
Hello[(),(),(),(),()]
\end{hscode}




\section{Монада \hs{Reader}.}
Вычисление, допускающее чтение значений из разделяемого окружения.
\begin{hscode}
instance Monad ((->) r) where
	return :: a -> (r -> a)  -- просто игнорим окружение 
	retrun x = \_ -> x

	(>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)  -- передаем полученное окружение в оба вычисления
	m >>= k = \e -> k (m e) e

GHCi> do {a <- (^2); b <- (*5); return (a + b)} $ 3
24
\end{hscode}
Для большей универсальности введем тип:
\begin{hscode}
newtype Reader r a = Reader { runReader :: r -> a }
\end{hscode}
На самом деле этот тип определен по-другому, а нам интересен публичный интерфейс сборки и разборка:
\begin{hscode}
reader :: (r -> a) -> Reader r a
runReader :: Reader r a -> r -> a

instance Monad (Reader r) where
	return x = reader $ \_ -> x
	m >>= k = reader $ \e -> let v = runReader m e in runReader (k v) e
\end{hscode}
Напишем простейший \hs{Reader}, отчитывающийся о значении окружная:
\begin{hscode}
simpleReader :: Show r => Reader r Strins
simpleReader = reader (\e -> "Enviroment is " ++ show e)

GHCi> runReader simpleReader 42
"Enviroment is 42"
\end{hscode}
\subsection{Функция \hs{ask}}
Функция \hs{ask :: Reader r r} возвращает окружение
\begin{hscode}
type User = String
type Password = String
type UsersTable = [(User,Password)]

pwds :: UsersTable
pwds = [("Bill","123"),("Ann","qwerty"),("John","2sR")]
firstUser = do
	e <- ask
	let name = fst (head e)
	return name

GHCi> runReader firstUser pwds
"Bill"
\end{hscode}
\subsection{Функция \hs{asks}}
Функция \hs{asks :: (r -> a) -> Reader r a} возвращает
результат выполнения функции над окружением:
\begin{hscode}
getPwdLen :: User -> Reader UsersTable Int
getPwdLen person = do
	mbPwd <- asks $ lookup person
	let mbLen = fmap length mbPwd
	let len = fromMaybe (-1) mbLen
	return len
GHCi> runReader (getPwdLen "Ann") pwds
6
GHCi> runReader (getPwdLen "Ann") []
-1
\end{hscode}


\section{Монада \hs{Writer}.}
Это вычисление, допускающее запись в лог. В первом элементе пары лежит значение, во втором --- лог.
\begin{hscode}
newtype Writer w a = Writer { runWriter :: (a, w) }

writer :: (a, w) -> Writer w a
runWriter :: Writer w a -> (a, w)
\end{hscode}
Контекст \hs{Monoid} обеспечивает полноценное конструирование
лога.
\begin{hscode}
instance Monoid w => Monad (Writer w) where
	return x = writer (x, mempty)
	m >>= k = let ~(x, u) = runWriter m  -- ~ для ленивого вычисления
                  ~(y, v) = runWriter $ k x
                in writer (y, u `mappend` v)
\end{hscode}
Есть два способа запустить вычисление
\begin{hscode}
runWriter :: Writer w a -> (a, w)
execWriter :: Writer w a -> w  -- если хотим только логгирование получить

GHCi> runWriter (return 3 :: Writer String Int)
(3,"")
GHCi> runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
GHCi> execWriter (return 3 :: Writer (Product Int) Int)
Product {getProduct = 1}
\end{hscode}
База данных для интернет-магазина «Овощи-Фрукты».
\begin{hscode}
type Vegetable = String

type Price = Double
type Qty = Double
type Cost = Double

type PriceList = [(Vegetable, Price)]
prices :: PriceList
prices = [("Potato", 13),("Tomato", 55),("Apple", 48)]
\end{hscode}
\subsection{Функция \hs{tell}}
Функция \hs{tell :: Monoid w => w -> Writer w ()} позволяет задать вывод, здесь возвращаемый unitype () подчеркивает, что задача функции породить эффект, а не вернуть что-то.
\begin{hscode}
addVegetable :: Vegetable -> Qty -> Writer (Sum Cost) (Vegetable, Price)
addVegetable veg qty = do
	let pr = fromMaybe 0 $ lookup veg prices
	let cost = qty * pr
	tell $ Sum cost
	return (veg, pr)

GHCi> runWriter $ addVegetable "Apple" 100
(("Apple",48.0), Sum {getSum = 4800.0})
GHCi> runWriter $ addVegetable "Pear" 100
(("Pear",0.0), Sum {getSum = 0.0})
\end{hscode}
\subsection{Функция \hs{listen}}
Если хотим знать промежуточные стоимости, используем

\hs{listen :: Monoid w => Writer w a -> Writer w (a, w)}
\begin{hscode}
myCart1 :: Writer (Sum Cost) [((Vegetable, Price), Sum Cost)]
myCart1 = do
	x1 <- listen $ addVegetable "Potato" 3.5
	x2 <- listen $ addVegetable "Tomato" 1.0
	x3 <- listen $ addVegetable "AGRH!!" 1.6
	return [x1,x2,x3]

GHCi> runWriter myCart1
([(("Potato",13.0),Sum {getSum = 45.5}),(("Tomato",55.0), 
Sum {getSum = 55.0}),(("AGRH!!",0.0),Sum {getSum = 0.0})],
Sum {getSum = 100.5})
\end{hscode}
\subsection{Функция \hs{listens}}
Есть более гибкая альтернатива, можем фильтровать то, что выводим

\hs{listens :: Monoid w => (w -> b) -> Writer w a -> Writer w (a, b)}
\begin{hscode}
myCart1' :: Writer (Sum Cost) [((Vegetable, Price), Cost)]
myCart1' = do
	x1 <- listens getSum $ addVegetable "Potato" 3.5
	x2 <- listens getSum $ addVegetable "Tomato" 1.0
	x3 <- listens getSum $ addVegetable "AGRH!!" 1.6
	return [x1,x2,x3]

GHCi> runWriter myCart1'
([(("Potato",13.0),45.5),(("Tomato",55.0),55.0),(("AGRH!!",0.0),0.0)],Sum {getSum = 100.5})
\end{hscode}
\subsection{Функция \hs{censor}}
Для модификации лога используем

\hs{censor :: Monoid w => (w -> w) -> Writer w a -> Writer w a}
\begin{hscode}
myCart0' :: Writer (Sum Cost) [(Vegetable, Price)]
myCart0' = censor (discount 10) myCart0

discount :: Double -> Sum Cost -> Sum Cost
discount proc s@(Sum x)
	| x < 100 = s
	| x >= 100 = Sum $ x * (100 - proc) / 100

GHCi> execWriter myCart0
Sum {getSum = 100.5}
GHCi> execWriter myCart0'
Sum {getSum = 90.45}
\end{hscode}


\section{Монада \hs{State}.}
Вычисление,позволяющее работать с изменяемым состоянием.
\begin{hscode}
newtype State s a = State { runState :: s -> (a, s) }

state :: (s -> (a, s)) -> State s a
runState :: State s a -> s -> (a, s)

instance Monad (State s) where 
	return x = state $ \st -> (x, st)
	m >>= k = state $ \st -> let (x, st') = runState m st
	                             m' =  k x
                             in runState m' st'
\end{hscode}
\hs{return} упаковывает значение в функцию, не меняющую состояние. \hs{(>>=)} передает обновленное первым вычислением состояние во второе вычисление.

Помимо пары, в вычислении с состоянием можно получить либо только итоговое состояние, либо только итоговое значение вычисления:
\begin{hscode}
runState :: State s a -> s -> (a,s)
execState :: State s a -> s -> s
evalState :: State s a -> s -> a

GHCi> runState (return 3 :: State String Int) "Hi, State!"
(3,"Hi, State!")
GHCi> execState (return 3 :: State String Int) "Hi, State!"
"Hi, State!"
GHCi> evalState (return 3 :: State String Int) "Hi, State!"
3
\end{hscode}
\subsection{Функции стандартного интерфейса}
\begin{hscode}
get :: State s s  -- ask
get = state $ \s -> (s, s)

put s :: s -> State s ()  -- tell, но мы портим прошлое состояние
put = state $ \_ -> ((), s)

modify :: (s -> s) -> State s ()  -- обработка
modify f = do s <- get
              put (f s)

gets :: (s -> a) -> State s a 
gets f = do s <- get
         return (f s) 
\end{hscode}
\subsection{Примеры}
\begin{hscode}
tick :: State Int Int  -- увеличиваем состояние на 1, возвразаемое значение оставляем
tick = do n <- get
          put (n + 1)
          return n
GHCi> runState tick 3
(3,4)

succ' :: Int -> Int
succ' n = execState tick n

plus :: Int -> Int -> Int
plus n x = execState (sequence $ replicate n tick) x 
\end{hscode}
Конструкция \hs{sequence . replicate n} встречается довольно часто, поэтому в \hs{Control.Monad} определено
\begin{hscode}
replicateM :: Applicative m => Int -> m a -> m [a] -- (Раньше контекст был Monad m)
replicateM n = sequenceA . replicate n 

plus' :: Int -> Int -> Int
plus' n x = execState (replicateM n tick) x
\end{hscode}

\paragraph{Другие инструменты для работы с состоянием}
\begin{itemize}
	\item \hs{State} это чистая функциональная конструкция.
	\item Монада \hs{ST} позволяет локально работать с настоящим изменяемым состоянием. Имеется удобный вспомогательный ссылочный тип \hs{STRef}. Локальность обеспечивается типом второго ранга 

		\hs{runST :: (forall s. ST s a) -> a}
	\item \hs{IORef} это \hs{STRef} без локальности и соответствующих гарантий безопасности.
	\item \hs{MVar} это \hs{IORef} с блокировками, поддерживающими конкурентный доступ.
	\item \hs{TVar} это изменяемые ячейки памяти в рамках \hs{STM} (Software transactional memory).
\end{itemize}


\section{Монада \hs{Except}.}
Вычисление, допускающее возбуждение и перехват
исключений.
\begin{hscode}
newtype Except e a = Except {runExcept :: Either e a}  -- как обычно такого на самом деле нет

except :: Either e a -> Except e a
except = Except

instance Monad (Except e) where
	return a = Except $ Right a
	m >>= k = case runExcept m of
		Left e -> Except $ Left e
		Right x -> k x
\end{hscode}
\subsection{Стандартный интерфейс}
\begin{hscode}
throwE :: e -> Except e a
throwE = except . Left

catchE :: Except e a -> (e -> Except e' a) -> Except e' a
m `catchE` h = case runExcept m of
	Left l -> h l
	Right r -> Except $ Right r
\end{hscode}
\subsection{Использование}
\begin{hscode}
do { action1; action2; action3 } `catchE` handler
\end{hscode}
В библиотеке mtl по историческим причинам \hs{throwError} и
\hs{catchError}.
\subsection{Примеры}
\begin{hscode}
data DivByError = ErrZero | Other String deriving (Eq,Show)

(/?) :: Double -> Double -> Except DivByError Double
_ /? 0 = throwE ErrZero
x /? y = return $ x / y

example0 :: Double -> Double -> Except DivByError String
example0 x y = action `catchE` handler where
	action = do q <- x /? y
	return $ show q
	handler = return . show
GHCi> runExcept $ example0 5 2
Right "2.5"
GHCi> runExcept $ example0 5 0
Right "ErrZero"
\end{hscode}
Можем захотеть расширить функциональность, работать с ошибками хитрее,
можем использовать функциональность \hs{MonadPlus}, то
есть \hs{guard, msum, mfilter}, для этого нужно сделать \hs{Except e} представителем:
(это, например, ошибка по умолчанию, операция накапливания ошибок)
\begin{hscode}
instance Monoid e => MonadPlus (Except e) where
	mzero = Except $ Left mempty
	Except x `mplus` Except y = Except $
		case x of
			Left e -> either (Left . mappend e) Right y
			r -> r
\end{hscode}
Семантика:
\begin{itemize}
	\item \hs{mzero} --- ошибка по умолчанию для \hs{guard}, задается \hs{mempty};
	\item \hs{mplus} --- накапливает ошибки слева направо, но если
происходит удачная попытка, то возвращает удачу.
\end{itemize}
\begin{hscode}
instance Monoid DivByError where
	mempty = Other ""
	Other s1 `mappend` Other s2 = Other $ s1 ++ s2
	Other s1 `mappend` ErrZero = Other $ s1 ++ "zero;"
	ErrZero `mappend` Other s2 = Other $ "zero;" ++ s2
	ErrZero `mappend` ErrZero = Other $ "zero;zero;"

example2 :: Double -> Double -> Except DivByError String
example2 x y = action `catchE` handler where
	action = do
		q <- x /? y
		guard $ y >= 0
		return $ show q
	handler = \err -> return $ show err
\end{hscode}

Посмотрим, как это работает
\begin{hscode}
GHCi> runExcept $ example2 5 0
Right "ErrZero"
GHCi> runExcept $ example2 5 (-2)
Right "Other \"\""
GHCi> runExcept $ msum [5/?0, 7/?0, 2/?0]
Left (Other "zero;zero;zero;")
GHCi> runExcept $ msum [5/?0, 7/?0, 2/?4]
Right 0.5
\end{hscode}


\end{document}
