\documentclass[11pt,a4paper]{article}
\input{preamble.tex}

\title{Билеты к экзамену по функциональному программированию. Haskell}
\author{Тамарин Вячеслав}

\makeindex

\begin{document}
\maketitle


\section{Основы программирования на Haskell. Связывание. Рекурсия. Базовые конструкции языка.}
% Базовыми ,,строительными кирпичиками'' для выражения служат \textit{Литералы}: символьные ('a', 'X', '\''); строковые ("Hello, world!"); целочисленные (42) и с плавающей точной (3.14159).
% Булевы значение определены через пользовательский тип данных.
\section{Основные встроенные типы языка Haskell. Система модулей. Частичное применение, каррирование.}


\section{Операторы и их сечения в Haskell. Бесточечный тип.}


\section{Ошибки. Основание. Строгие и нестрогие функции. Ленивое и энергичное исполнение.}
\subsection{Ошибки}
Специальное обозначение ошибки исполнения: $ \bot$ --- основание, дно, bottom. Библиотечная константа \mintinline{haskell}|undefined| --- пример реализации $\bot$. Другая реализация:
\begin{hscode}
bot = 1 + bot
fortyTwos = 42 : fortyTwos
\end{hscode}
Это пример продуктивной расходимости --- \mintinline{haskell}|take 5 fortyTwos|.

Теперь мы можем написать более ,,аккуратную'' версию факториала
\begin{hscode}
factorial n =
	if n < 0
	then error "factorial: negative argument"
	else if n > 1
		then n * factorial (n-1)
		else 1
\end{hscode}
Использованная здесь библиотечная функция \mintinline{haskell}|error| --- это гибкая версия \mintinline{haskell}|undefined| с настраеваемым сообщением об ошибке:
\begin{minted}{c}
GHCi> factorial (-3)
*** Exception: factorial: negative argument
\end{minted}
Тип \mintinline{haskell}|Bool| будет иметь три значения: \mintinline{haskell}|True, False, undefined|, так как вычисление могло не завершится.
\begin{hscode}
\bot :: forall {a}. a
\end{hscode}

\subsection{Строгость функций}
Haskell гарантирует вызов по необходимости, если мы запустим функцию, игнорирующую аргумент даже с расходимостью, то получим ответ. Функции, игнорирующие значение своего аргумента, называются \textit{нестрогими} по этому аргументу.

Для \textit{строгих} функций всегда результатом расходимости будет расходимость.

Небольшой неэффективностью ленивого вычисления является удержание всех незавершенных вычислений через указатели. Компилятор борется с этим с помощью анализатора строгости -- если вычисления гарантировано строгие, он снимает нестрогость.

Другая неэффективность --- нарастание отложенных вычислений (thunk). Чтобы форсировать вычисление можно использовать следующую функцию:
\begin{hscode}
seq :: a -> b -> b
seq :: \bot b =  \bot
seq a b = b, если a != \bot
\end{hscode}
Форсирование происходит до слабой головной нормальной формы, то есть до барьера распространения $ \bot$: конструктор данных, лямбда-абстрацкия, частично примененная функция.
\begin{hscode}
GHCi> seq (undefined, undefined) 42
42
GHCi> seq (\x -> undefined) 42
42
GHCi> seq ((+) undefined) 42
42
\end{hscode}
Через \mintinline{haskell}|seq| определяется энергичная аппликация
(с вызовом-по-значению):
\begin{hscode}
infixr 0 $!
($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x
\end{hscode}
Форсирование приводит к ,,худшей определенности''
\begin{hscode}
GHCi> ignore undefined
42
GHCi> ignore $! undefined
*** Exception: Prelude.undefined
\end{hscode}
Пример использования \mintinline{haskell}|seq|:
вспомним факториал c аккумулирующим параметром
\begin{hscode}
factorial n = helper 1 n where
  helper acc k | k > 1 = helper (acc * k) (k - 1)
               | otherwise = acc
\end{hscode}
Из-за ленивости \mintinline{haskell}|acc| будет содержать thunk вида
$$(...((1 * n) * (n - 1)) * (n - 2) * ... * 2)$$

Оптимизатор GHC обычно справляется, имея встроенный
анализатор строгости. Но можно, не полагаясь на него,
написать
\begin{hscode}
factorial n = helper 1 n where
  helper acc k | k > 1 = (helper $! acc * k) (k - 1)
               | otherwise = acc
\end{hscode}


\section{Алгебраические типы данных. Сопоставление с образцом, его семантика.}
Из базовых кирпичиков типов можно строить новые с помощью суммы, произведения и возведения в степень.							

\subsection{Сопоставление с образцом}
Пусть мы хотим поменять местами два элемента в паре:
\begin{hscode}
swap :: (a, b) -> (b, a)
swap :: (x, y) = (y, x)
\end{hscode}
Здесь конструкция \mintinline{haskell}|(x, y)| представляет собой \mf{образец}.
\begin{hscode}
GHCi> swap (5 + 2, True)
(True, 7)
\end{hscode}
При вызове функции происходит \mf{сопоставление с  образцом}:
\begin{itemize}
	\item проверяется, что конструктор \hs{(, )} подходящий
	\item переменные \hs{x} и \hs{y} связываются с выражениями \hs{5 + 2} и \hs{True}
	\item осуществляется подстановка вместо переменных в теле функции \hs{swap}
\end{itemize}

\subsection{Тип суммы}
\mf{Перечисление} --- тип с 0-арными конструкторами данных:
\begin{hscode}
data CardinalDirection = North | East | South | West deriving Show
\end{hscode}
Конструкторы данных имеют тип \hs{CardinalDirection}:
\begin{hscode}
GHCi> dir = North
GHCi> :t dir
dir :: CardinalDirection
\end{hscode}
Сопоставление с образцом происходит сверху вниз
\begin{hscode}
hasPole :: CardinalDirection -> Bool
hasPole North = True
hasPole South = True
hasPole _ = False
\end{hscode}
Подчеркивание (или переменная) задают неопровержимый
образец.
\begin{hscode}
GHCi> hasPole North
True
GHCi> hasPole West
False
\end{hscode}
Встроенные типы данных (\hs{Char, Int, Integer}) ведут себя так, как будто определены как перечисления, поэтому можно использовать литералы как образцы.

\subsection{Декартово произведение}
Тип-произведение с одним конструктором данных
\begin{hscode}
data PointDouble = PtD Double Double
deriving Show

GHCi> :type PtD
PtD :: Double -> Double -> PointDouble

midPointDouble :: PointDouble -> PointDouble
-> PointDouble
midPointDouble (PtD x1 y1) (PtD x2 y2) =
PtD ((x1 + x2) / 2) ((y1 + y2) / 2)

GHCi> midPointDouble (PtD 3.0 5.0) (PtD 9.0 8.0)
PtD 6.0 6.5
\end{hscode}
Можно параметризовывать типовым параметром:
\begin{hscode}
data Point a = Pt a a
deriving Show

GHCi> :type Pt
Pt :: a -> a -> Point a
\end{hscode}
\hs{Point} --- оператор над типами, конкретный тип получается его аппликацией к некоторому типу, например, \hs{Int}.
\begin{hscode}
GHCi> :kind Point
Point :: * -> *

GHCi> :kind Point Int
Int :: *
\end{hscode}
\mf{Кайнды} --- система типов над системой типов Haskell.
\subsection{Экспоненциальные типы}
\mf{Экспоненциальный} тип --- это тип функции.
\begin{hscode}
data Endom a = Endom (a -> a)
appEndom :: Endom a -> a -> a
appEndom (Endom f) = f

GHCi> e = Endom (\n -> 2 * n + 3)
GHCi> :t e
e :: Num a => Endom a
GHCi> :t appEndom e
appEndom e :: Num a => a -> a
GHCi> e `appEndom` 5
13
\end{hscode}
\subsection{Рекурсивные типы}
При объявлении типов можно использовать рекурсию. Это значит, что допустимо указывать объявляемый тип в качестве аргумента конструктора данных:
\begin{hscode}
GHCi> data Nat = Zero | Suc Nat deriving Show
\end{hscode}
Конструктор \hs{Suc} при этом оказывается эндоморфизмом над типом \hs{Nat}
\begin{hscode}
GHCi> :t Zero
Zero :: Nat
GHCi> :t Suc
Suc :: Nat -> Nat
\end{hscode}
Это позволяет строить неограниченное число обитателей данного типа:
\begin{hscode}
GHCi> one = Suc Zero
GHCi> two = Suc (Suc Zero)
GHCi> three = Suc two
GHCi> four = Suc three
\end{hscode}
Это так называемые числа Пеано. Их можно рассматривать как способ кодирования натуральных чисел в унарной системе исчисления. Поскольку тип \hs{Nat} это тип суммы, тотальные функции над ним, использующие опровержимые образцы, определяются
несколькими равенствами
\begin{hscode}
GHCi> {pred (Suc n) = n; pred Zero = Zero}
GHCi> pred two
Suc Zero
\end{hscode}

\subsection{Стандартные алгебраические типы}
\begin{itemize}
\item Тип \hs{Maybe a} позволяет задать ,,необязательное'' значение
\begin{hscode}
data Maybe a = Nothing | Just a
maybe :: b -> (a -> b) -> Maybe a -> b
find :: (a -> Bool) -> [a] -> Maybe a
\end{hscode}
\item Тип \hs{Either a b} описывает одно значение из двух
\begin{hscode}
data Either a b = Left a | Right b
either :: (a -> c) -> (b -> c) -> Either a b -> c

head' :: [a] -> Either String a
head' (x:_) = Right x
head' [] = Left "head': empty list"
\end{hscode}
\end{itemize}

\subsection{Сопоставление с образцом}
Сопоставление происходит сверху вниз, затем слева направо.
Сопоставление бывает
\begin{itemize}
	\item
успешным (succeed);
\item 
неудачным (fail);
\item
расходящимся (diverge).
\end{itemize}
\begin{hscode}
bar (1, 2) = 3
bar (0, _) = 5
\end{hscode}
\begin{itemize}[noitemsep]
	\item(0, 7) --- неудача в первом, успех во втором;
	\item(2, 1) --- две неудачи и, как следствие, расходимость;
	\item(1, 5-3) --- успех, так как для сопоставления нужно приходится форсировать
	\item(1, undefined) --- расходимость, так как форсируем undefined 
	\item(0, undefined) --- неудача на первом, успех на втором
\end{itemize}


\section{Объявления \texttt{type, newtype}. Метки полей.}


\section{Списки, стандартные функции работы с ними. Генерация (выделение) списков.}
Списки встроены, но мы можем определить их сами:
\begin{hscode}
data [] a = [] | a : ([] a)
infixr 5 :
\end{hscode}
Для удобства введён синтаксический сахар
\begin{hscode}
[1,2,3] = 1:(2:(3:[])) = 1:2:3:[]
\end{hscode}
\subsection{Стандартные функции из \hs{Data.List}}

\begin{hscode}
head :: [a] -> a
head (x:_) = x
head [] = error "Prelude.head: empty list"

tail :: [a] -> [a]
tail (x:xs) = xs
tail [] = error "Prelude.tail: empty list"
\end{hscode}
Это частичная функция, в современном Haskell использовать
их не рекомендуется.

Еще одним важнейшим оператором для списков служит оператор бинарной конкатенации: он делает из двух списков один, присоединяя первый к началу второго.
\begin{hscode}
infixr 5 ++
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : xs ++ ys
\end{hscode}
Из реализации оператора видно, что его сложность (число рекурсивных вызовов до наступления терминирующего условия) линейно зависит от размера первого списка и не зависит от второго.

\begin{hscode}
length :: [a] -> Int

concat :: [[a]] -> [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss

infix 4 `elem`
elem :: (Eq a) => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = x == y || elem x ys
\end{hscode}

Функция, осуществляющая поиск значения с заданным ключом в ассоциативном списке (то есть списке пар ключ-значение)
\begin{hscode}
lookup :: Eq a => a -> [(a,b)] -> Maybe b
lookup _ [] = Nothing
lookup key ((k,v):kvs)
  | key == k = Just v
  | otherwise = lookup key kvs
\end{hscode}

Оператор, возвращающий элемент списка с заданным индексом
\begin{hscode}
infixl 9 !!
(!!) :: [a] -> Int -> a
xs     !! n | n < 0 = error "Prelude.!!: negative index"
[]     !! _         = error "Prelude.!!: index too large"
(x:_)  !! 0         = x
(_:xs) !! n         = xs !! (n-1)
\end{hscode}
Левая ассоциативность позволяет удобно обслуживать вложенные списки:
\begin{hscode}
GHCi> ["Hello","world"] !! 0 !! 1
'e'
GHCi> ["Hello","world"] !! 1 !! 2
'r'
\end{hscode}
\subsubsection{Подсписки}
Функция \hs{take} получает целое число $ n$ и список и возвращает первые $ n$ элементов списка. Если элементов меньше, чем $ n$, возвращается сколько есть. Если $ n$ не положительно, возвращается пустой список.
\begin{hscode}
take :: Int -> [a] -> [a]
take n _ | n <= 0 = []
take _ []         = []
take n (x:xs)     = x : take (n - 1) xs
\end{hscode}

\begin{hscode}
drop :: Int -> [a] -> [a]
drop n xs | n <= 0 = xs
drop _ []          = []
drop n (_:xs)      = drop (n - 1) xs
\end{hscode}

\subsubsection{Функции высших порядков над списками}
В библиотеке \hs{Data.List} много функций высших порядков. У следующих двух функций первый аргумент --- функция типа \hs{a -> Bool}, то есть унарный предикат.
\begin{hscode}
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) 
  | p x = x : filter p xs
  | otherwise = filter p xs

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (x:xs)
  | p x = x : takeWhile p xs
  | otherwise = []
\end{hscode}
У функции высшего порядка map функциональный аргумент — произвольная функция:
\begin{hscode}
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
\end{hscode}

Функция map обрабатывает каждый элемент списка переданной функцией-обработчиком, формируя список результатов той же длины, но, возможно, другого типа.
\subsubsection{Семейства \hs{zip} и \hs{zipWith}}
\begin{hscode}
zip :: [a] -> [b] -> [(a,b)]
zip [] _ = []
zip _ [] = []
zip (a:as) (b:bs) = (a,b) : zip as bs

zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
...

unzip :: [(a,b)] -> ([a],[b])
unzip3 :: [(a,b,c)] -> ([a],[b],[c])
...

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith _ [] _ = []
zipWith _ _ [] = []
zipWith f (a:as) (b:bs) = f a b : zipWith f as bs

zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
...
\end{hscode}
Все перечисленные семейства содержат функции вплоть до 7 аргументов.
\subsubsection{Способы генерации списков}
\begin{hscode}
GHCi> take 2 ones
[1,1]
GHCi> take 4 (numsFrom 3)
[3,4,5,6]

take 2 ones → -- (1)
take 2 (1 : ones) → -- (2)
1 : take (2-1) ones) → -- (3)
1 : take 1 (1 : ones) → -- (4)
1 : 1 : take (1-1) ones) → -- (5)
1 : 1 : take 0 ones) → -- (6)
1 : 1 : []
\end{hscode}

\begin{itemize}
\item (1) сопоставление с образцом форсирует вычисление ones до $WHNF$;
\item (2) подходит последнее уравнение в определении \hs{take}, используем его;
\item (3) сопоставление с образцом форсирует вычисление до $WHNF$ обоих аргументов \hs{take}: первого, чтобы отвергнуть первое из уравнений в определении \hs{take}, второго — чтобы отвергнуть второе;
\item (4) используем последнее уравнение в определении \hs{take};
	\item (5) сопоставление с образцом форсирует вычисление до $WHNF$ первого аргумента \hs{take};
	\item (6) подходит первое уравнение в определении \hs{take}, используем его.
\end{itemize}

\begin{hscode}
GHCi> squares = map (^2) (numsFrom 0)
GHCi> takeWhile (<=100) squares
[0,1,4,9,16,25,36,49,64,81,100]

GHCi> fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
GHCi> take 10 fibs
[0,1,1,2,3,5,8,13,21,34]
\end{hscode}

Для формирования ,,нелинейных'' последовательностей имеется другая техника, носящая название выделение списка (\mf{list comprehension}) 
\begin{hscode}
GHCi> digits = [0..9]
GHCi> [ x^2 | x <- digits ]
[0,1,4,9,16,25,36,49,64,81]
\end{hscode}
Часть справа от вертикальной черты носит название генератора: элементы, связываемые с переменной \hs{x} пробегают по всему списку \hs{digits}. Слева от вертикальной черты находится выражение, в котором можно использовать \hs{x}. 

При наличии нескольких генераторов чаще обновляется тот, что правее:
\begin{hscode}
GHCi> [ [x,y] | x <- "ABC", y <- "de" ]
["Ad","Ae","Bd","Be","Cd","Ce"]
\end{hscode}
Генераторы могут ссылаться на значения из предыдущих генераторов; кроме того можно использовать предикаты над этими значениями для фильтрации результатов.

\subsubsection{Последовательности}
\begin{hscode}
GHCi> [1..10]
[1,2,3,4,5,6,7,8,9,10]
GHCi> [1,3..17]
[1,3,5,7,9,11,13,15,17]

ones = 1 : ones
numsFrom n = n : numsFrom (n + 1)
\end{hscode}

\section{Специальный полиморфизм. Классы типов. Объявление представителей. Классы типов \texttt{Eq, Ord, Enum, Bound}.}
\subsection{Параметрический полиморфизм}
Когда в определение функции входит тип как параметр, и мы вместо него можем подставить любой тип. Например,
\begin{hscode}
id :: a -> a
id x = x

id True     :: Bool
id "Badger" :: [Char]
id id       :: a -> a
\end{hscode}
Этот код универсален: можем использовать любой тип параметра и реализация не зависит от какой-то специфики типа.

Изучим функцию, определяющую принадлежность списку:
\begin{hscode}
elem :: a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = x == y || elem x ys
\end{hscode}
Очевидно, для элементов нужно отношение равенства. Если для встроенных типов сравнение определено, для пользовательских типов тоже можно определить отношение равенства, то для функций все сложнее:
\begin{hscode}
suc :: (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a
suc = \n s z -> n s (s z)

suc' :: (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a
suc' = \n s z -> s (n s z)

suc ?= suc'
\end{hscode}
С точки зрения $ \beta $-эквивалентности это две разные функции в \bNF. За счет использования \hs{forall} передать можно только числа Черча.

Эти функции поточечно равны, но не равны \textit{интенсинонально} (совпали по \bNF). Такие называются \textit{экстенсионально} равными.
Чтобы доказать, что функции равны придется для всех различные рассуждения использовать, поэтому в хаскеле функции несравнимы. 

\subsection{Специальный полиморфизм}
Это вид полиморфизма, противоположный параметрическому: интерфейс полностью общий (полиморфный), но реализация специализирована для конкретных типов. Например, так устроено сложение чисел.

\subsection{Классы типов}
\mf{Класс типов} --- именованный набор имен функций с сигнатурами, параметризованными общим типовыми параметром:
\begin{hscode}
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{hscode}
Имя класса типов задает ограничение, называемое \textit{контекстом}.
\begin{hscode}
(==) :: Eq a => a -> a -> Bool

elem :: Eq a => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = x == y || elem x ys
\end{hscode}
Чтобы сделать тип \textit{представителем класса}, нужно реализовать требуемые функции класса:
\begin{hscode}
instance Eq Bool where
  True  == True  = True
  False == False = True
  _     == _     = False
  x /= y = not (x == y)
\end{hscode}
Тип-представитель может быть полиморфным:
\begin{hscode}
instance Eq a => Eq [a] where
  [] == [] = True
  (x:xs) == (y:ys) = x == y && xs == ys
  _     == _     = False
\end{hscode}
Можно не реализовывать неравенство, оно определено по умолчанию.
Для механической реализации можно использовать \hs{deriving Eq}.

\subsection{Расширение класса}
Класс \hs{Ord} наследует все методы \hs{Eq} и содержит новые методы:
\begin{hscode}
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) , (<=), (>=), (>) :: a -> a -> Bool
  max, min :: a -> a -> a

  compate x y = if x == y then EQ 
                else if x <= y then LT
                else GT

  x < y = case compare x y of {LT -> True; _ -> False}
  x <= y = case compare x y of {GT -> False; _ -> True}
  x > y = case compare x y of {GT -> True; _ -> False}
  x >= y = case compare x y of {LT -> False; _ -> True}
  max x y = if x <= y then y else x
  min x y = if x <= y then x else y

sort :: Ord a => [a] -> [a]
\end{hscode}

Допустимо множественное наследование:
\begin{hscode}
class (Eq a, Show a) => MyClass a where
  ...
\end{hscode}

\subsection{\hs{Enum}, \hs{Bounded}}
\begin{hscode}
class Enum a where 
  succ, pred     :: a -> a
  toEnum         :: Int -> a
  fromEnum       :: a -> Int

  enumFrom       :: a -> [a]            -- [n..]
  enumFromThen   :: a -> a -> [a]       -- [n, n'..]
  enumFromTo     :: a -> a -> [a]       -- [n..m]
  enumFromThenTo :: a -> a -> a -> [a]  -- [n, n'..m]

class Bounded a where
  minBound, maxBound :: a
\end{hscode}
Класс \hs{Integer} потенциально бесконечен в обе стороны, поэтому он является \hs{Enum}, но не является \hs{Bounded}.


\section{Внутренняя реализация классов типов.}
Организована через механизм передачи словарей. Словарь для класса --- запись его методов.
\begin{hscode}
data Eq' a = MkEq { eq, ne :: a -> a -> Bool}
\end{hscode}
Здесь хранится две \textit{функции-селекторы}, они выбирают методы равенства и неравенства из данного словаря.
\begin{hscode}
GHCi> :t eq
eq :: Eq' a -> a -> a -> Bool
GHCi> :i ne
eq :: Eq' a -> a -> a -> Bool
\end{hscode}
Теперь вместо того, что называлось контекстом, теперь просто дополнительный параметр.

Объявления представителей транслируются в функции, возвращающие словарь или в функции, принимающие словарь и возвращающие более сложный словарь:
\begin{hscode}
dEqInt :: Eq' Int
dEqInt = MkEq {
	eq = eqInt, -- это низкоуровневый способ сравнивать Intы
	ne = \x y -> not $ eqInt x y
}

dEqList :: Eq' a -> Eq' [a]
dEqList (MkEq e _) = MkEq el (\x y -> not $ el x y) -- e - словарь для сравнения элементов списка
  where el [] [] = True
        el (x:xs) (y:ys) = x `e` y && xs `el` ys
        el _ _ = False
\end{hscode}
Теперь можем написать \hs{enum'}: он требует, чтобы ему дали словарь для сравнения элементов типа \hs{a} первым аргументом, а остальное аналогично.
\begin{hscode}
elem' :: Eq' a -> a -> [a] -> Bool
elem' _ _ [] = False
elem' d x (y:ys) = eq d x y || elem' d x ys

GHCi> elem' dEqInt 2 [3, 5, 2]
True
GHCi> elem (dEqList dEqInt) [3, 5] [[4], [1, 2, 3], [3, 5]]
True
\end{hscode}


\section{Стандартные классы типов: \texttt{Num} и его наследники, \texttt{Show} и \texttt{Read}.}
\begin{hscode}
class (Eq a, Show a) => Num a where
  (+), (-), (*) :: a -> a -> a
  negate        :: a -> a
  abs, signum   :: a -> a
  fromInteger   :: Integer -> a

  x - y = x + negate y
  negate x = 0 - x
\end{hscode}
\begin{tikzcd}%
	Enum\arrow[ddd] &&& Eq\arrow[ld]\arrow[rd] && Show\arrow[ld] \\
				  && Ord\arrow[ld]\arrow[rd] && Num\arrow[ld]\arrow[d]&\\
				  & Ix && Real\arrow[llld]\arrow[d] & Fractional\arrow[ld]\arrow[rd]& \\
	Integral\arrow[d]\arrow[rd] &&& RealFrac\arrow[rd] && Floating\arrow[ld] \\
	Int & Integer &&& RealFloat\arrow[ld]\arrow[rd] & \\
		&&& Double && Float
\end{tikzcd}

Автоматического приведения типов в Хаскеле нет. Всегда нужно использовать приведение.


\section{Полугруппы и моноиды. Представители класса типов \hs{Semigroup} и \hs{Monoid}.}
\subsection{Полугруппы}
\mf{Полугруппа} --- множество с ассоциативной бинарной операцией над ним.
\begin{hscode}
infixr 6 <>
class Semigroup a where
  (<>) :: a -> a -> a
  sconcat :: NonEmpty a -> a  -- конкатенация, все : заменяем на <>
  stimes :: Integral b => b -> a -> a  -- повторяем b раз и вставляем между копиями <>

infixr 5 :|
data NonEmpty a = a :| [a]  -- произведение a и [a]
\end{hscode}
За счет ассоциативности операции, можно достичь логарифмической трудности операций.
Для любой полугруппы должен выполняться закон:
\begin{hscode}
(x <> y) <> z = x <> (y <> z)
\end{hscode}
Список --- полугруппа относительно конкатенации:
\begin{hscode}
class Semigroup [a] where
  (<>) = (++)
\end{hscode}
Можем использовать в функциях, которые не работают на пустых списках:
\begin{hscode}
GHCi> import Data.List.NonEmpty
GHCi> sconcat $ "AB" :| ["CDE", "FG"]
"ABCDEFG"
GHCi> stimes 5 "Ab"
"AbAbAbAbAb"
\end{hscode}
\subsection{Моноиды}
\mf{Моноид} --- множество с ассоциативной бинарной операцией над ним и нейтральным элементом для этой операции.
\begin{hscode}
class Semigroup a => Monoid a where
  mempty :: a  -- нейтарльный элемент
  mappend :: a -> a -> a  -- операция
  mappend = (<>)
  mconcat :: [a] -> a
  mconcat = foldr mappend mempty
\end{hscode}
Законы:
\begin{hscode}
mempty <> x = x
x <> mempty = x
(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
\end{hscode}
Список --- моноид относительно \hs{(++)}, нейтральный --- пустой список:
\begin{hscode}
instance Semigroup [a] where
  (<>) = (++)
instance Monoid [a] where
  mempty = []
  mconcat = concat
\end{hscode}
Числа тоже моноид, причем четырежды: сложение -- нуль, умножение -- единица, минимум -- \hs{maxBound}, максимум -- \hs{minBound}.
Для разделения этих вариантов при реализации можем обернуть числа в \hs{newtype}-коробочку:
\begin{hscode}
newtype Sum a = Sum { getSum :: a} deriving (Eq, Ord, Read, Show, Bounded)
instance Num a => Semigroup (Sum a) where
  Sum x <> Sum y = Sum (x + y)
instance Num a => Monoid (Sum a) where
  mempty = Sum 0

GHCi> Sum 3 <> Sum 2 
Sum {getSum = 5}
\end{hscode}
\hs{mconcat} --- сумма нескольких чисел, \hs{stimes} --- умножение.

Теперь напишем для умножения, используя \hs{coerce} -- безопасное приведение, если мы имеем два одинаковых рантаймовых представления, то можем привести одно к другому автоматически:
\begin{hscode}
newtype Product a = Product { getProduct :: a} deriving (Eq, Ord, Read, Show, Bounded)
instance Num a => Semigroup (Product a) where
  (<>) = coerce ((*) :: a -> a -> a)  -- Data.Coerce
instance Num a => Monoid (Product a) where
  mempty = Product 1

GHCi> Product 3 <> Product 2 
Product {getProduct = 6}
\end{hscode}
Для использования \hs{coerce}, нужно подключить расширение \hs{ScopedTypeVariables}, чтобы расширить область видимости \hs{a} из типа.

\hs{Integer} не имеет максимума, поэтому, хотя это и полугруппа, моноидом быть не может. Также не существует моноида для строк.

Для решения такой проблемы можем перейти к полугрупповой операции \hs{sconcat} и от списка к  \hs{NoEmpty}:
\begin{hscode}
GHCi> (getMin . sconcat . fromList . fmap Min) ["Hello", "Hi"]
"Hello"
-- вместо
GHCi> (getMin . mconcat . fmap Min) ["Hello", "Hi"]
<interactive>: error: No instance for (Bounded [Char])
\end{hscode}

Булев тип тоже является моноидом относительно конъюнкции и дизъюнкции.
\begin{hscode}
newtype All = All { getAll :: Bool} deriving (Eq, Ord, Read, ShowBounded)
instance Semigroup All where
  (<>) = coerce (&&)
instance Monoid All where
  mempty = All True

newtype Any = Any { getAny :: Bool} deriving (Eq, Ord, Read, ShowBounded)
instance Semigroup Any where
  (<>) = coerce (||)
instance Monoid Any where
  mempty = Any False
\end{hscode}


\section{Свертки списков. Правая и левая свертки. Энергичные версии. Развертки.}
\subsection{Правая свертка}
\begin{hscode}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f ini [] = ini
foldr f ini (x:xs) = x `f` (foldr f ini xs)

p : q : r : []  ======>  p `f` (q `f` (r `f` ini))
\end{hscode}
Примеры  использования:
\begin{hscode}
sum :: [Integer] -> Integer
sum = foldr (+) 0

concat :: [[a]] -> [a]
concat = foldr (++) []

allOdd :: [Integer] -> Bool
allOdd = foldr (\n b -> odd n && b) True

id = foldr (:) []
\end{hscode}
Правые свертки позволяют работать с бесконечными списками.
\subsection{Левая свертка}
\begin{hscode}
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f ini [] = ini
foldl f ini (x:xs) = foldl f (ini `f` x) xs

p : q : r : []  ======>  ((ini `f` p) `f` q) `f` r
\end{hscode}
Здесь хвостовая рекурсия оптимизируется, но нарастает thunk из цепочки вызовов: запустятся вычисления только, когда список кончится, так как форсирования нет (нет \hs{seq} или сопоставления с образцом).

\begin{hscode}
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' f ini [] = ini
foldl' f ini (x:xs) = arg `seq` foldl' f arg xs
                        where arg = f ini x
\end{hscode}
Здесь thunk не нарастает, вычисление \hs{arg} форсируется на каждом шаге, это самая эффективная из сверток, но, как и любая левая свертка, не работает с бесконечным циклом.

\subsection{Версии без начального значения}
\begin{hscode}
foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 _ [x] = x
foldr1 f (x:xs) = f x (foldr1 f xs)
foldr1 _ [] = error "foldr1: EmptyList"
\end{hscode}
\begin{hscode}
foldl1 :: (a -> a -> a) -> [a] -> a
foldl1 f (x:xs) = foldl f x xs
foldl1 _ [] = error "foldl1: EmptyList"
\end{hscode}
Аналогично можно сделать строгую версию \hs{foldl1'}.

 \subsection{Сканы}
Это списки последовательных шагов свертки:
\begin{hscode}
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl _ z [] = [z]
scanl (#) z (x:xs) = z : scanl (#) (z # x) xs

GHCi> scanl (++) "!" ["a", "b", "c"]
["!", "!a", "!ab", "!abc"]
GHCi> scanl (*) 1 [1..] !! 5 -- факториал
120
\end{hscode}
В отличие от \hs{foldl} может работать и с бесконечными списками.

\noindent Правый скан накапливает результаты в обратном порядке:
\begin{hscode}
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr _ z [] = [z]
scanr f z (x:xs) = f x q : qs
                     where qs@(q:_) = scanr f z xs  -- здесь используем псевдоним
\end{hscode}
Тождества для сканов:
\begin{hscode}
head (scanr f z xs) = foldr f z xs
last (scanl f z xs) = foldl f z xs
\end{hscode}
\subsection{Развертка}
Двойственная свертке операция.
\begin{hscode}
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
unfoldr g ini 
  | Nothing     <- next = []
  | Just (a, b) <- next = a : unfoldr g b
  where next = g ini

GHCi> helper x = if x == 0 then Nothing else Just (x, x - 1)
GHCi> unfoldr helper 10
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
\end{hscode}
Пример использования --- возможное определение \hs{iterate}
\begin{hscode}
iterate f = unfoldr (\x -> Just (x, f x))
\end{hscode}


\section{Класс типов \hs{Foldable} и его представители.}
Идея: обобщить свертки на более общий тип, то есть  заменить скобки на букву.
\begin{hscode}
class Foldable t where
  fold :: Monoid m => t m -> m
  fold = foldMap id

  foldMap :: Monoid m => (a -> m) -> t a -> m
  foldMap f = foldr (mappend . f) mempty

  foldr, foldr' :: (a -> b -> b) -> b -> t a -> b
  foldr f z t = appEndo (foldMap (Endo . f) t) z

  foldl, foldl' :: (b -> a -> b) -> a -> t b -> a
  foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z

  foldr1, foldl1 :: (a -> a -> a) -> t a -> a
\end{hscode}
Минимальное определение \hs{foldMap} или  \hs{foldr}.
Изучим  полезные функции:
\begin{hscode}
class Foldable t where
  toList :: t a -> [a]

  null :: t a -> Bool
  null = foldr (\_ _ -> False) True

  lenght :: t a -> Int
  length = foldl' (\c _ -> c + 1) 0

  elem :: Eq a => a -> t a -> Bool
  elem x = foldr f False
             where f result elem = result || x == elem 
  
  maximum, minimum :: Ord a => t a -> a

  sum, product :: Num a => t a -> a
  sum = getSum . foldMap Sum
\end{hscode}
\subsection{Представители}
\begin{hscode}
instance Foldable [] where
  foldr = Prelude.foldr
  foldl = Prelude.foldl
  foldr1 = Prelude.foldr1
  foldl1 = Prelude.foldl1

instance Foldable Maybe where
  foldr _ z Nothing = z
  foldr f z (Just x) = f x z
\end{hscode}
Еще много контейнеров: \mf{Set, Map, Tree, Seq}. Также \hs{Either, Pair}. Чтобы объявить представителя двухпараметрического типа, первый параметр нужно связать.
\begin{hscode}
GHCi> foldr (+) 5 (Right 37)
42
GHCi> foldr (+) 5 (Left 37)
5
GHCi> foldr (+) 5 ("Answer", 37)
42

GHCi> maximum (Right 37)
37
GHCi> maximum (Left 37)
*** Exception: maximum: empty structure
GHCi> maximum (100, 42)
42
\end{hscode}
Реализация:
\begin{hscode}
foldr f z t = appEndo (foldMap (Endo . f) t ) z
foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
fold        = foldMap id
length      = getSum . foldMap (Sum . const 1)
sum         = getSum . foldMap Sum
product     = getProduct . foldMap Product
minimum     = getMin . foldMap Min
maximum     = getMax . foldMap Max
foldr f z   = foldr f z . toList
foldl f z   = foldl f z . toList 
\end{hscode}

Другие моноиды: \hs{Ordering, SortedList, a -> b}.
\begin{hscode}
newtype Endo a = Endo { appEndo :: a -> a }
instance Semigroup (Endo a) where
  Endo f <> Endo g = Endo $ f . g
instance Monoid (Endo a) where
  mempty = Endo id

newtype Dual a = Dual { getDual :: a}  -- разворачивает агрументы
instance Semigroup a => Semigroup (Dual a) where
  Dual a <> Dual b = Dual (b <> a)
instance Monoid a => Monoid (Dual a) where
  mempty = Dual mempty
\end{hscode}


\section{Класс типов \hs{Functor} и его представители.}
Функтор определятся следующим образом: 
\begin{hscode}
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)
  (<$) :: a -> f b -> f a  -- стрелка направлена в ту сторону, откуда берется значение
  (<$) = fmap . const

(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$>) fmap

($>) :: Functor f => f a -> b -> f b
($>) = flip (<$)

void :: Functor f => f a -> f ()  -- это unittype, ровно одно значение
void x = () <$ x

infixl 1 <&>
(<&>) :: Functor f => f a -> (a -> b) -> f b
xs <&> f = f <&> xs
\end{hscode}
Представители этого класса должны быть конструкторами типа с одним параметром: \hs{f :: * -> *}.
\begin{hscode}
instance Functor [] where
  fmap _ [] = []
  fmap g (x:xs) = g x : fmap g xs

instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap g (Just a) - Just (g a)

data Tree a = Leaf | Branch (Tree a) a (Tree a)
instance Functor Tree where
  fmap :: (a -> b) -> Tree a -> Tree b
  fmap g (Leaf x) = Leaf (g x)
  fmap g (Branch l x r) = Branch (fmap g l) (g x) (fmap g r)
\end{hscode}
Структурно ничего не меняется после применения \hs{fmap}, \mintinline{haskell}|<$>| --- инфиксный аналог.

Расширение \hs{InstanceSigs} позволяет указывать сигнатуры методов в представителе класса типов.

Представители для двухпараметрических типов: так как \hs{Either, (,), (->) :: * -> * -> *} мы должны связать первый параметр.
\begin{hscode}
instance Functor (Either e) where
  fmap :: (a -> b) -> Either e a -> Either e b
  fmap _ (Left x) = Left x
  fmap g (Right y) = Right (g y)

instance Functor ((,) s) where
  fmap :: (a -> b) -> (s, a) -> (s, b)
  fmap g (x, y) = (x, g y)

instance Functor ((->) e) where
  fmap :: (a -> b) -> ((->) e a) -> ((->) e b)
  fmap = (.)
\end{hscode}
\subsection{Законы}
Вообще, в Хаскеле из первого следует второй закон.
\begin{hscode}
fmap id = id
fmap (f . g) = fmap f . fmap g
\end{hscode}
Смысл законов --- сохраняем структуру контейнера, воздействуя только на элементы.
Всегда нужно следить за соблюдением законов, например, есть такой нарушитель:
\begin{hscode}
instance Functor [] where
  fmap _ [] = []
  fmap g (x:xs) = g x : g x : fmap g xs
\end{hscode}
\subsection{Не-функторы}
Единственная реализация не удовлетворяет первому закону:
\begin{hscode}
instance Functor Endo where
  fmap :: (a -> b) -> Endo a -> Endo b
  fmap _ (Endo _) = Endo id
\end{hscode}
Вообще не допускает реализации:
\begin{hscode}
newtype RevArr c a = RevArr { appRevArr :: a -> c }
\end{hscode}


\section{Класс типов \hs{Applicative} и его представители}
Хотим вынуть стрелку из контейнера.
\begin{hscode}
class Functor f => Applicative f where
  {-# Minimal pure, ((<*>) | liftA2) #-}
  pure :: a -> f a

  (<*>) :: f (a -> b) -> f a -> f b
  (<*>) = liftA2 id

  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  liftA2 g a b = g <$> a <*> b

  (*>) :: f a -> f b -> fb
  a1 *> a2 = (id <$ a1) <*> a2

  (<*) :: f a -> f b -> f a
  (<*) = liftA2 const

infixl 4 <*>, *>, <*, <**>
\end{hscode}
\hs{pure} --- чистая упаковка, вложение без эффекта.

Вспомогательные функции из \hs{Control.Applicative} 
\begin{hscode}
liftA :: Applicatice f => (a -> b) -> f a -> f b
liftA f a = pure f <*> a

liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 g a b c = g <$> a <*> b <*> c

(<**>) :: Applicative f => f a -> f (a -> b) -> f b
(<**>) = liftA2 (&)
\end{hscode}

\subsection{Законы}
\begin{itemize}
	\item Закон, связывающий \hs{Applicative} и \hs{Functor}: \hs{fmap g xs =  pure g <*> xs}
	\item Identity: \hs{pure id <*> v = v}
	\item Homomorphism: \hs{pure g <*> pure x = pure (g x)}
	\item Interchange: \mintinline{haskell}|u <*> pure x = pure ($ x) <*> u|
	\item Composition: \hs{pure (.) <*> u <*> x = u <*> (v <*> x)}
\end{itemize}


\subsection{Представители}
Контекст с возможно отсутствующим значением (примитивная обработка ошибок):
\begin{hscode}
instance Applicative Maybe where
  pure = Just
  Nothing <*> _ = Nothing
  (Just g) <*> x = fmap g x

GHCi> Just (+2) <*> Just 5
Just 7
GHCi> Just (+2) <*> Nothing
Nothing
GHCi> Just (+) <*> Just 2 <*> Just 5
Just 7
\end{hscode}
Для списков есть две семантики \hs{fs <*> xs}: либо каждый с каждым (множественные результаты недетерминированного вычисления), либо \hs{zip} (коллекция упорядоченных элементов).
Список определен только для первой, так как одна расширяется до \hs{Monad}.
\begin{hscode}
instance Applicative [] where
  pure x = [x]
  gs <*> xs = [ g x | g <- gs, x <- xs ]

newtype ZipList a = ZipList { getZipList :: [a] }

instance Functor Ziplist where
  fmap f (ZipList xs) = ZipList (map f xs)
instance Applicative ZipList where
  pure x = x : pure x  -- или repeat x из Data.List
  ZipList gs <*> ZipList xs = ZipList (zipWith ($) gs xs)
\end{hscode}
Для пары выполняется семантика логгирования:
\begin{hscode}
instance Monoid s => Applicative ((,), s) where
  pure x = (mempty, x)
  (u, f) <*> (v, x) = (u <> v, f x)

GHCi> ("Answer to ", (*)) <*> ("the Ultimate ", 6) <*> ("Question ", 7)
("Answer to the Ultimate Question ", 42)
\end{hscode}


\section{Классы типов \hs{Alternative, MonadPlus} и их представители.}
\subsection{\hs{Alternative}}
\begin{hscode}
class Applicative f => Alternative f where
	empty :: f a
	(<|>) :: f a -> f a -> f a
infixl 3 <|>
\end{hscode}
Мы наделяем аппликативный функтор дополнительной моноидальной операцией с семантикой  сложения:
\begin{hscode}
instance Alternative [] where
	empty :: [a]
	empty = []
	(<|>) :: [a] -> [a] -> [a]
	(<|>) = (++)
\end{hscode}
\begin{hscode}
instance Alternative Maybe where
	empty :: Maybe a
	empty = Nothing
	
	(<|>) :: Maybe a -> Maybe a -> Maybe a
	Nothing <|> m = m
	m <|> _ = m

	some, many :: f a -> f [a]
	some v = (:) <$> v <*> many v  -- One or more
	many v = some v <|> pure []  -- Zero or more

optional :: Alternative f => f a -> f (Maybe a)
optional v = Just <$> v <|> pure Nothing
\end{hscode}
Представитель \hs{Alternative} для \hs{Maybe} ведет себя, как упаковка \hs{First}, возвращая первый не-\hs{Nothing} в цепочке альтернатив:
\begin{hscode}
GHCi> Nothing <|> (Just 3) <|> (Just 5) <|> Nothing
Just 3
\end{hscode}
Интерфейс для парсера
\begin{hscode}
instance Alternative (Parser tok) where
	empty :: Parser tok a
	empty = Parser $ \_ -> Nothing

	(<|>) :: Parser tok a -> Parser tok a -> Parser tok a
	Parser u <|> Parser v = Parser f where
		f xs = case u xs of
			Nothing -> v xs
			z -> z
\end{hscode}
СЕМАНТИКА:
\hs{empty} --- парсер, всегда возвращающий неудачу;
\hs{(<|>)} --- пробуем первый, при неудаче пробуем второй на исходной строке.

Рекурсивный парсер
\begin{hscode}
lowers :: Parser Char String
lowers = (:) <$> lower <*> lowers <|> pure ""

GHCi> runParser lowers "abCd"
Just ("Cd","ab")
GHCi> runParser lowers "abcd"
Just ("","abcd")
GHCi> runParser lowers "Abcd"
Just ("Abcd","")
\end{hscode}

\subsection{\hs{MonadPlus}}



\section{Аппликативные парсеры}
\begin{defn}
	\mf{Парсер} --- программа, принимающая на вход строку и возвращающая некоторую структуру данных, если строка удовлетворяет заданной грамматике, или сообщение об ошибке в противном случае.
\end{defn}
Различные парсеры:
\begin{itemize}
	\item Простой, но неудобный: \hs{type Parser a = String -> a}
	\item Храним неразобранный остаток: \hs{type Parser a = String -> (String, a)}
	\item Обрабатываем ошибки: \hs{type Parser a = String -> Maybe (String, a)} или 

		\hs{type Parser a = String -> Either String (String, a)}
	\item Разбираем неоднозначные грамматики: \hs{type Parser a = String -> [(String, a)]}
\end{itemize}
Выберем третий вариант. Также существует обобщение на список токенов, который мы обрабатываем вместо строки, если перед этим мы разбили текст на лексемы / токены.
\begin{hscode}
newtype Parser tok a = Parser { runParser :: [tok] -> Maybe ([tok], a) }
\end{hscode}
Можно написать простой парсер, распознающий строку, начинающуюся с символа \hs{'A'}:
\begin{hscode}
charA :: Parser Char Char
charA = Parser f where
  f (c:cs) | c == 'A' = Just (cs, c)
  f _ = Nothing

GHCi> runParser charA "ABC"
Just ("BC", 'A')
\end{hscode}
Напишем более общую функцию, которая разбирает токен, если он удовлетворяет предикату, а иначе выдает ошибку:
\begin{hscode}
satisfy :: (tok -> Bool) -> Parser tok tok
satisfy pr = Parser f where
	f (c:cs) | pr c = Just (cs,c)
	f _ = Nothing

GHCi> runParser (satisfy isUpper) "ABC"  -- можно использовать функции из Data.Char, Data.Punctuation 
Just ("BC",'A')
GHCi> runParser (satisfy isLower) "ABC"
Nothing

lower :: Parser Char Char
lower = satisfy isLower
char :: Char -> Parser Char Char
char c = satisfy (== c) 
\end{hscode}
Чтобы поменять тип возвращаемого значения, например, возвращать цифру, а не символ, нужно сделать парсер функтором:
\begin{hscode}
digit :: Parser Char Int
digit = digitToInt <$> satisfy isDigit

instance Functor (Parser tok) where
	fmap :: (a -> b) -> Parser tok a -> Parser tok b
	fmap g (Parser p) = Parser f where
		f xs = case p xs of
			Just (cs, c) -> Just (cs, g c)
			Nothing -> Nothing
\end{hscode}
Можно сделать это компактнее, так как \hs{Parser} --- композиция трех функторов \hs{(->) [tok]}, \hs{Maybe}, \hs{(,) [tok]}:
\begin{hscode}
newtype Parser tok a = Parser { runParser :: [tok] -> Maybe ([tok], a) }

instance Functor (Parser tok) where
  fmap :: (a -> b) -> Parser tok -> Parser tok b
  fmap g (Parser p) = Parser $ (fmap . fmap . fmap) g p
\end{hscode}
Основной эффект парсера состоит в том, что мы постепенно едем по строке и отжираем от нее кусочки.

Семантика \hs{pure} --- ничего не откусить, семантика \hs{<*>} --- получить результат первого парсера, затем второго на остатке и применить первый ко второму.

Тогда можем сделать парсер аппликативным:
\begin{hscode}
instance Applicative (Parser tok) where
	pure :: a -> Parser tok a
	pure x = Parser $ \s -> Just (s, x)

	(<*>) :: Parser tok (a -> b) -> Parser tok a -> Parser tok b
	Parser u <*> Parser v = Parser f where
		f xs = case u xs of
			Nothing -> Nothing
			Just (xs', g) -> case v xs' of
				Nothing -> Nothing
				Just (xs'', x) -> Just (xs'', g x)

GHCi> runParser (pure 42) "ABCD"
Just ("ABCD",42)
GHCi> runParser (pure (,) <*> digit <*> digit) "12AB"
Just ("AB",(1,2))
GHCi> runParser ((,) <$> digit <*> digit) "1AB2"
Nothing
\end{hscode}
Постоим  парсер, который перемножает два числа:
\begin{hscode}
multiplication :: Parser Char Int
multiplication = (*) <$> digit <* char '*' <*> digit  -- <* говорит, что резуьтат звездочки просто игнорируем

GHCi> runParser multiplication "6*7"
Just ("",42)
\end{hscode}


\section{Класс типов \hs{Traversable} и его представители.}
Пусть есть список с аппликативными функторами, а мы хотим вытащить функтор наружу:
\begin{hscode}
dist :: Applicative f => [f a] -> f [a]
dist [] = pure []
dist (ax:axs) = pure (:) <*> ax <*> dist axs

GHCi> dist [Just 3,Just 5]
Just [3,5]
GHCi> dist [Just 3,Nothing]
Nothing
GHCi> getZipList $ dist $ map ZipList [[1,2],[3,4],[5,6]]
[[1,3,5],[2,4,6]]
\end{hscode}
Использование в теле определения dist тех же самых
конструкторов, что и в образцах, приводит к сохранению
трехэлементной структуры списка.

Обобщим до любого однопараматрического типа.
\begin{hscode}
class (Functor t, Foldable t) => Traversable t where
	sequenceA :: Applicative f => t (f a) -> f (t a)
	sequenceA = traverse id
	traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
	traverse g = sequenceA . fmap g
\end{hscode}
Минимальное определение: \hs{traverse} или \hs{sequenceA}.
\begin{itemize}
	\item \hs{sequenceA}: обеспечиваем правило коммутации нашего функтора \hs{t} с произвольным аппликативным функтором \hs{f}.

		Структура внешнего контейнера \hs{t} сохраняется, а аппликативные эффекты внутренних \hs{f} объединяются в результирующем \hs{f}.
	\item 
		\hs{traverse} --- это \hs{fmap} с эффектами: проезжаем по структуре \hs{t a}, последовательно применяя функцию к элементам типа \hs{a} и монтируем в точности ту же структуру из результатов типа \hs{b}, параллельно ,,коллекционируя'' эффекты.
\end{itemize}
Если реализовать \hs{Traversable}, то он будет и функтором и \hs{Foldable}.
\subsection{Представители}
\begin{hscode}
instance Traversable Maybe where
	traverse :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
	traverse _ Nothing = pure Nothing
	traverse g (Just x) = Just <$> g x

instance Traversable [] where
	traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
	traverse _ [] = pure []
	traverse g (x:xs) = (:) <$> g x <*> traverse g xs
\end{hscode}
Можно заметить, что с функтором очень схожий код, просто все происходит поднятым на уровень выше.

\subsection{Законы}
\begin{hscode}
newtype Identity a = Identity { runIdentity :: a }

instance Functor Identity where
	fmap g (Identity x) = Identity (g x)

instance Applicative Identity where
	pure = Identity
	Identity g <*> v = fmap g v
\end{hscode}
Первый закон (Identity):
\begin{hscode}
traverse Identity = Identity

GHCi> traverse Identity [1,2,3]
Identity [1,2,3]
\end{hscode}
Всякий \hs{Traversable} --- это \hs{Functor}: имея \hs{traverse} мы можем универсальным образом реализовать \hs{fmap}, удовлетворяющий законам функтора.
\begin{hscode}
fmapDefault :: Traversable t => (a -> b) -> t a -> t b
fmapDefault g = runIdentity . traverse (Identity . g)
\end{hscode}

\begin{hscode}
Identity :: b -> Identity b
(Identity . g) :: a -> Identity b
traverse (Identity . g) :: Identity (t b)
runIdentity . traverse (Identity . g) :: t b
\end{hscode}
Второй закон (Composition):
\begin{hscode}
traverse (Compose . fmap f2 . f1) = Compose . fmap (traverse f2) . traverse f1
\end{hscode}
Здесь обе части имеют тип \hs{t a -> Compose g2 g1 (t с)} в предположении, что \hs{f1 :: a -> g1 b} и \hs{f2 :: b -> g2 c}.

Третий закон (Naturality):
\begin{hscode}
h . traverse f = traverse (h . f)
\end{hscode}
Здесь \hs{h :: (Applicative f, Applicative g) => f b -> g b} -- произвольный аппликативный гомоморфизм, то есть функция удовлетворяющая требованиям:
\begin{itemize}
	\item \hs{h (pure x) = pure x};
	\item \hs{h (x <*> y) = h x <*> h y}.
\end{itemize}
В предположении, что \hs{f :: a -> f b}, обе части имеют тип \hs{t a -> g (t b)}.
\subsection{Практический смысл законов}
Законы \hs{Traversable} дают следующие гарантии:
\begin{itemize}
	\item Траверсы не пропускают элементов.
	\item Траверсы посещают элементы не более одного раза. 
	\item \hs{traverse pure} дает \hs{pure}.
	\item Траверсы не изменяют исходную структуру --- она либо сохраняется, либо полностью исчезает.
\end{itemize}
\begin{hscode}
GHCi> traverse Just [1,2,3]
Just [1,2,3]
GHCi> traverse (const Nothing) [1,2,3]
Nothing
\end{hscode}


\end{document}
