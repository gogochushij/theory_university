\lecture{6}{10 dec}{\dag}

\begin{figure}[ht]
	\centering
	\incfig{shceme-det}
	\caption{Построение схемы по ДМТ}
	\label{fig:shceme-det}
\end{figure}
\begin{ex}[$ \P$-полный язык]
	Приведем пример  $ \P$-полного языка.
	\index{\CircuitEval}
	\[
		\CircuitEval = \{(\text{схема } C, \text{вход } x \mid C(x) = 1 \}
	.\]
	Нам уже дан вход, остается только его проверить. Это легко и быстро сделать.

	Докажем полноту. Вспомним, как строили схему по недетерминированной МТ в доказательстве теоремы Кука-Левина.
	Построим аналогично по детерминированной: каждый слой отвечает за состояние, переход к следующему -- маленькие подсхемки, на вход только $ x$.

	Единственное, что нужно проверить --- что нарисовать можно с логарифмической памятью.

	Описание машины --- константа. От $ x$  нам нужна только длина, чтобы узнать количество этажей.

	На каждом уровне, чтобы построить следующий, нам нужно знать положение головки, три бита прошлой строки и состояние. Будем хранить $ t$ --- номер уровня, $ i$ --- положение головки, логарифма для этого хватит.
\end{ex}

\begin{thm}
	$ \NC^{1} \subseteq \L \subseteq \NL \subseteq \NC^{2}$.
\end{thm}
\begin{proof}
	\begin{enumerate}
		\item Начнем с последнего включения. У нас есть недетерминированная машина, использующая логарифмическую память, хотим ее параллелизовать.

			Вспомним про граф псевдоконфигураций нашей детерминированной машины. Так как память логарифмическая, конфигураций полиномиальное число.

			Можем задать допустимые переходы НМТ матрицей смежности $ A$ ($ k \times k$). Чтобы найти пути длины $ k$ (а больше нам не нужно), возведем булево в степень  $ k$.

			Это $ \log k$ последовательных умножений: $ A^2, (A^2)^2, \ldots  $, причем каждое умножение пары булевых матриц вычисляется схемой глубины $ \O(\log k)$.

			Тогда общая глубина $ \log^2 k$, из чего следует последнее включение.
		\item Среднее включение тривиально.
		\item Докажем первое.
			Мы знаем, что $ \logspace$ функции можно комбинировать и получится тоже $ \logspace$.

			Сейчас находимся в $ \NC^{1}$, поэтому у нас есть семейство схем $ \{C_n\}$, каждая вычисляется с логарифмической памятью.

			Построим композицию трех функций:
			\begin{itemize}
				\item  Первая функция вычисляет схему. Заметим, что эта схема будет логарифмической глубины  (так как мы в $ \NC^{1}$).
				\item Докажем, что эту схему  можно преобразовать в формулу тоже с логарифмической памятью.

					Пусть есть некоторая схема. Склонируем все гейты, которые используются два раза в следующих гейтах. Так как глубина логарифмическая, больше полинома вершин в полученном дереве не окажется.
					\begin{figure}[ht]
						\centering
						\incfig{dag-tree}
						\caption{Схема $\to$ дерево}
						\label{fig:dag-tree}
					\end{figure}
					Научимся делать это формально с $ \logspace$. Запустим dfs от выхода схемы и будем записывать все пути. Заметим, что каждый путь представляет из себя как раз одну из полученных веток с клонированными уникальными гейтами.

					После построения одного пути, начинаем из корня, храним только текущую вершину.
					<<Сам путь нам подскажет, где мы ходили налево, а где еще нет>>\footnote{Тогда уж <<сила подскажет>>, кажется, можно сделать так: храним еще одну примерно $ \log n$-битную переменную, в которой $ i$-й бит равен $ 1$, если на $ i$-ом уровне мы уже ходили в левое поддерево.}.
				\item Теперь вычисляем значение формулы на входе $ x$. Аналогично запускаем dfs, храним текущую вершину и результаты в поддеревьях, когда обошли оба поддерева, поднимемся выше и передадим результат операции гейта.
			\end{itemize}
	\end{enumerate}
\end{proof}

\begin{thm}
    Если $ L$ --- $ \P$-полный, то все параллелизуется
	\[
	L \in  \NC \Longleftrightarrow \P = \NC
	.\] 
\end{thm}
\begin{proof}
	Если $ L' \in \P$, его можно свести к $ L$ ($ \logspace$), а $ L \in \NC$. То есть $ \exists i\colon L \in \NC^{i}$. 

	Логарифмические вычисления мы умеем превращать в параллельные с $ \log^2$, поэтому $ L' \in \NC^{i+2}$.
\end{proof}

\subsection{Замкнутость $\NSpace$ относительно пополнения}
\begin{thm}[Immerman, Szelepcsényi]\index{теорема Иммермана-Клапана}
     $ \STCON \in \coNL$. Альтернативная формулировка $ \overline{\STCON} \in \NL$. 
\end{thm}
    Хотим: недетерменированно с логарифмической памятью принимать те, где нет пути в орграфе
\begin{proof}
	Придумаем такие подсказки, которые будут нас убеждать, что пути между $ s$ и $ t$ нет.

	Пусть $ S_i$ --- множество вершин на расстоянии не более $ i$ от $ s$.

	Сертификат того, что $ x \in S_i$ --- последовательность вершин от $ s $ до $ x$.
	
	Так как подсказки будут в недетерминированной подсказке, память занимать они не будут.

	Теперь посмотрим на такой сертификат \textit{непринадлежности} ($ x \notin S_i$):
	\begin{itemize}[noitemsep]
		\item все вершины  $ S_i$ с сертификатами принадлежности,
		\item размер $ S_i$\footnote{Это тоже нужно сертифицировать и об этом будет написано ниже.}
	\end{itemize}

	Теперь нужно проверить все вершины из $ S_i$, что ни одна из них не совпала с $ x$, и, что их столько, сколько нужно.

	Будем строить сертификат $ \lvert S_i \rvert $ индуктивном:
	\begin{itemize}[noitemsep]
		\item $ \lvert S_{i-1} \rvert $ мы знаем,
		\item переберем все $ u$ и проверим, что  $ u \in S_i$:
			\begin{itemize}[noitemsep]
				\item переберем все $ v $, проверяя $ (v, u) \in E$, и, если такое ребро есть, сертификат принадлежности (то есть путь) для $ v \in S_{i-1}$,
				\item в процессе проверки, подсчитываем количество правленых сертификатов, в итоге должно сойтись с $ \lvert S_{i-1} \rvert $.
			\end{itemize}
			Теперь мы знаем общее число вершин из $ S_{i}$.
	\end{itemize}
	\begin{note}
		Что мы храним? Храним номера вершин и счетчики, поддерживаем простые арифметические операции. Еще нужно хранить обращение к входу (несколько счетчиков для поиска ребер), считаем, что граф записан в нормальном виде, например, как перечисление ребер или матрица смежности.
	\end{note}
\end{proof}

\begin{cor}
	Если $ s(n) = \Omega (\log n)$, то $ \NSpace[s(n)] = \coNSpace[s(n)]$.
\end{cor}
\begin{proof}
	Пусть есть МТ $ M$ для языка из $ \NSpace[s(n)]$. Тогда нас интересует достижимость в графе конфигураций из $ 2^{s(n)}$.

	Только что мы научились проверять достижимость в классе $ \coNL$, то есть доказывать достижимость в классе $ \NL $.
	\[
		\log 2^{s(n)} \approx s(n)
	.\] 
	Поэтому теперь мы можем запустить алгоритм из прошлой теоремы, единственное, что нужно изменить --- теперь не нужно читать граф с входной ленты, а нужно проверять смежность двух конфигураций.
\end{proof}
