\lecture{2}{12 nov}{\dag}
\section{Недетерминированная машина Тьюринга}
\begin{defn}[Недетерминированная машина Тьюринга] \index{машина Тьюринга недетерминированная}
	\selectedFont{Недетерминированная машина Тьюринга} --- машина Тьюринга, допускающая более одной инструкции для данного состояния $ q \in Q$ и $ c_1, \ldots c_k \in \Sigma $, то есть для состояния  $ q $ и символа $ c$ функция  $ \delta $ будет многозначной.
\end{defn}

Из такого определения получаем \selectedFont{дерево вычислений} вместо последовательности состояний ДМТ.

Мы говорим, что НМТ \footnote{недетерминированная машина Тьюринга} \selectedFont{принимает} вход, если существует путь в дереве вычислений, \\ заканчивающийся принимающим состоянием.

\begin{st}
	В машины (ДМТ / НМТ) с заведомо ограниченным временем работы можно встроить \textbf{будильник} и считать время вычислений на входах одной длины всегда \textbf{одинаковым}.
	Для этого можем просто записать на дополнительную ленту $ t(n)$ единиц и стирать по одной за ход. 
\end{st}

\begin{defn}[Эквивалентное определение НМТ]
	\selectedFont{Недетерминированная машина Тьюринга} --- ДМТ, у которой есть дополнительный аргумент -- конечная (ограниченная временем работы) подсказка $ w$ на второй ленте.
\end{defn}


Определённая таким образом НМТ $ M $ принимает вход $ x $, если существует такая подсказка $ w $, что соответствующая ДМТ примет такой вход, т.е. $ M(x, w) = 1 $.

\begin{proof}
	Докажем эквивалентность. 
	\begin{itemize}                                              \item Представим дерево вычисления как бинарное дерево и пронумеруем ребра из каждой вершины $ 0$ и $ 1$. Теперь запишем нужную     принимающую ветку на ленту-подсказку.
	
        По подсказке можем построить дерево, где будет нужный путь.
    \item Обратно: у нас есть ДМТ, которая ожидает вход из самого входа $x$ (который мы знаем -- всегда одинаков) и подсказки $w$.    
        Считаем, что мы знаем оценку верхнюю на длину подсказки. Построим теперь НМТ: бинарное дерево $0$ и $1$.

        Отработав какой-то путь в таком дереве, мы получим возможную подсказку, которую отдадим в качестве $w$ ДМТ. Тогда приниматься будет тогда и только тогда, когда существует подсказка.
    \end{itemize}

\end{proof}
\begin{defn}\index{\NP}
    Еще одно определение класса $ \NP$ --- класс языков, принимаемых полиномиальными по времени НМТ.
\end{defn}
\begin{note}
    Это определение класса $\NP$, можно считать двумя, так как у нас есть два определения НМТ.
\end{note}

\section{Сведения и сводимости}
\begin{defn}[Сведение по Карпу]\index{сведение по Карпу}
	Язык $ L_1$  \selectedFont{сводится по Карпу} к языку $ L_2$, если существует полиномиально вычислимая функция $ f$ такая, что
	\[
		\forall x\colon x \in L_1 \Longleftrightarrow f(x) \in L_2
	.\] 
\end{defn}

\begin{defn}[Сведение по Левину]\index{сведение по Левину}
	Задача поиска (отношение) $ R_1$ \selectedFont{сводится по Левину} к задаче $ R_2$, если существуют функции $ f, g, h$ такие, что для всех  $ x_1, y_1, y_2$ верно
	\begin{itemize}
		\item $ R_1(x_1, y_1) \Longrightarrow R_2(f(x_1), g(x_1, y_1))$;
		\item $ R_1(x_1, h(f(x_1), y_2)) \Longleftarrow R_2(f(x_1), y_2)$;
		\item $ f, g, h$ полиномиально вычислимые.
	\end{itemize}
	\begin{note}
	    Первое условие нужно для того, чтобы образы каждого входа, имеющего решение первой задачи, имели решение и второй задачи.
	\end{note}
\end{defn}

\begin{thm}
	Классы $\P, \NP, \tP, \tNP$ замкнуты относительно этих сведений.
	
	То есть если $R_2 \in \tP, R_1 \to R_2 \Rightarrow R_1 \in \tP$
\end{thm}
\begin{proof}
		Пусть есть два языка или две задачи поиска $ R_1, R_2$, $ R_2$ принадлежит классу $ C \in \{\P, \tP, \NP, \tNP\}$ и $ R_1$ сводится к $ R_2$. Чтобы проверить принадлежность $ R_1 \in C$, нам нужно:
	\begin{itemize}[noitemsep]
		\item Проверить полиномиальную ограниченность и полиномиальную проверяемость, тогда $ R_2$ будет в $ \NP$ или $ \tNP$.
		\item Если $ C \in \{\P, \tP\}$, то еще проверить, что для $ R_1$ есть полиномиальный алгоритм.
	\end{itemize}
	\begin{description}
		\item[Задачи поиска.] 
			$R_2$ задано п.о.п.п. отношением.
			Что можно узнать про $ R_1$? 

			Если есть решение для $ R_1$, то функция $ g$ дает решение $ R_2$, которое не на много длиннее.

			Еще есть $ h$, которая позволяет из решения $ R_2$ обратно быстро построить решение $ R_1$.
			\begin{itemize}
				\item \textbf{Полиномиальная ограниченность.} Пусть есть некоторое решение $ y_1$ для задачи $ R_1$. Для него можно получить некоторое решение $ R_2$ -- $ g(x_1, y_1)$.

			Так как существует \textbf{какое-то} решение $ g(x_1, y_1)$, то (по определению п.о.) есть решение $ y_2$, которое ограничено полиномом. В таком случае его можно перевести в $ h(f(x_1), y_2)$ -- решение для $ R_1$.
			Оно тоже будет ограничено полиномом, так как $ h$ -- полиномиально вычислимо (и как следствие -- полиномиально ограничена).

			    \item \textbf{Полиномиальная проверяемость.}  Проверяется аналогично.
				\item \textbf{Полиномиальный алгоритм.} Если есть алгоритм для $ R_2$ и $ x_1$, сначала перегоняем $ x_1 \to  f(x_1)$, далее применяем алгоритм, получаем $ y_2$, а далее, используя $ h$, перегоняем обратно в $ R_1$.
			\end{itemize}
		\item[Языки.] 
            Пусть есть $L_1 \to L_2$, $L_2 \in C$. 
            \begin{itemize}
                \item $C = \P$. Хотим проверить $x \in L_1$. Сначала можем за полином посчитать $f(x)$, а затем опять за полином проверить $f(x) \in L2$. 
                \item $C = \NP$. У нас есть алгоритм проверки решения для $L_2$ за полином. Так как $L_1 \to L_2$, если $x \in L_1$, то $f(x) \in L_2$, поэтому можем проверить решение в $L_2$.
            \end{itemize}
	\end{description}
\end{proof}
		\begin{st}
	    Если задача $ R_1$ сводится по Левину к $ R_2$, то язык $ L(R_1)$ сводится по Карпу к $ L(R_2)$.
        \end{st}
        \begin{proof}
	    Функция $ f$ для сведения по Карпу будет взята из сведения по Левину. Разберем два случая:
	    \begin{itemize}
		    \item $ x \in L(R_1)$. Тогда мы точно знаем, что есть некоторый $ y_1$, причем $ (x, y_1) \in  R_1$. 
			    Следовательно, по сведению по Левину есть такой $ y_2 = g(x_1, y_1)$, что $ (f(x_2), y_2) \in R_2$. 
			    Значит, $x \in L(R_1) \Longrightarrow  f(x) \in L(R_2)$.
	        \item $x \notin L(R_1)$. Хотим показать, что тогда $ f(x) \notin L(R_2)$. Пусть это не так.
	            Тогда есть некоторый $ y_2$ такой, что $ (f(x), y_2) \in R_2$. 
	            Тогда из сведения по Левину знаем, что $(f(x), h(f(x), y_2)) \in  R_1$ , то есть $x \in  L(R_1)$, противоречие.
	    \end{itemize}
\end{proof}

\begin{defn}[Оракульная МТ]\index{машина Тьюринга оракульная}
	\selectedFont{Оракульная МТ} --- МТ с доступом к оракулу, который за один шаг дает ответ на некоторый вопрос.
\end{defn}
\begin{name}
	При переходе в состояние $ q_{\text{in}}$ происходит <<фантастический переход>> в состояние $ q_{\text{out}}$, заменяющий содержимое некоторой ленты на ответ оракула.

	\noindent$ M^{B}$ --- оракульная машина $ M$, которой дали оракул $ B$. 
\end{name}

\begin{defn}[Сведение по Тьюрингу]\index{сведение по Тьюрингу}
	Язык или задача $ A$ \selectedFont{сводится по Тьюрингу} к $ B$, если существует оракульная машина полиномиальная по времени $ M^{\medblackcircle}$ такая, что $ M^{B}$ решает $ A$.

	\noindent
	Например, если  $ A$ ---  язык, $ A = L(M^{B})$.
\end{defn}
\begin{ex}
	Классы $\P$ и $\tP$ замкнуты относительно сведений по Тьюрингу. А $\NP$ и $\tNP$ могут быть незамкнуты: если $A = \UNSAT,~ B = \SAT$, $ M^{O}(x) = \overline{(x \in O)}$, и $ A$ сводится по Тьюрингу к $ B$, но $ B \in \NP$, a про $ A$ не известно.
\end{ex}

\subsection{Трудные и полные задачи}
\begin{defn}[Трудные и полные задачи]
	Задача $ A$ называется \selectedFont{трудной}\index{трудная задача} для класса $\Class$, если  $ \forall C \in \Class \colon C \to A$.

	\noindent
	Задача $ A$ называется \selectedFont{полной}\index{полная задача} для класса $ \Class$, если она трудная и принадлежит $ \Class$.
\end{defn}
\begin{note}
    Если не упомянуто другое, имеется ввиду сводимость по Карпу.
\end{note}

\begin{thm}
    Если $ A$ --- \NP-трудная и $ A \in \P$, то $ \P = \NP$.
\end{thm}

\begin{cor}
    Если $ A$ --- \NP-полная, то $
    A \in \P \Longleftrightarrow \P = \NP
    $. 
\end{cor}


\subsubsection{Задача об ограниченной остановке}
\begin{defn}[\BH]\index{\BH, задача об ограниченной подстановке}
	Определим задачу об ограниченной остановке $ \tBH(\langle M, x, 1^{t} \rangle, w)$ \footnote{здесь $ 1^{t}$ --- служебные $ t$ единиц, ограничивающие время работы МТ} так:
	дана НМТ $ M$ и вход $ x$, требуется найти такую подсказку $ w$, чтобы $ M$ распознавала $ x$ не более чем за $ t$ шагов.

	\noindent
	Соответствующая задача распознавания --- ответить, существует ли такая подсказка.
    \end{defn}
\begin{thm}
    Задача об ограниченной остановке $ \tNP$-полная, а соответствующий язык \NP-полный.
\end{thm}
\begin{proof}
	\begin{itemize}
		\item Принадлежность $ \tNP$ и $ \NP$ следует из существования универсальной ДМТ, которая за $ \O(t \log t)$ промоделирует вычисление ДМТ, описание которой дано ей на вход. 
		После этого нужно проверить, что $M$ успевает за $t$ шагов закончить.
		\item Проверим, что язык  $ \NP$-трудный.
			Пусть  язык $ L$ принадлежит $ \NP$. По определению $\NP$ существует для соответствующего отношения $ R$ машина Тьюринга $ M^{*}(x, w)$, которая работает за $ p(\lvert x \rvert )$ -- полином.

			Сведем $ L$ к задаче $ \BH$. Рассмотрим тройку $ \langle M^{*}, x, 1^{p(\lvert x \rvert )} \rangle$. 
			Пусть функция $ f(x)$ будет равна этой тройке.

		  В таком случае условие распознавание тройки равносильно тому, что $ x$ из языка $L(M^*)$
		\item Аналогично для задач поиска.
    \end{itemize}
\end{proof}

\subsection{Булевы схемы}
\begin{defn}[Булева схема]\index{булевы схемы}
	\selectedFont{Булева схема} --- ориентированный граф  без циклов, в вершинах которого записаны бинарные, унарные или нульарные операции над битами ($ \wedge, \vee, \oplus$), при этом есть специальные вершины-входы и вершины-выходы.
\end{defn}
\begin{defn}[\CircuitSat]\index{\CircuitSat}
	\[
		\tCircuitSat = \{(C, w) \mid C\text{ --- булева схема}, C(w) = 1\}
	.\] 
	Соответственно, $ C \in \CircuitSat$, если существует такой вход $w$, что схема возвращает $1$.
\end{defn}
Очевидно, что $ \CircuitSat \in \NP$.
Чтобы доказать $ \NP$-трудность, сведем $ \BH \to \CircuitSat$:
будем рисовать конфигурацию МТ на схемах.
\begin{itemize}
	\item Пусть каждый этаж схемы --- конфигурация ДМТ.     Всего этажей будет столько же, сколько шагов в МТ, то есть $ t$. Если в последнем этаже $ q_{acc}$, то результат $ 1$.
	\item \textbf{Пересчет конфигураций.} Заметим, что при переходе от одной конфигурации к другой меняются только гейты рядом с положением головки. 
	
	    Выделим подсхему, которая должна по состоянию и элементу рядом с головкой получить новое состояние, положение головки и поменять элемент, а остальные символы скопировать. Так мы построим новый уровень с измененными элементами.

	    Для хранения головки будем после каждого символа с ленты хранить $ d_i $ равное единице, если головка на символе $ c_i$ перед ним.

		Если $ d_i = 0$, то новый $ c_i' = c_i$, иначе нужно заменить   $ c_i$ на $ c_i'$ из программы МТ:
		\[
			(q, c_{i-1}, c_i, c_{i+1}, d_{i-1}, d_i, d_{i+1}) \mapsto (q', c_i', d_i') 
		.\] 
	\item Так как входная строка $ x$ нам дана, <<запаяем>> ее в схему: подключим входные гейты с элементами $x$ к нужным входам.
	
	    Тогда оставшимся входом схемы останется подсказка $ w$ для НМТ, а выходом --- попадание в $ q_{acc}$.
\end{itemize}
Таким образом, мы по $\langle M, x, t \rangle$ построили схему $ C(w)$.
