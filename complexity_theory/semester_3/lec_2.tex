\lecture{2}{12 nov}{\dag}
\section{Недетерминированная машина Тьюринга}
\begin{defn}[Недетерминированная машина Тьюринга] \index{машина Тьюринга недетерминированная}
	\selectedFont{Недетерминированная машина Тьюринга} --- машина Тьюринга, допускающая более одной инструкции для данного состояния $ q \in Q$ и $ c_1, \ldots c_k \in \Sigma $, то есть для состояния  $ q $ и символа $ c$ функция  $ \delta $ будет многозначной.
\end{defn}

Из такого определения получаем \selectedFont{дерево вычислений} вместо последовательности состояний ДМТ.

Мы говорим, что НМТ \footnote{недетерминированная машина Тьюринга} \selectedFont{принимает} вход, если существует путь в дереве вычислений, \\ заканчивающийся принимающим состоянием.

\begin{st}
	В машины (ДМТ / НМТ) с заведомо ограниченным временем работы можно встроить \textbf{будильник} и считать время вычислений на входах одной длины всегда \textbf{одинаковым}.
	Для этого можем просто записать на дополнительную ленту $ t(n)$ единиц и стирать по одной за ход. 
\end{st}

\begin{defn}[Эквивалентное определение НМТ]
	\selectedFont{Недетерминированная машина Тьюринга} --- ДМТ, у которой есть дополнительный аргумент (конечная (ограниченная временем работы) подсказка $ w$ на второй ленте).
\end{defn}

Определённая таким образом НМТ $ M $ принимает вход $ x $, если существует такая подсказка $ w $, что соответствующая ДМТ примет такой вход, т.е. $ M(x, w) = 1 $.

\begin{proof}
	Докажем эквивалентность. 
	\begin{itemize}                                              \item Представим дерево вычисления как бинарное дерево и пронумеруем ребра из каждой вершины $ 0$ и $ 1$. Теперь запишем нужную     принимающую ветку на ленту-подсказку.
	
        По подсказке можем построить дерево, где будет нужный путь.
    \item Обратно: у нас есть ДМТ, которая ожидает вход из самого входа $x$ (который мы знаем -- всегда одинаков) и подсказки $w$.    
        Считаем, что мы знаем оценку верхнюю на длину подсказки. Построим теперь НМТ: бинарное дерево $0$ и $1$.

        Отработав какой-то путь в таком дереве, мы получим возможную подсказку, которую отдадим в качестве w ДМТ. Тогда приниматься будет тогда и только тогда, когда существует подсказка.
    \end{itemize}

\end{proof}
\begin{defn}\index{\NP}
    Еще одно определение класса $ \NP$ --- класс языков, принимаемых полиномиальными по времени НМТ.
\end{defn}

\section{Сведения и сводимости}
\begin{defn}[Сведение по Карпу]\index{сведение по Карпу}
	Язык $ L_1$  \selectedFont{сводится по Карпу} к языку $ L_2$, если существует полиномиально вычислимая функция $ f$ такая, что
	\[
		\forall x\colon x \in L_1 \Longleftrightarrow f(x) \in L_2
	.\] 
\end{defn}

\begin{defn}[Сведение по Левину]\index{сведение по Левину}
	Задача поиска (отношение) $ R_1$ \selectedFont{сводится по Левину} к задаче $ R_2$, если существуют функции $ f, g, h$ такие, что для всех  $ x_1, y_1, y_2$ верно
	\begin{itemize}
		\item $ R_1(x_1, y_1) \Longrightarrow R_2(f(x_1), g(x_1, y_1))$;
		\item $ R_1(x_1, h(f(x_1), y_2)) \Longleftarrow R_2(f(x_1), y_2)$;
		\item $ f, g, h$ полиномиально вычислимые.
	\end{itemize}
	\begin{note}
	    Первое условие нужно для того, чтобы образы каждого входа, имеющего решение первой задачи, имели решение и второй задачи.
	\end{note}
\end{defn}

\begin{thm}
	Классы $\P, \NP, \tP, \tNP$ замкнуты относительно этих сведений.
	
	То есть если $R_2 \in \tP, R_1 \to R_2 \Rightarrow R_1 \in \tP$
\end{thm}
\begin{proof}
	Рассмотрим $ R_2 \in \tP$ и $ R_1 \to R_2$. Тогда должно выполняться $ R_1 \in \tP$. Аналогично для $ \tNP$. 
    В обоих случаях $ R_2$ задано п.о.п.п. Если говорим про $ \tP$, то еще есть алгоритм, работающий за полиномиальное время.

	Что можно узнать про $ R_1$? Если есть решение для $ R_1$, то функция $ g$ дает решение $ R_2$, которое не на много длиннее.
	Еще есть $ h$, которая позволяет построить из решения $ R_2$ обратно построить решение $ R_1$.
	\begin{itemize}
		\item Пусть есть некоторое решение $ y_1$ для задачи $ R_1$. Для него можно получить некоторое решение $ R_2$ -- $ g(x_1, y_1)$.

	Так как $ R_2$ полиномиально ограничено, для него есть полиномиальное решение поменьше. Поэтому, когда оно будет возвращено функцией $ h$, исходное решение $ y_2$ тоже окажется коротким.

		\item Полиномиальная проверяемость проверяется аналогично.

		\item Про алгоритм: если есть алгоритм для $ R_2$ и $ x_1$, сначала перегоняем $ x_1 \to  f(x_1)$, далее применяем алгоритм, получаем $ y_2$, а далее, используя $ h$, перегоняем обратно в $ R_1$.
	\end{itemize}
\end{proof}

\begin{defn}[Оракульная МТ]\index{машина Тьюринга оракульная}
	\selectedFont{Оракульная МТ} --- МТ с доступом к оракулу, который за один шаг дает ответ на некоторый вопрос.
\end{defn}
\begin{name}
	При переходе в состояние $ q_{\text{in}}$ происходит <<фантастический переход>> в состояние $ q_{\text{out}}$, заменяющий содержимое некоторой ленты на ответ оракула.

	\noindent$ M^{B}$ --- оракульная машина $ M$, которой дали оракул $ B$. 
\end{name}

\begin{defn}[Сведение по Тьюрингу]\index{сведение по Тьюрингу}
	Язык или задача $ A$ \selectedFont{сводится по Тьюрингу} к $ B$, если существует оракульная машина полиномиальная по времени $ M^{\medblackcircle}$ такая, что $ M^{B}$ решает $ A$.

	\noindent
	Например, если  $ A$ ---  язык, $ A = L(M^{B})$.
\end{defn}
\begin{ex}
	Классы $\P$ и $\tP$ замкнуты относительно сведений по Тьюрингу. А $\NP$ и $\tNP$ могут быть незамкнуты: если $A = \UNSAT,~ B = \SAT$, $ M^{O}(x) = \overline{(x \in O)}$, и $ A$ сводится по Тьюрингу к $ B$, но $ B \in \NP$, a про $ A$ не известно.
\end{ex}

\subsection{Трудные и полные задачи}
\begin{defn}[Трудный и полные задачи]
	Задача $ A$ называется \selectedFont{трудной}\index{трудная задача} для класса $\Class$, если  $ \forall C \in \Class \colon C \to A$.

	\noindent
	Задача $ A$ называется \selectedFont{полной}\index{полная задача} для класса $ \Class$, если она трудная и принадлежит $ \Class$.
\end{defn}

\begin{thm}
    Если $ A$ --- \NP-трудная и $ A \in \P$, то $ \P = \NP$.
\end{thm}
\begin{cor}
    Если $ A$ --- \NP-полная, то $
    A \in \P \Longleftrightarrow \P = \NP
    $. 
\end{cor}

\subsubsection{Задача об ограниченной остановке}
\begin{defn}[\BH]\index{\BH, задача об ограниченной подстановке}
	Определим задачу об ограниченной остановке $ \tBH(\langle M, x, 1^{t} \rangle, w)$ \footnote{здесь $ 1^{t}$ --- служебные $ t$ единиц} так:
	дана НМТ $ M$ и вход $ x$, требуется найти такую подсказку $ w$, чтобы $ M$ распознавала $ x$ не более чем за $ t$ шагов.

	\noindent
	Соответствующая задача распознавания --- ответить, существует ли такая подсказка.
\end{defn}
\begin{thm}
    Задача об ограниченной остановке $ \tNP$-полная, а соответствующий язык \NP-полный.
\end{thm}
\begin{proof}
	\begin{itemize}
		\item Принадлежность $ \tNP$ и $ \NP$ следует из существования универсальной ДМТ, которая за $ \O(t \log t)$ промоделирует вычисление ДМТ, описание которой дано ей на вход.
		\item Проверим, что язык  $ \NP$-трудный.
			Пусть  язык $ L$ принадлежит $ \NP$, что равносильно существованию для соответствующего отношения $ R$ машины Тьюринга $ M^{*}(x, w)$, которая работает за $ \poly(\lvert x \rvert )$.

			Сведем $ L$ к задаче $ \BH$. Рассмотрим тройку $ \langle M^{*}, x, 1^{\poly(\lvert x \rvert )} \rangle$. 
			Пусть функция $ f(x)$ будет равна этой тройке.

			Если и только если существует подсказка $ w$ для тройки $ f(x) $ принадлежит $ \BH$, а наш язык $ L$ и определяется машиной $ M^{*}$. 
		\item Аналогично для задач поиска.
    \end{itemize}
\end{proof}

\subsection{Булевы схемы}
\begin{defn}[Булева схема]\index{булевы схемы}
	\selectedFont{Булева схема} --- ориентированный граф  без циклов,в вершинах которого записаны бинарные, унарные или нульарные операции над битами ($ \wedge, \vee, \oplus$), при этом есть специальные вершины-входы и вершины-выходы.
\end{defn}
\begin{defn}[\CircuitSat]\index{\CircuitSat}
	\[
		\tCircuitSat = \{(C, w) \mid C\text{ --- булева схема}, C(w) = 1\}
	.\] 
\end{defn}
Очевидно, что $ \CircuitSat \in \NP$.
Чтобы доказать $ \NP$-трудность, сведем $ \BH \to \CircuitSat$:
будем рисовать конфигурацию МТ на схемах.
\begin{itemize}
	\item Пусть каждый этаж системы --- конфигурация ДМТ. Всего этажей будет столько же, сколько шагов в МТ, то есть $ t$. Если в последнем этаже $ q_{acc}$, то результат $ 1$.
	\item Пересчет конфигураций: меняются только гейты рядом с положением головки. Выделим подсхему, которая должна по состоянию и элементу рядом с головкой получить новое состояние, положение головки и поменять элемент, то есть построить новый уровень с измененными элементами.

		Для хранения головки будем после каждого символа с ленты хранить $ d_i $ равное единице, если головка на символе $ c_i$ перед ним.

		Если $ d_i = 0$, то новый $ c_i' = c_i$, иначе нужно заменить   $ c_i$ на $ c_i'$ из программы МТ:
		\[
			(q, c_{i-1}, c_i, c_{i+1}, d_{i-1}, d_i, d_{i+1}) \mapsto (q', c_i', d_i') 
		.\] 
	\item Так как входная строка $ x$ нам дана, запаяем ее в схему. Тогда входом схемы останется подсказка $ w$ для НМТ, а выходом --- попадание в $ q_{acc}$.
\end{itemize}
Таким образом, мы по $ M, x, t$ построили схему $ C(w)$.
