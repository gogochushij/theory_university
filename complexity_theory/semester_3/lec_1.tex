\chapter{Введение в теорию сложности вычислений}
\lecture{1}{5 nov}{\dag}

\section{Машины Тьюринга}
\subsection{Напоминания}
Обсудим, что мы решаем.
\begin{name}
	~\begin{itemize}[noitemsep]
		\item Алфавит будет бинарный  $\{0, 1\}$;
		\item Множество всех слов длины $ n$ : $ \{0, 1\}^{n}$;
		\item Множество всех слов конечной длины  $ \{0, 1\}^{*}$;
		\item Длина слова $ x\colon  \lvert x \rvert $.
	\end{itemize}
\end{name}

\begin{defn}
    \noindent
    \selectedFont{Язык}\index{язык} (задача распознавания, decision problem) ---  $ L \subseteq \{0, 1\}^{*}$.
	
    \noindent
    \selectedFont{Индивидуальная задача}\index{индивидуальная задача} --- пара,
	первым элементом которой является условие, а второй~-- решение;
	принадлежит $ \{0, 1\}^{*} \times \{0, 1\}^{*}$.
	
	\noindent
	\selectedFont{Массовая задача}\index{массовая задача} --- некоторое множество индивидуальных задач, то есть бинарное отношение на $ \{0, 1\}^{*}$.
\end{defn}

\begin{defn}
	Будем говорить, что алгоритм \selectedFont{решает задачу поиска} для массовой задачи $ R$, если для условия $ x$ он находит решение $ w$, удовлетворяющее $ (x, w) \in R$.

	\noindent
	Можем сопоставить массовой задаче, заданной отношением $ R$, язык
	\[
		L(R) = \{x \mid \exists w\colon (x, w) \in R\}
	.\]
\end{defn}

\begin{ex}[Массовая задача и соответствующий язык]
	\[
		\FACTOR = \{(n, d) \mid d | n, ~ 1<d<n\}
	.\]
	Здесь условием задачи является натуральное число  $ n$, а решением некоторый (не 1, и не $ n$) делитель числа $ n$.

	Данной задаче соответствует язык
	\[
		L(\FACTOR) = \text{множество всех составных чисел}
	.\]
\end{ex}

\subsection{Детерминированная машина Тьюринга}
\begin{defn}[Детерминированная машина Тьюринга]
	\selectedFont{Детерминированная машина Тьюринга}\index{машина Тьюринга детерминированная} ---
	\begin{itemize}[noitemsep]
		\item конечный алфавит (с началом ленты и пробелом): $ \Sigma  = \{0, 1, \triangleright, \_\}$;
		\item несколько лент, бесконечных в одну сторону;
		\item читающие/пишущие головки, по одной на каждую ленту;
		\item конечное множество состояний, в том числе начальное ($ q_S$/$q_0$), принимающее ($ q_Y $/$ q_{acc}$) и отвергающее ($ q_N$/$ q_{rej}$);
		\item управляющее устройство (программа), содержащее для каждых $ q, c_1, \ldots c_k$ одну инструкцию вида
			\[
				(q, c_1, \ldots c_k) \mapsto (q', c_1', \ldots c_k', d_1, \ldots d_k)
			,\]
			где $ q, q' \in Q$ --- состояния, $ c_i, c_i' \in \Sigma $ --- символы, обозреваемые головками, $ d_i \in \{ \to , \leftarrow, \cdot  \}$ --- направления движения головок.
	\end{itemize}

	ДМТ \selectedFont{принимает} входное слово, если заканчивает работу в $ q_{acc}$, и \selectedFont{отвергает}, если заканчивает в $ q_{rej}$.

	ДМТ $ M$ \selectedFont{распознает язык $ A$}, если принимает все $ x \in A$ и отвергает все $ x \not\in A$.
	\[
		A = L(M)
	.\]
\end{defn}
\begin{note}
	Обычно есть отдельная лента только для чтения, куда записаны входные данные, \\
	и лента только для вывода, куда нужно поместить ответ. Остальные ленты будут рабочими.
\end{note}
\begin{note}
	Изначально на входной ленте вход и пробелы, на остальных пробелы, головки в крайней левой позиции, а состояние есть $ q_s$.
\end{note}

\begin{defn}
	\selectedFont{Время работы  машины } \index{время работы МТ} $ M$ на входе $ x$ --- количество шагов (применений инструкций) \\ 
	до  достижения $ q_{acc}$ или $ q_{rej}$.

	\noindent
	\selectedFont{Используемая память} \index{используемая память} --- суммарное крайнее правое положение всех головок на \textit{рабочих} лентах.
\end{defn}

\begin{thm}\label{th:two_bands}
	Для любого $ k \in \N$, работу ДМТ  $ M$ с $ k$ рабочими лентами, работающую $ t$ шагов, можно  промоделировать на  ДМТ с двумя рабочими лентами за время  $ \O(t \log t)$,
	где константа $ \O(\ldots) $ зависит только от размеров записи машины $ M$.
\end{thm}
\begin{proof}
	\begin{itemize}
		\item
			Перестроим исходную МТ:
			\begin{itemize}
				\item Запишем все ленты в одну строку  по символу из всех лент по очереди.
				\item  Будем бегать <<лентой по головке>>: выровняем все ленты, чтобы головки стояли друг над  другом и далее будем сдвигать нужную ленту.
				\item Заметим, что двустороннюю ленту можно смоделировать на односторонней, причем
				с увеличением количества операций в константу раз: \\
				разрезаем двустороннюю пополам и записываем элементы через один.
			\end{itemize}
			\begin{figure}[ht]
				\centering
				\incfig{two-bands}
				\caption{Построение новой МТ}
				\label{fig:two-bands}
			\end{figure}
		\item
			Теперь поймем, как экономично сдвигать ленты в однострочной записи.

			Разобьем строку на блоки начиная от позиции головки в две стороны: справа блоки $ R_i$, слева $ L_i$. При этом $ \lvert L_i \rvert = \lvert R_i \rvert  = 2^{i}$. Раздвинем символы, заполняя пустоту специальными символами пустоты, так, чтобы в каждом блоке ровно половина элементов были пустыми.

			Далее будем поддерживать такое условие:
			\begin{enumerate}[noitemsep]
				\item В блоке либо информация, либо пусто, либо наполовину (ровно) пусто
				\item $ L_i$ пустой, когда  $ R_i$ полный
				\item  $ L_i$ наполовину пустой, когда $ R_i$ наполовину полный
				\item $ L_i$ полный, когда $ R_i$ пустой
			\end{enumerate}

			Пусть нужно подвинуть головку влево. Найдем слева первый не пустой блок $ L_i$. Возьмем из него правую половину и разложим по пустым $ L_{<i}$ так, чтобы порядок сохранился и каждый из $ L_{<i}$ стал полупустым, а первый символ попал под головку.

			Так получится сделать, так как всего перемещаемых символов $ 2^{i-1}$, а в $ j$-й блок будет помещено $ 2^{j-1}$ символов, поэтому всего в $ L_{<i}$ поместится
			\[
				1 + 2 + 4 + \ldots + 2^{i-2} = 2^{i-1} - 1
			.\]
			И один символ под головку.

			Чтобы инвариант сохранился нужно теперь исправить правую часть.

			Так как первые $ i-1$ левых блоков были пусты, первые $ i-1$ правых блоков полны, а $ R_i$ пуст (либо наполовину полон, в зависимости от первоначального состояния $ L_i$).
			Заполним половину в $ R_i$ символами из $ R_{i-1}$.
			Теперь $ R_{i-1}$ пустой, а меньшие полные. Проделаем ту же операцию еще раз для $ i-1$, потом для $ i-2$ и так далее. Заметим, что по отношению к $ R_i$ все сохранилось: если $ L_i$ был наполовину полон, то стал пуст, а $ R_i$ - полон (так как до этого  был наполовину полон). Полностью аналогичный случай, если бы $ L_i$ был полон.

			Когда мы дойдем до $ R_1$, положим туда элемент из-под головки.

			Итого, инвариант  сохранился.
			\begin{figure}[ht]
				\centering
				\incfig{blocks}
				\caption{Структура блоков}
				\label{fig:blocks}
			\end{figure}
		\item Посчитаем количество операций. В алгоритме переносим различные отрезки из одного места в другое. Чтобы делать это за линию, сначала скопируем нужный участок на вторую ленту, а затем запишем с нее.

			Тогда при перераспределении происходит $ c\cdot 2^{i}$ операций: \\ 
			каждый символ переносили константное число раз (на вторую ленту, со второй ленты)  плюс линейное перемещение от $ L_i$ к $ R_i$ несколько раз (символов всего $ 2^{i - 1}$ в каждой половине, итого суммарно перенесли $ 2^i$ символов).

			Докажем, что с $ i$-м блоком происходят изменения не чаще $ 2^{i-1}$  шагов. Пусть $ L_i$ хотя бы наполовину заполнен. Когда мы забрали половину из него, мы заполнили все $ L_{<i}$ и $ R_{<i}$ наполовину.

			Поэтому, чтобы изменить $ L_i$ еще раз, нужно сначала опустошить все $ L_{<i}$.
			При перераспределении в левой части становится на один элемент меньше, а всего там $ 2^{i-1}$ заполненное место. Для того, чтобы все они ушли из левой половины, придется совершить $ 2^{i-1}$ сдвигов.

			Итого, для $ t$ шагов исходной машины будет
			\[
				\sum_{i}^{\log t}c\cdot 2^{i} \cdot \frac{t}{2^{i-1}} = \O(t \log t)
			.\]
			Почему сумма до логарифма? Заметим, что так как мы сделали не более чем $ t$ шагов изначально, то мы не можем на каждой ленте занять более чем $ t$ ячеек. В таком случае, самый большой блок не будет больше $ t$. А его индекс, соответственно не будет больше, чем $ \log t$.
			\begin{note}
			Так как до этого у нас было k лент и все сдвиги делались одновременно, то здесь мы делаем сдвиг каждой ленты по очереди. То есть на самом деле мы получаем $ \O(k \cdot t \log t)$, но $ k$ в данном случае просто константа (почти точно константа может стать намного больше, чем $ k$, но всё равно останется константой). 
			\end{note}
	\end{itemize}
\end{proof}

\begin{thm}[Об универсальной МТ]
	Существует ДМТ $ U$, выдающая на входе $(M, ~ x)$ тот же результат, что дала бы машина $ M$ на входе $ x$, за время $ \O(t \log t)$, где $ t $ --- время работы $ M$ на входе $ x$.
\end{thm}
\begin{proof}
	Используем прием из прошлой теоремы \ref{th:two_bands}.
\end{proof}

\begin{note}
	Единственный способ узнать результат машины $M$ на строке $x$, это промоделировать вычисление машины $M$ на входе. Мы никогда не можем заранее сказать результат этого вычисления, и заканчивается ли оно вообще. Поэтому, моделировать вычисления (т.е. иметь универсальную машину Тьюринга) можно, но, например, нельзя иметь машину, которая по записи машины $M'$ скажет, принимает ли $M'$ пустую строку, можно лишь повести себя как $M'$ на пустой строке.
\end{note}

\section{Классы сложности}
\subsection{Классы $\DTIME$ и $\P$}

\begin{defn}[Конструируемая по времени функция]\index{конструируемая по времени функция}
	Функция $ t\colon \N \to  \N$ называется \selectedFont{конструируемой по времени}, если
	\begin{itemize}[noitemsep]
		\item $ t(n) \ge n$;
		\item двоичную запись  $ t(\lvert x \rvert )$ можно найти по входу $ x$ на ДМТ за  $ t(\lvert x \rvert )$ шагов.
	\end{itemize}
\end{defn}

\begin{note}
    Все стандартные функции (многочлены, экспоненты) конструируемы по времени. 
    
    Неконструируемыми являются вырожденные, специально построенные случаи.
\end{note}

\begin{defn}[Класс $\DTIME$]\index{$\DTIME$}
	Язык $ L$ принадлежит классу $ \DTIME[t(n)]$, если существует ДМТ $ M$, принимающая $ L$ за время $ \O(t(n))$, где $ t$ конструируема по времени.

	\noindent
	Константа может зависеть от языка, но не от длины входа.
\end{defn}

\begin{defn}[Класс $\P$]\index{$\P$}
	Класс языков, распознаваемых за полиномиальное время на ДМТ ---
	\[
		\P = \bigcup_{c}^{} \DTIME[n^{c}]
	.\]
\end{defn}
Будем обозначать задачи, заданные отношениями волной.

\begin{defn}
	Массовая задача $ R$ \selectedFont{полиномиально ограничена}\index{полиномиально ограниченная задача}, если существует полином $ p$, ограничивающий длину кратчайшего решения:
	\[
		\forall x ~ \Bigl( \exists u \colon (x, u) \in  R \Longrightarrow \exists w \colon \bigl( (x, w) \in R \wedge \lvert w \rvert \le p(\lvert x \rvert )\bigr)\Bigr)
	.\]
	Массовая задача $ R$ \selectedFont{полиномиально проверяема}\index{полиномиально проверяемая задача}, если существует полином $ q$, ограничивающий время проверки решения: для любой пары $ (x, w)$ можно проверить принадлежность $ (x, w) \stackrel{?}{\in} R$ за время $ q(\lvert (x, w) \rvert )$.
\end{defn}
\begin{defn}[Класс $ \tNP$]\index{$ \tNP$}
	$ {\tNP}$ --- класс задач поиска, задаваемых полиномиально ограниченными полиномиально проверяемыми массовыми задачами.
\end{defn}
\begin{defn}[Класс $ \tP $]\index{$\tP$}
	$ { \tP} $ --- класс задач поиска из $ { \tNP} $, разрешимых за полиномиальное время.

	\noindent
	То есть класс задач поиска, задаваемых отношениями $ R$, что для всех $ x \in \{0, 1\}^{*}$ за полиномиальное время можно найти $ w$, для которого $ (x, w) \in  R$.
\end{defn}
\[
	\boxed{\text{Ключевой вопрос теории сложности } { \tP}  \stackrel{?}{=} { \tNP}}
\]
\begin{defn}[Класс $\NP$]\index{$\NP$}
	$ \NP$~---  класс языков (задач распознавания),  задаваемых полиномиально ограниченными полиномиально проверяемыми массовыми задачами:
	\[
		\NP = \{L(R) \mid R \in { \tNP} \}
	.\]
\end{defn}
\begin{note}
	$ L \in \NP$, если существует массовая п.о.п.п.\footnote{полиномиально ограниченная полиномиально проверяемая} задача, такая, что
	\[
		\forall x \in \{0, 1\}^{*} \colon  x \in L \Longleftrightarrow \exists w \colon (x, w) \in R
	.\]
\end{note}

\begin{defn}[Класс $\P$]\index{\P}
	\P --- класс языков (задач распознавания), распознаваемых за полиномиальное время.
	\[
		\P = \{L(R) \mid R \in \tP\}
	.\]
\end{defn}
\begin{note}
	Очевидно, $ \P \subseteq \NP$.
\end{note}
\[
	\boxed{\text{Ключевой вопрос теории сложности } { \P}  \stackrel{?}{=} { \NP}}
\]
