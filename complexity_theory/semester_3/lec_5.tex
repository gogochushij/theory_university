\lecture{5}{3 dec}{\dag}

\begin{thm}[Карп-Липтон]\index{теорема Карпа-Липтона}
    $ \NP \subseteq \Ppoly \Longrightarrow \PH = \SIGMA^2\P$.
\end{thm}
\begin{proof}
    Покажем, что $ \SIGMA^3\P$-полный язык лежит в $ \SIGMA^2\P$.  Тогда все следующие классы тоже схлопываются.
	Мы знаем $ \SIGMA^3\P$-полный язык
	\[
		\QBF_3 = \{F \text{ --- формула в КНФ} \mid  \exists x \forall y \exists z ~ F(x, y, z)\}
	.\] 
	Докажем, что он лежит в $ \SIGMA^2\P$.

	Заметим, что корректность некоторой схемы $ G \in \SAT$ можно проверить так: сначала подставим в первую переменную $ 0$, 
	а потом $ 1$ и проверим полученные схемы.
	Исходная корректна, согда хотя бы одна из полученных корректна.
	
	Можно записать это так:
	\[
		\forall G \colon C_{\lvert G \rvert } = C_{\lvert G[x_1 \coloneqq 0] \rvert }\left( G[x_1\coloneqq 0] \right) \vee C_{\lvert G[x_1\coloneqq 1] \rvert }\left( G[x_1\coloneqq 1] \right) 
	.\] 

	Хотим доказать, что $ \QBF_3$ можно уложить в два квантора. Сделаем это следующим образом:
	\[
	\begin{aligned}
		\left( \exists x \forall y \exists z ~ F \right) \in \QBF_3 &\Longleftrightarrow \\
		& \exists \text{ схемы } C_1, \ldots C_{\lvert F \rvert } \text{ размера, ограниченного полиномом} \\
		& \exists x \\
		& \forall y \\
		& \forall G \text{ --- булева формула длина не более } \lvert F \rvert \\
		& \left( \text{семейство } \{C_i\} \text{ корректно для } G\right)  \wedge C_{\lvert F \rvert }(F(x, y, z)) = 1
	\end{aligned}
	\]
	Такая запись принадлежит $ \SIGMA^2\P$.
	\begin{note}
	    $\NP \subseteq \Ppoly$ используем, когда проверяем схему из $\SAT$ за полином.
	\end{note}
\end{proof}

\subsection{Схемы фиксированного полиномиального размера}

\begin{thm}
	$ \forall k\colon \SIGMA^{4}\P \nsubseteq \Size[n^{k}]$
\end{thm}
\begin{proof}
    Заметим, что существует функция $ f\colon \{0, 1\}^{n} \to  \{0, 1\}$, зависящая только от первых $ c\cdot k\cdot \log n$ битов, для которой нет булевой схемы размера $ n^{k}$, так как всего функций с ограничением на биты $ 2^{2^{c\cdot k\cdot \log n}}$, а схем $ \O(2^{n^{k}\log n})$ (для каждого из $n^k$ гейтов нужно задать два числа, каждое задается $\log n^k = \O(\log n)$).

Найдем такую в $ \SIGMA^{4}\P$:
\[
	\begin{aligned}
		y \in L &\Longleftrightarrow \exists f ~ \forall c \text{ (схемы размера $ n^{k} $) } \forall f'~  \exists x \exists c' \text{ (схема размера $ n^{k}$) } \forall x'\colon \\
				&\underbrace{f(x) \ne c(x)}_{\text{не принимается схемой}} \wedge \underbrace{\left( (f < f') \vee f'(x') = c'(x')
\right) }_{\text{лексикографически первая $ f$ }} \wedge  \underbrace{\left( f(y)=1 \right) }_{\text{значение}}
	\end{aligned}
\] 
Все кванторы имеют полиномиальные размеры.
\end{proof}
\begin{cor}
	$ \forall k\colon \SIGMA^{2}\P \cap \PI^2\P \nsubseteq \Size[n^{k}]$\footnote{Здесь берется пересечение, так как схемам все равно, выдавать $ 0$ или $ 1$}.
\end{cor}
\begin{proof}
	Пусть $ \SIGMA^{2}\P \cap \PI^2\P \subseteq \Size[n^{k}]$. Тогда $ \NP \subseteq \Ppoly$, поэтому можно применить теорему Карпа-Липтона:
	\[
		\PH = \SIGMA^2 \P \cap \PI^2\P \subseteq \Size[n^{k}]
	.\] 
	Но $ \SIGMA^{4}\P \subseteq \PH \subseteq \Size[n^{k}]$. Противоречие. 
\end{proof}

\subsection{Класс $ \NSpace$}
\begin{defn}[$ \NSpace$]\index{\NSpace}
	$ \NSpace[f(n)] = \{L \mid L \text{ принимается НМТ с памятью } \O(f(n))\}$.
\end{defn}
\begin{note}
	~\begin{itemize}
		\item  $ f(n)$ должна быть конструируемая по памяти;
		\item входная лента \readonly, выходная лента \writeonly, память на них не учитывается;
		\item \textbf{ленту подсказки} можно читать только слева направо.
    \end{itemize}
\end{note}
\index{\NPSPACE}
\[
	\NPSPACE = \bigcup_{k \ge 0} \NSpace[n^{k}]
.\] 

\section{Логарифмическая память}
\begin{defn}\index{\STCON}
	$ \STCON = \{(G, s, t) \mid  G \text{ --- ориентированный граф}, ~ \exists ~ s \rightsquigarrow t\}$.
\end{defn}
\begin{lm}
	$ \STCON \in \DSpace[\log ^2 n]$.
\end{lm}
\begin{proof}
    Будем делить путь пополам и искать путь от начала до середины и от середины до конца.
    
	Пусть $ \PATH(x, y, i)$ равно $ 1$, если есть путь из $ x$ в $ y$ длины не более $ 2^{i}$.
	\[
	\begin{aligned}
		&\PATH(x, y, 0) &&= (x, y) \in E \\
		&\PATH(x, x, 1) &&= 1 \\
		&\PATH(x, y, i) &&= \bigvee_{z} \left( \PATH(x, z, i-1) \wedge \PATH(z, y, i-1) \right) 
	\end{aligned}
	\]
	Перебираем промежуточную вершину. Будем хранить <<задания>> (пары, для которых проверяем путь) в стеке. Достаем оттуда одно <<задание>> и заменяем его на два меньших. Когда-то мы либо найдем $ 1$, тогда нужно вернуться к проверке второй половины, либо $ 0$, тогда нужно перейти к следующей промежуточной вершине, так как с текущей пути нет.
	
	Чтобы получить ответ, посчитаем $\PATH(s, t, \log \lvert V \rvert)$.

	Оценим память: на счетчик промежуточных вершин и на стек нужен логарифм. Тогда всего не более $ \log^2 n$. 
\end{proof}

\begin{thm}
	$ \NSpace[f(n)] \subseteq \DSpace[f^2(n)]$ для $ f(n) = \Omega (\log n)$.
\end{thm}
\begin{proof}
	Построим граф псеводоконфигураций: вершина --- состояние, содержимое \textit{рабочих} лент и положение \textit{всех} головок.

	Всего памяти для хранения псевдоконфигураций требуется  $ 2^{f(n)\cdot k}$ памяти: всего состояний конечное число, положение занимает $ \log n$, остается содержимое.

	Считаем, что у нас только одно принимающее состояние. 

	Заметим, что граф нам нужен, когда хотим выяснить достижимость за один шаг.

	Делаем такой же стек, как и выше, на него уходит порядка $ f(n)$ памяти (на каждую <<задачу>> три числа: начало, конец и длина).

	Теперь посмотрим на <<задачу>> $ (z, t, 0)$. Мы хотим выяснить, есть ли переход из $ z$ в $ t$. Для этого сравниваем их посимвольно, кроме состояния. 

	Вспоминаем, что мы проверяем, что данная НМТ $ M$ на данном входе выдает $ 1$. Поэтому для сравнения $ z$ и $ t$ осталось посмотреть табличку перехода $ M$ и на текущий символ на входной ленте (его индекс хранится вместе с рабочими индексами) и понять, можно ли из $ z$ получить $ t$.  

	Так как один стек занимает $ \O(f(n))$ памяти, то для всей работы достаточно $ \O(f^2(n))$.
\end{proof}
\begin{cor}
    $ \PSPACE = \NPSPACE$
\end{cor}

\begin{defn}[$ \L$ и $ \NL$]
	\index{\L}
	Класс языков $ \L$ --- множество языков, разрешимых на детерминированной машине Тьюринга с использованием $\O(\log n)$ дополнительной памяти для входа длиной $ n$. 
   
    \noindent
    \index{\NL}
    Класс языков $\NL$ --- множество языков, разрешимых на недетерминированной машине Тьюринга с использованием $\O(\log n)$ дополнительной памяти для входа длиной $n$.
\end{defn}
\begin{lm}
	$ \STCON$ является $ \NL$-полной (относительно $ \logspace$-сведений, то есть сводящая функция использует логарифмическую память).
\end{lm}
\begin{proof}
	\begin{itemize}
		\item Принадлежность $ \NL$: храним только текущую вершину и угадываем следующее состояние, пока не дойдем до конца.
		\item Полнота: если есть задача из $ \NL$, то есть НМТ $ M$, которая использует логарифмическую память. 
		
		$M$ принимает вход, если в дереве вычислений есть путь от стартовой вершины до принимающей:
			\[
				M(x) = 1 \Longleftrightarrow start \rightsquigarrow accept
			.\] 
			Поэтому функция сведения должна построить граф по машине Тьюринга для данного входа $ x$.
    \end{itemize}
\end{proof}
\begin{st}
	Для неориентированного графа алгоритм гораздо сложнее: $ \USTCON \in \L$ (Reingold, 2004).
\end{st}
\begin{st}
	Все задачи из $ \L$ являются  $ \L$-полными (относительно $\logspace$ сводимости).
\end{st}

\section{Равномерные полиномиальные схемы}
\begin{defn}\index{равномерное семейство схем}
	Семейство схем $ \{C_n\}_{n \in \N}$ \selectedFont{равномерно}, если существует полиномиальный алгоритм $ A$ такой, что $ A(1^{n}) = C_{n}$. 
\end{defn}
\begin{lm}
    Равномерные схемы задают класс $ \P$.
\end{lm}
\begin{proof}
	Полиномиальная МТ на входе $ x$ сначала запускает $ A(\lvert x \rvert )$, потом запускает полученную схему $ C(x)$.

	Наоборот, пусть дана полиномиальная МТ, про вход мы знаем, что  $ \lvert x \rvert = n$, тогда  можно нарисовать схему из состояний, которая будет работать как МТ. Каждый уровень можно породить алгоритмом, который будет их пересчитывать по функции перехода. 
\end{proof}
\begin{defn}\index{\logspace-равномерное семейство схем}
	Семейство схем $ \{C_n\}_{n \in \N}$ \selectedFont{$\logspace$-равномерно}, если существует полиномиальный алгоритм $ A$, использующий $ \O(\log n)$ памяти, такой, что $ A(1^{n}) = C_{n}$. 
\end{defn}

Глубина булевой схемы --- время параллельного вычисления.
\begin{defn}[Nick's class]
	\index{$\NC^{i}$}
	Класс $ \NC^{i} = \left\{ L \mid \text{для } L  \text{ есть } \logspace\text{-равномерные схемы глубины } \O(\log^{i} n) \right \} $.

	\noindent
	Класс\index{\NC} $ \NC = \bigcup_{i} \NC^{i} \subseteq \P$.
\end{defn}
\begin{note}
    Еще есть класс $\ComplexityFont{AC}^i$, который определяется аналогично $\NC^i$, только разрешает степень входа гейта больше двух.
\end{note}

\begin{lm}
	Композиция двух $ \logspace$-функций $ f_2(f_1(x))$ принадлежит $ \logspace$.
\end{lm}
\begin{proof}
    Будем запускать\footnote{считаем, что функции --- МТ, которые принимают аргумент на входной ленте и возвращают результат на выходной} и $ f_1$ и $ f_2$. Храним счетчики позиций на лентах: для $ f_1$ на выходе и для $ f_2$ на входе.

	Пусть $ f_2$ нужен очередной бит входа с номером $ y_i$. Запускаем $ f_1$, как только ее счетчик достигает $ y_i$, останавливаем $ f_1$, продолжаем работу $ f_2$.

	Если $ f_2$ требуется новый $ y_j$ (возможно $ j < i$), то мы запускаем $ f_1$ снова (с самого начала). 
	
	В итоге у нас хранится только вход для $f_1$ и индексы, а он не входит в рабочую память.

	И так пока $ f_2$ не закончит. Во время работы $ f_1, f_2$ запущено только два экземпляра, поэтому память логарифмическая (для счетчиков -- логарифм размера ленты).
	\begin{note}
	    $ f_1$ мы моделируем без выходной ленты, помним только последний символ.
	\end{note}
\end{proof}

\begin{thm}
	Если $ L$ --- $ \P$-полный (относительно $ \logspace$-сводимости), то
	$$ L \in \L \Longleftrightarrow \P = \L.$$
\end{thm}
\begin{proof}
\begin{itemize}
    \item Докажем, что $L \in \L \Rightarrow \P = \L$.
		Если $ L' \in \P$, то он сводится к $ L$, так как второй $ \P$-полный. А $ L$ решается $ \logspace$-алгоритмом. 
		Получили две функции, обе $ \logspace$, значит, по доказанной лемме их композиция тоже $\logspace$, поэтому $ L' \in \L$.
	
		С другой стороны, $\L \subset \P$, так как $L\in\P$ и $L$ является $\L$-полной. 
	\item В обратную сторону. Пусть $\P = \L$, по условию $L$ --- \P-полный,  поэтому $L \in \L = \P$.
\end{itemize}
\end{proof}
